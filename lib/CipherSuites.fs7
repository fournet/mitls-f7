module CipherSuites

open Bytes
open Algorithms
open Error

type cipherSuite = // internal; kept abstract in the .fsi
    | NullCipherSuite
    | CipherSuite of kexAlg * authencAlg
    | OnlyMACCipherSuite of kexAlg * hashAlg
    | SCSV of SCSVsuite
    | Unknown of b:bytes{Length(b)=2}  

type cipherSuites = cipherSuite list

type Compression =
    | Null
    | UnknownComp

//CF fs7 does *NOT* support enums.
//Why using them instead of ADTs, e.g. here? Can we get rid of UnknownPV? 
type ProtocolVersionType =
    | UnknownPV = -1
    | SSL_3p0   = 10
    | TLS_1p0   = 20
    | TLS_1p1   = 30
    | TLS_1p2   = 40

type KnownPV = pv:ProtocolVersionType{pv = SSL_3p0 \/ pv = TLS_1p0 \/ pv = TLS_1p1 \/ pv = TLS_1p2}

//CF Bad name. We'll need VersionBytes to be injective; we can verify it in principle.
function val VersionBytes: ProtocolVersionType -> bytes
val versionBytes: pv:KnownPV -> b:bytes{Length(b) = 2 /\ b = VersionBytes(pv)}
val parseVersion: b:bytes{Length(b) = 2} -> pv:ProtocolVersionType{ b= VersionBytes(pv)}
val minPV: a:KnownPV -> b:KnownPV -> c:KnownPV{(a < b /\ c = a) \/ (a >= b /\ c = b)}

(* FIXME: same duplication between logical and concrete function definitions, 
   already seen in Algorithms. *)
function val IsNullCiphersuite: cipherSuite -> bool
function val IsOnlyMACCiphersuite: cipherSuite -> bool
val nullCipherSuite: c:cipherSuite{IsNullCiphersuite(c)}
val isNullCipherSuite: c:cipherSuite -> r:bool{r=true => IsNullCiphersuite(c)}
val isOnlyMACCipherSuite: c:cipherSuite -> r:bool{r=true => IsOnlyMACCiphersuite(c)}

(* TODO: predicates similar to the ones above, to be done when handling handshake *)
val isAnonCipherSuite: cipherSuite -> bool
val cipherSuiteRequiresKeyExchange: cipherSuite -> bool
val canEncryptPMS: cipherSuite -> bool
val contains_TLS_EMPTY_RENEGOTIATION_INFO_SCSV: cipherSuites -> bool
val verifyDataLen_of_ciphersuite: cipherSuite -> int
val prfHashAlg_of_ciphersuite: cipherSuite -> hashAlg
val verifyDataHashAlg_of_ciphersuite: cipherSuite -> hashAlg

val macAlg_of_ciphersuite: cipherSuite -> hashAlg
val encAlg_of_ciphersuite: cipherSuite -> cipherAlg

val compression_of_bytes: b:bytes{Length(b)=1} -> Compression
val compressionBytes: Compression -> b:bytes{Length(b)=1}
(* FIXME: We can say that the length of the following byte array is the same of the length of the returned list.
   1) do we want/need to say this?
   2) how do we talk about lengths of lists in F7?
   CF: we can even typecheck it, but this is low priority
*)
val compressions_of_bytes: bytes -> Compression list

val bytes_of_cipherSuite: c:cipherSuite -> b:bytes{Length(b)=2}
val cipherSuite_of_bytes: b:bytes{Length(b)=2} -> cipherSuite

function val CipherSuitesBytes: cipherSuites -> bytes 
// this parsing function may fail if b has the wrong length,
// or if we were strict on unknown ciphersuites
val cipherSuites_of_bytes: b:bytes -> (css:cipherSuites {b=CipherSuitesBytes(css)}) Result
val bytes_of_cipherSuites: css:cipherSuites -> b:bytes {b=CipherSuitesBytes(css)}

val getKeyExtensionLength: ProtocolVersionType -> cipherSuite -> int

val PVRequiresExplicitIV: ProtocolVersionType -> bool

(* Not for verification, just to run the implementation *)

type cipherSuiteName =
    | TLS_NULL_WITH_NULL_NULL            

    | TLS_RSA_WITH_NULL_MD5              
    | TLS_RSA_WITH_NULL_SHA              
    | TLS_RSA_WITH_NULL_SHA256           
    | TLS_RSA_WITH_RC4_128_MD5           
    | TLS_RSA_WITH_RC4_128_SHA           
    | TLS_RSA_WITH_3DES_EDE_CBC_SHA      
    | TLS_RSA_WITH_AES_128_CBC_SHA       
    | TLS_RSA_WITH_AES_256_CBC_SHA       
    | TLS_RSA_WITH_AES_128_CBC_SHA256    
    | TLS_RSA_WITH_AES_256_CBC_SHA256 
       
    | TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA   
    | TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA   
    | TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA  
    | TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA  
    | TLS_DH_DSS_WITH_AES_128_CBC_SHA    
    | TLS_DH_RSA_WITH_AES_128_CBC_SHA    
    | TLS_DHE_DSS_WITH_AES_128_CBC_SHA   
    | TLS_DHE_RSA_WITH_AES_128_CBC_SHA      
    | TLS_DH_DSS_WITH_AES_256_CBC_SHA    
    | TLS_DH_RSA_WITH_AES_256_CBC_SHA    
    | TLS_DHE_DSS_WITH_AES_256_CBC_SHA   
    | TLS_DHE_RSA_WITH_AES_256_CBC_SHA    
    | TLS_DH_DSS_WITH_AES_128_CBC_SHA256 
    | TLS_DH_RSA_WITH_AES_128_CBC_SHA256 
    | TLS_DHE_DSS_WITH_AES_128_CBC_SHA256
    | TLS_DHE_RSA_WITH_AES_128_CBC_SHA256
    | TLS_DH_DSS_WITH_AES_256_CBC_SHA256 
    | TLS_DH_RSA_WITH_AES_256_CBC_SHA256 
    | TLS_DHE_DSS_WITH_AES_256_CBC_SHA256
    | TLS_DHE_RSA_WITH_AES_256_CBC_SHA256

    | TLS_DH_anon_WITH_RC4_128_MD5       
    | TLS_DH_anon_WITH_3DES_EDE_CBC_SHA  
    | TLS_DH_anon_WITH_AES_128_CBC_SHA
    | TLS_DH_anon_WITH_AES_256_CBC_SHA  
    | TLS_DH_anon_WITH_AES_128_CBC_SHA256
    | TLS_DH_anon_WITH_AES_256_CBC_SHA256

val cipherSuites_of_nameList: cipherSuiteName list -> cipherSuites