module Mac

open Bytes
open Algorithms
open TLSInfo

/// a refined, ideal interface for indexed MACs
/// this file is loosely synchronized with cma/mac2.fs7

type id = TLSInfo.KeyInfo 
predicate val CMA: id -> bool

// id is an abstract index type managed by the protocol
// id may e.g. determine the choice of algorithms, 
// so in principle the sizes should also be indexed by id

//TLS: algorithms and sizes for keys and tags are in algorithms. 
//TLS: how to logically go from id to Algorithms.hashAlg ?
//     this is *some* ki.sinfo.cipher_suite
//     also confusing hash and mac algorithms for now. 

// this could also be imported; we had (;ki) ltext ? 

function val KeySize: id -> int // to be removed? 
val keysize: id:id -> n:int{n=KeySize(id)} 
type (;id:id) keybytes = b:bytes{Length(b)=KeySize(id)}
type (;id:id) key = {bytes: (;id) keybytes} 

function val TagSize: id -> int // to be removed? 
val tagsize: id:id -> n:int{n=TagSize(id)} 
type (;id:id) tag = b:bytes{Length(b) = TagSize(id)}

type text = bytes 
predicate val Msg: (id * text) -> bool

// removed internal stuff for now 

val GEN:    id:id -> (;id) key
val MAC:    id:id -> k:(;id) key -> t:text{Msg(id,t)} -> (;id) tag
val VERIFY: id:id -> k:(;id) key -> t:text -> (;id) tag -> 
  v:bool{ (v=true (*/\ CMA(id)*) ) => Msg(id,t) }
val LEAK:   id:id {!t. Msg(id,t)} -> (;id) key -> (;id) keybytes
val COERCE: id:id {!t. Msg(id,t)} -> (;id) keybytes -> (;id) key
