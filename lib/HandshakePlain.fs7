module HandshakePlain

open Bytes
open TLSInfo
open DataStream

// protocol-specific abstract fragment,
// and associated functions (never to be called with ideal functionality)
type (;ki:KeyInfo) stream = (;ki)DataStream.stream
type (;ki:KeyInfo,s:(;ki) stream, rg:range) fragment = (;ki,s,rg)delta
type (;ki:KeyInfo,s:(;ki) stream, rg:range) ccsFragment = (;ki,s,rg)delta

// Deprecated. Use functions in DataStream module
// predicate EmptyStream of KeyInfo * stream
// predicate ConcatStream of KeyInfo * stream * fragment * stream
// predicate ConcatCCSStream of KeyInfo * stream * ccsFragment * stream
// val emptyStream: ki:KeyInfo -> s:(;ki)stream{EmptyStream(ki,s)}
// val addFragment: ki:KeyInfo -> s:(;ki)stream -> 
//                  r:DataStream.range -> f:(;ki,s,r) fragment -> 
//                  s':(;ki)stream{ConcatStream(ki,s,f,s')}
// val addCCSFragment: ki:KeyInfo -> s:(;ki)stream -> 
//                  r:DataStream.range -> f:(;ki,s,r) ccsFragment -> 
//                  s':(;ki)stream{ConcatCCSStream(ki,s,f,s')}
 
// This predicate must be assumed (or defined) by the application creating its own deltas
predicate HandshakeFragment of KeyInfo * stream * range * bytes
predicate CCSFragment of KeyInfo * stream * range * bytes


val repr: ki:KeyInfo{not Safe(ki)} -> s:stream -> r:range -> (;ki,s,r)fragment -> bytes
val fragment: ki:KeyInfo{not Safe(ki)} -> s:stream -> r:range -> bytes -> (;ki,s,r)fragment
val ccsRepr: ki:KeyInfo{not Safe(ki)} -> s:stream -> r:range -> (;ki,s,r)ccsFragment -> bytes
val ccsFragment: ki:KeyInfo{not Safe(ki)} -> s:stream -> r:range -> bytes -> (;ki,s,r)ccsFragment

// FIXME: Cannot typeckeck! The application must be aware of ranges and streams when
// creating its own deltas!
val makeFragment: ki:KeyInfo -> b:bytes -> (r:range * fragment) * bytes
val makeCCSFragment: ki:KeyInfo -> b:bytes -> (r:range * fragment) * bytes
// We would like something like:
// val makeFragment: ki:KeyInfo -> s:stream -> r:range -> b:(;r)rbytes -> (;ki,s,r)fragment{Safe(ki) => HandshakeFragment(ki,s,r,b)}