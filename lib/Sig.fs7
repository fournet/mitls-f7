module Sig

// TODO still many details to fix.

open Bytes
open TLSConstants

(* TLS uses three signatures algorithms, together with hash algorithm.
   We verify TLS security relative to those *combinations* of algorithms
   that provide CMA-security, as specified in this interface. 
   However, none of them are CMA-secure in the standard model under an 
   assumption much weaker than "This scheme is secure".

   This interface is adapted from the one described in CCS'11:

       Cedric Fournet, Markulf Kohlweiss, Pierre-Yves Strub: Modular 
       code-based cryptographic verification. ACM Conference on Computer 
       and Communications Security 2011: 341-350

   Its implementation is trusted, not verified. *)

// CF we should verify its ideal implementation!?

(*********************** Cryptographic agility **************************** 

   note that the same key may be used with different hashes. 
   so we require some joint security assumption for them

   TLS 1.2 provides explicit support for it:
   [1.2] - Substantial cleanup to the client's and server's ability to
           specify which hash and signature algorithms they will accept.
           Note that this also relaxes some of the constraints on signature
           and hash algorithms from previous versions of TLS.
***************************************************************************)

// TODO: there is some adhocness processing of those algs left in Handshake.fs
  
// implements SignatureAndHashAlgorithm, with fewer values for hashAlg
//MK: I don't understand this comment.
type alg   = sigHashAlg //defined in TLSConstants.fs7: sigAlg * hashAlg

type text = bytes
type (;a:alg) sigv = bytes
  // TODO: specify their size, 36 with RSA, 20 with DSA
  // with TLS 1.2, this explicitly contains a; see DigitallySigned struct 

// Summary of the extension logic for the client:
// - specific to TLS 1.2
// - cs indicates sigAlg but not hashAlg, but "this is historical"
// - extension indicates supported algs (not necessarily following the cs)
// - no extension == client supports exactly the default alg

// let defaultAlg cs =
//   let a = 
//     match cs with 
//     | RSA | DH_RSA | DHE_RSA | RSA_PSK (* | ECDH_RSA | ECDHE_RSA *) -> RSA
//     | DH_DSS | DHE_DSS                                              -> DSA
//     | ECDH_ECDSA | ECDHE_ECDSA                                      -> ECDSA in
//   (a, SHA1)

// TODO: how to extract & check the algs from certs?
// TODO: how does the server control the choice of algorithms? For now hardcoded.

//********************** Ideal Functionality for Signing *********************** 
private type (;a:alg) pkey = {pkey : CoreSig.sigpkey * hashAlg }
//#begin-abstraction
private type (;a:alg) skey = {skey: CoreSig.sigskey * hashAlg; pub: (;a) pkey}
//#end-abstraction

function val PK: 'a -> 'b // a:alg * (;a)skey -> vkey
private definition !sk. PK(sk) = sk.pub

predicate Msg of a:alg * (;a)pkey * text 
predicate type pred = Honest of a:alg * (;a) pkey
predicate Strong of alg
private definition !a. Strong(a) <=> (a = (SA_DSA,SHA384))

val gen:     a:alg -> pk:(;a) pkey * sk:(;a) skey { pk = PK(sk) }
val sign:    a:alg -> sk:(;a) skey -> t:text{Msg(a,PK(sk),t)} -> (;a) sigv
val verify:  a:alg -> pk:(;a) pkey -> t:text -> m:(;a) sigv -> 
  b:bool {(b=true /\ Strong(a) /\ Honest(a,pk)) => Msg(a,pk,t)}

type honest_entry = (a:alg * sk:(;a)skey * pk:(;a)pkey{Honest(a,pk) /\ pk = PK(sk)})
private val honest_log: (honest_entry list) ref
private val has_pk: a:alg -> pk:(;a)pkey -> 
          (honest_entry list) -> b:bool{(b = true => Honest(a,pk))}

val pk_of: a:alg -> sk:(;a) skey -> pk:(;a) pkey{pk = PK(sk)}
val honest: a:alg -> pk: (;a) pkey -> b:bool{(b = true /\ Honest(a,pk)) \/ (b=false /\ not Honest(a,pk))}
val strong: a:alg -> b:bool{(b = true /\ Strong(a)) \/ (b = false /\ not Strong(a))}

private val consHonestLog: a:alg -> sk:(;a)skey -> pk:(;a) pkey{Honest(a,pk) /\ pk = PK(sk)} -> (honest_entry list) -> honest_entry list

type entry = (a:alg * pk:(;a) pkey * t:text){ Msg(a,pk,t) }
private val log: entry list ref
private val consLog: a:alg -> pk:(;a) pkey -> t:text {Msg(a,pk,t)} -> entry list -> entry list
private val has_mac: a:alg -> pk:(;a) pkey -> t:text -> entry list -> b:bool{b = true => Msg(a,pk,t)}

val coerce:  a:alg -> p:(;a) pkey{not Honest(a,p)} -> CoreSig.sigskey -> s:(;a)skey{p = PK(s)}
val leak:    a:alg -> s:(;a) skey{not Honest(a,PK(s))} -> CoreSig.sigskey

private val create_pkey: a:alg -> CoreSig.sigpkey -> (;a)pkey

// TODO: adjust compromise model, connect it to Cert (mostly for the benefit of the adversary)
// TODO: MK: our current implementation does not allow access to the gen function. 
// TODO: All secret keys used in runs of our protocol are thus coerced keys and we thus don't have any safe instances
