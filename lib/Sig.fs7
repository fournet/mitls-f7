module Sig

open Bytes
open TLSConstants

// TLS uses three signatures algorithms, together with an hash algorithm.
// We verify TLS security relative to those combinations of algorithms
// that provide CMA-security, as specified in this interface. 
// However, none of them are CMA-secure in the standard model.

// This interface is adapted from the one described in CCS'11.
// Its implementation is trusted, not verified.

//*********************** Cryptographic agility **************************** 

// note that the same key may be used with different hashes. 
// so we require some joint security assumption for them

// TLS 1.2 provides explicit support for it:
// [1.2] - Substantial cleanup to the client's and server's ability to
//         specify which hash and signature algorithms they will accept.
//         Note that this also relaxes some of the constraints on signature
//         and hash algorithms from previous versions of TLS.

// TODO: there is some adhocness processing of those algs left in Handshake.fs
  
 // implements SignatureAndHashAlgorithm, with fewer values for hashAlg
type alg   = sigAlg * hashAlg

type text = bytes
type (;a:alg) sigv = bytes
  // TODO: specify their size, 36 with RSA, 20 with DSA
  // with TLS 1.2, this explicitly contains a; see DigitallySigned struct 

// Summary of the extension logic for the client:
// - specific to TLS 1.2
// - cs indicates sigAlg but not hashAlg, but "this is historical"
// - extension indicates supported algs (not necessarily following the cs)
// - no extension == client supports exactly the default alg

// let defaultAlg cs =
//   let a = 
//     match cs with 
//     | RSA | DH_RSA | DHE_RSA | RSA_PSK (* | ECDH_RSA | ECDHE_RSA *) -> RSA
//     | DH_DSS | DHE_DSS                                              -> DSA
//   (*| ECDH_ECDSA | ECDHE_ECDSA                                      -> ECDSA in
//   (a, SHA1)

// TODO: how to extract & checks the algs from certs?
// TODO: how does the server control the choice of algorithms? For now hardcoded.

//********************** Ideal Functionality for Signing *********************** 

type (;a:alg) skey
type (;a:alg) pkey

function val PK: 'a -> 'b // a:alg * (;a)skey -> vkey
predicate val Msg: a:alg * (;a)pkey * text -> bool

// FIXME: Local dummy definition of "Strong", until we relocate CMA/CTXT and the like to TLSConstants.
predicate val Strong: 'a (* alg *) -> bool

val gen:     a:alg -> pk:(;a) pkey * sk:(;a) skey { pk = PK(sk) }
val sign:    a:alg -> sk:(;a) skey -> t:text{Msg(a,PK(sk),t)} -> (;a) sigv
val verify:  a:alg -> pk:(;a) pkey -> t:text -> m:(;a) sigv -> b:bool {b=true /\ (Strong(a) => Msg(a,pk,t))}


// Commented out as it depends on core crypto and is not used by ideal functionality
(* 
function val sigalg_of_skeyparams : CoreSig.sigskey -> sigAlg
function val sigalg_of_pkeyparams : CoreSig.sigpkey -> sigAlg

private definition !m, e. sigalg_of_skeyparams (CoreSig.SK_RSA (m, e)) = SA_RSA
private definition !m, e. sigalg_of_pkeyparams (CoreSig.PK_RSA (m, e)) = SA_RSA
private definition !x, p. sigalg_of_skeyparams (CoreSig.SK_DSA (x, p)) = SA_DSA
private definition !y, p. sigalg_of_pkeyparams (CoreSig.PK_DSA (y, p)) = SA_DSA

// AP: These are "Coerce"-like.
val create_skey: h:chash -> k:skeyparams -> (;(sigalg_of_skeyparams(k), h))skey
val create_pkey: h:chash -> k:pkeyparams -> (;(sigalg_of_pkeyparams(k), h))vkey
// AP: And these are leak-like.
val repr_of_skey: skey -> CoreSig.sigskey * hashAlg
val repr_of_pkey: pkey -> CoreSig.sigpkey * hashAlg

// TODO: adjust compromise model, connect it to Cert (mostly for the benefit of the adversary)
*)