module StatefulPlain
open Bytes
open TLSConstants
open TLSInfo

//------------------------------------------------------------------------------------------------------
// `Plain' interface towards StatefulAEAD
//------------------------------------------------------------------------------------------------------

function val ADLength: epoch -> nat
private definition !e. 
    (EpochSI(e).protocol_version = SSL_3p0  /\ ADLength(e) = 1) \/
	(EpochSI(e).protocol_version <> SSL_3p0 /\ ADLength(e) = 3)

type (;e:epoch) adata = (b:bytes){Length(b) = ADLength(e)} 

function val ADBytes: (epoch * ContentType) -> bytes //(;e)StatefulPlain.adata
private definition !e,ct.
	( EpochSI(e).protocol_version = SSL_3p0 /\
	  ADBytes(e,ct) =
		CTBytes(ct) ) \/
	( EpochSI(e).protocol_version <> SSL_3p0 /\
          ADBytes(e,ct) =
		(CTBytes(ct) @| VersionBytes(EpochSI(e).protocol_version)))

private val makeAD: e:succEpoch -> ct:ContentType ->
	  ad: (;e)adata{ad=ADBytes(e,ct)}
private val parseAD: e:succEpoch -> ad:(;e)adata -> ct:ContentType{ad=ADBytes(e,ct)}

function val ParseAD: (e:epoch * (;e)adata) -> ContentType
private definition !e,ct. ParseAD(e,ADBytes(e,ct)) = ct

private type (;e:epoch,ad:(;e)adata,r:range)fragment = {contents: (;e,ParseAD(e,ad),r)TLSFragment.fragment}

private type (;e:epoch) prehistory = (ad:(;e)adata * r:range * f:(;e,ad,r)fragment) list

function val HLength: e:epoch * (;e)prehistory -> nat
private definition !e.          HLength(e,[]) = 0
private definition !e,h,ad,r,f. HLength(e,(ad,r,f)::h) = HLength(e,h)+1

type (;e:epoch)history = (sn:nat * ph:(;e)prehistory){sn = HLength(e,ph)}
function val SeqN: e:epoch * (;e)history -> nat
assume !e,sn,h. SeqN(e,(sn,h)) = sn
predicate EmptyHistory of e:epoch * (;e) history
function val ExtendHistory: e:epoch * ad:(;e) adata * h:(;e) history * r:range * (;e,ad,r) fragment -> 'a //(;e)history
private definition !e,h. EmptyHistory(e,h) <=> h = (0,[])
private definition !e,n,h,d,r,f. ExtendHistory(e,d,(n,h),r,f) = (n+1,(d,r,f)::h)

predicate StAESent of e:epoch * ad:(;e)adata *  h:(;e)history * r:range * (;e,ad,r)fragment

function val Multiplexed: e:epoch * (;e) history -> 'b //(;e)TLSFragment.history
private definition !e,sh,h. EmptyHistory(e,sh) /\
   TLSFragment.EmptyHistory(e,h) => h = Multiplexed(e,sh)
private definition !e,sh,sh',h,ct,r,f. 
  (sh' = ExtendHistory(e,ADBytes(e,ct),sh,r,f) /\
   h = Multiplexed(e,sh)) => 
  (Multiplexed(e,sh') = TLSFragment.ExtendHistory(e,ct,h,r,f.contents))

private definition !e,sh,ct,r,f. 
	StAESent(e,ADBytes(e,ct),sh,r,f) <=>  TLSFragment.RecordSent(e,ct,Multiplexed(e,sh),r,f.contents)

private type (;e:epoch,ad:(;e)adata,h:(;e)history,r:range) plain =
	f:(;e,ad,r)fragment{Auth(e) => StAESent(e,ad,h,r,f)}

val plain: e:succEpoch{not Auth(e)} -> h:(;e)history -> ad:(;e)adata -> r:range -> (;r)rbytes -> (;e,ad,h,r) plain
val repr:  e:succEpoch{not Safe(e)} -> h:(;e)history -> ad:(;e)adata -> r:range -> (;e,ad,h,r) plain -> (;r)rbytes

//------------------------------------------------------------------------------------------------------
// `internal' interface towards TLSFragment
//------------------------------------------------------------------------------------------------------

val emptyHistory: e:epoch -> h:(;e)history{EmptyHistory(e,h)}
private val consHistory: e:epoch -> h:(;e)prehistory ->
	ad:(;e)adata -> r:range -> x:(;e,ad,r)fragment ->
	h':(;e)prehistory{h' = (ad,r,x)::h}
val addToHistory: e:epoch -> ad:(;e)adata ->
	h:(;e)history -> r:range -> f:(;e,ad,h,r)plain ->
	h':(;e)history{h' = ExtendHistory(e,ad,h,r,f)}


//------------------------------------------------------------------------------------------------------
// Auxiliary Definitions and Assumes for Typing
//------------------------------------------------------------------------------------------------------

// Sent grows linearly
// assume !e.          Sent(e,(0,[]))
// assume !e,h,ad,r,x. Sent(e,ExtendHistory(e,h,ad,r,x)) => Sent(e,h)
// assume !e,h,h'. (Auth(e) /\ Sent(e,h) /\ Sent(e,h') /\ SeqN(e,h) = SeqN(e,h')) => h = h'

val RecordPlainToStAEPlain: e:succEpoch -> ct:ContentType -> h:(;e) TLSFragment.history ->
	st:(;e) history{h = Multiplexed(e,st)} -> rg:range -> f:(;e,ct,h,rg) TLSFragment.plain -> 
	sf:(;e,ADBytes(e,ct),st,rg) plain

val StAEPlainToRecordPlain: e:succEpoch -> ct:ContentType -> h:(;e) TLSFragment.history ->
	st:(;e) history{h = Multiplexed(e,st)} -> rg:range -> 
    d:(;e,ADBytes(e,ct),st,rg) plain ->
	f:(;e,ct,h,rg) TLSFragment.plain