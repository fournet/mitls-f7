module StatefulPlain
open Bytes
open Formats
open TLSInfo
open DataStream
// open AEADPlain // Do not open, or AEADPlain "module" and AEADPlain "function" will clash. We should stop using the same name for modules, types and functions, as this creates names clashes everywhere!

type (;ki:epoch) data = (b:bytes){Length(b) = AEPlain.ADLength(ki) - 8}


private type (;ki:epoch)prehistory =
	| Empty
	| ConsHistory of h:(;ki)prehistory * ad:(;ki)data * r:range * x:(;ki,r)Fragment.fragment //{Fragment(ki,h,ad,r,x)}

function val HLength: ki:epoch * (;ki)prehistory -> nat
private assume !ki. HLength(ki,Empty) = 0
private assume !ki,h,ad,r,x. HLength(ki,ConsHistory(h,ad,r,x)) = HLength(ki,h)+1

predicate type preds = History of ki:epoch * ( nat * (;ki)prehistory )

private type (;ki:epoch)history = (sn:nat * ph:(;ki)prehistory){History(ki,(sn,ph)) /\ sn = HLength(ki,ph)}

function val SeqN: ki:epoch * (;ki)history -> nat
private assume !ki,sn,h. SeqN(ki,(sn,h)) = sn

predicate Fragment of ki:epoch * (;ki)history * (;ki)data * r:range * (;ki,r)Fragment.fragment

private type (;ki:epoch,h:(;ki)history,ad:(;ki)data,range:range) prefragment =
	x:(;ki,range)Fragment.fragment{Auth(ki) => Fragment(ki,h,ad,range,x)}

private type (;ki:epoch,h:(;ki)history,ad:(;ki)data,range:range) fragment =
	{contents: (;ki,h,ad,range)prefragment}

function val SAEADContents: 'a -> 'b
assume !f. SAEADContents(f) = f.contents

predicate EmptyHistory of ki:epoch * (;ki) history
function val ExtendHistory: ki:epoch * h:(;ki) history * (;ki) data * r:range * (;ki,r) Fragment.fragment -> 'a
private assume !ki. EmptyHistory(ki,(0,Empty))
private assume !ki,n,h,d,r,f. ExtendHistory(ki,(n,h),d,r,f) = (n+1,ConsHistory(h,d,r,f))

val emptyHistory: ki:epoch -> h:(;ki)history{EmptyHistory(ki,h)}
private val consHistory: ki:epoch -> h:(;ki)prehistory ->
	ad:(;ki)data -> r:range -> x:(;ki,r)Fragment.fragment ->
	h':(;ki)prehistory{h' = ConsHistory(h,ad,r,x)}
val addToHistory: ki:epoch -> h:(;ki)history ->
	ad:(;ki)data -> r:range -> x:(;ki,h,ad,r)fragment ->
	h':(;ki)history{h' = ExtendHistory(ki,h,ad,r,x)}

function val MakeAD:  ki:epoch * (;ki)history * (;ki)data -> bytes//(;ki)AEADPlain.data
assume !ki,h,ad. MakeAD(ki,h,ad) = IntBytes(8,SeqN(ki,h)) @| ad

val makeAD:  ki:epoch -> h:(;ki)history -> ad:(;ki)data ->
	b:(;ki)AEADPlain.data{b=MakeAD(ki,h,ad)}

val fragment: ki:epoch{not Auth(ki)} -> hh:(;ki)history -> ad:(;ki)data -> r:range -> (;r)rbytes -> (;ki,hh,ad,r) fragment
val repr: ki:epoch{not Safe(ki)} -> h:(;ki)history -> ad:(;ki)data -> r:range -> (;ki,h,ad,r) fragment -> (;r)rbytes

val contents:  ki:epoch -> h:(;ki)history -> ad:(;ki)data -> r:range -> (;ki,h,ad,r)fragment ->
	x:(;ki,r)Fragment.fragment{Auth(ki) => Fragment(ki,h,ad,r,x)}
val construct: ki:epoch -> h:(;ki)history -> ad:(;ki)data -> r:range ->
	x:(;ki,r)Fragment.fragment{Auth(ki) => Fragment(ki,h,ad,r,x)} -> (;ki,h,ad,r)fragment

val FragmentToAEADPlain: ki:epoch -> h:(;ki)history -> ad:(;ki)data -> r:range -> (;ki,h,ad,r)fragment ->
	(;ki,r,MakeAD(ki,h,ad))AEADPlain.AEADPlain

val AEADPlainToFragment: ki:epoch -> h:(;ki)history -> ad:(;ki)data -> r:range ->
	(;ki,r,MakeAD(ki,h,ad))AEADPlain.AEADPlain -> (;ki,h,ad,r)fragment

assume !ki,ad,r,x. AEADPlain.AEADSays(ki,r,ad,x) <=> ?h,ad'. 
  ad = MakeAD(ki,h,ad') /\ 
  History(ki,h) /\ Fragment(ki,h,ad',r,x)

ask !ki,ad,h,ad',r,x. (ad = MakeAD(ki,h,ad') /\ History(ki,h) /\ Fragment(ki,h,ad',r,x)) => AEADPlain.AEADSays(ki,r,ad,x)

ask !ki,ad,h,h',ad',ad''. ad = MakeAD(ki,h,ad') /\ ad = MakeAD(ki,h',ad'') => 
    (SeqN(ki,h) = SeqN(ki,h') /\ ad' = ad'')

// History and seqn are bijective
assume !ki,h,h'. History(ki,h) /\ History(ki,h') /\ SeqN(ki,h) = SeqN(ki,h') => h = h'
assume !ki. History(ki,(0,Empty))

ask !ki,ad,h,ad',r,x. (ad = MakeAD(ki,h,ad') /\ History(ki,h) /\ AEADPlain.AEADSays(ki,r,ad,x)) => Fragment(ki,h,ad',r,x)


