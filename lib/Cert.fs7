module Cert 

(* Trusted Key and Certificate Store *)

open Bytes
open Error
open TLSConstants

type hint = string
type cert = bytes

type chain = cert list
type sign_cert = (chain * a:Sig.alg * (;a)Sig.skey) option
type enc_cert = (chain * RSAKey.sk) option

val for_signing : Sig.alg list -> hint -> Sig.alg list -> sign_cert
val for_key_encryption : Sig.alg list -> hint -> enc_cert

val get_public_signing_key : cert -> a:Sig.alg -> (;a)Sig.pkey Result
val get_public_encryption_key : cert -> RSAKey.pk Result

val is_for_signing:        cert -> bool
val is_for_key_encryption: cert -> bool

function val SigPKCert: cert list * a:Sig.alg -> 'a //(;a)Sig.pkey
val get_chain_public_signing_key : c:chain -> a:Sig.alg -> (pk:(;a)Sig.pkey{pk=SigPKCert(c,a)}) Result

function val RSAPKCert: cert list -> RSAKey.pk
val get_chain_public_encryption_key : c:chain -> (pk:RSAKey.pk{pk=RSAPKCert(c)}) Result

val is_chain_for_signing:        chain -> bool
val is_chain_for_key_encryption: chain -> bool

val get_chain_key_algorithm : chain -> TLSConstants.sigAlg option

function val CN: chain -> hint
val get_hint: c:chain -> (cn:hint{cn=CN(c)}) option

val validate_cert_chain : Sig.alg list -> chain -> bool


(* ---- TLS-specific encoding ---- *)

private val consCertificateBytes: c:bytes -> a:bytes ->
	b:bytes{B(b)=VLBytes(3,c) @| a}

function val CertificateListBytes: chain -> cbytes
//private definition !bl. CertificateMsg(bl) = MessageBytes(HT_certificate,VLBytes(3,UnfoldBack(bl,empty_bytes)))

val certificateListBytes: cl:chain ->
	b:bytes{B(b)=VLBytes(3,CertificateListBytes(cl))}
val parseCertificateList: b:bytes -> acc:chain ->
	(cl:chain{(* ?l. cl = l @ acc /\ b=CertificateListBytes(l) *)
		acc = [] => B(b)=CertificateListBytes(cl)}) Result

//AP: Commenting out to let typeckeching go through

(*FIXME

// long-term key repository (part of the handshake implementation):
//
// an abstract interface for creating and storing long-term keypairs:
// the handshake may lookup the private key associated with any stored keypair
// when running a session parameterized by the corresponding public key

val pk = bytes       // any bytes defines some principal identity 
val template = bytes // some unspecified parameters for keys

// our interface hides the co-existence of keypairs for different algorithms 
// as controlled by the first part of the ciphersuite; for instance template
// may specify which algorithm & keylength to use; internal lookups may
// fail when the stored algorithm does not match the one requested by the 
// ciphersuite; and secret keys may be implemented as 
//
// type sk = DHSecret of DH.s | RSAPrivateKey of RSA.s | ... 

predicate val Honest: pk -> bool
// event tracking correct key generations
// (defined as the indexes of the created key log)

val create: template -> (pk:pk {Honest(pk)}) option 
// correctly produces and stores a fresh keypair

val coerce: template -> bytes -> pk option
// stores a chosen keypair, thereby modelling static compromise
// no need to guarantee {not(Honest(pk))} ? 

// ideally, both calls above return None in case the public key
// is already stored, so that created and coerced keys never clash.

// certificate chains (user-defined)
//
// HS carries certificate chains indicating which key to use 
// it is up to the user to produce certificates from public keys,
// and conversely to validate certificate chains upon request

type certs = bytes

// parsing function extracting the endorsed public key
// from any certificate chain (user-defined, no validity checks) 
function val CertKey: certs -> pk option
val certkey: c:certs -> o:pk option {o = CertKey(c)}

//CF: note on the current implementation:
//CF: - [RSA] implements long-term keys
//CF: - we probably do not support DH yet
//CF: - [Certificate] implements X509 certificate processing
//CF: - [Handshake] implements parsing of certificate chains into Certificate.cert list
//CF: - we do not provide concrete long-term key & cert generation 

//MK: should we define pk as a sumtype of (;a)Sig.pkey and RSAKey.pk, rather than as bytes? 
//MK: can we then define Honest in terms of HonestSig and HonestRSAKey?
//MK: should we plan ahead for static DH??


*)
