module Algorithms

(* Identifiers and sizes for the TLS crypto algorithms *)

open Bytes

(* Not abstract, but meant to be used only by crypto modules and CipherSuites *)

type kexAlg =  (* all these kex have server-auth & optional client-auth, *)
               (* except for anon which has nothing *)
    | RSA     // --> client-generated pms encrypted using server's public key
    | DH_DSS  // <-- Certificate(DSA containing g^y); --> g^x then pms = g^xy  //$ reuse of exponentials?
    | DH_RSA  // idem with an RSA cert
    | DHE_DSS // <-- Certificate(DSA); ServerKeyExchange({Cr,Sr,p,g,g^y}signed); --> g^x then pms = g^xy  //$ reuse of exponentials?
    | DHE_RSA
    | DH_anon // --> g^x ; <-- g^y then pms = g^xy ; secure only against passive adversaries

type cipherAlg =
    | RC4_128
    | TDES_EDE_CBC
    | AES_128_CBC
    | AES_256_CBC

type hashAlg =
    | MD5
    | SHA
    | SHA256
    | SHA384

type sigAlg = 
  | SA_RSA
  | SA_DSA 
  | SA_ECDSA

type aeadAlg =
    | AES_128_GCM
    | AES_256_GCM

type authencAlg =
    | MtE of cipherAlg * hashAlg
    | AEAD of aeadAlg * hashAlg

(* With F7, we need to declare both logical length functions
   and their concrete implementations; we still miss a few...
   TODO: use uniform naming convention, e.g. length implements Length
   a nicer F7 could enable homonymous concrete implementations of logical functions *) 

function val EncKeySize: cipherAlg -> int
assume !x. EncKeySize(x) >= 0
// providing an explicit spec at least once; this should be internal
definition EncKeySize(RC4_128)      = 16
definition EncKeySize(TDES_EDE_CBC) = 24
definition EncKeySize(AES_128_CBC)  = 16
definition EncKeySize(AES_256_CBC)  = 32

val encKeySize: a:cipherAlg -> l:nat{l=EncKeySize(a)}

function val BlockSize: cipherAlg -> nat
assume !x. BlockSize(x) >= 0
definition BlockSize(RC4_128)		=  0
definition BlockSize(TDES_EDE_CBC)	=  8
definition BlockSize(AES_128_CBC)	= 16
definition BlockSize(AES_256_CBC)	= 16
val blockSize: a:cipherAlg -> l:nat {l=BlockSize(a)}
val ivSize: a:cipherAlg -> l:nat    {l=BlockSize(a)}

val aeadKeySize: aeadAlg -> int
val aeadIVSize: aeadAlg -> int

function val MacKeySize: hashAlg -> nat
assume !x. MacKeySize(x) >= 0
definition MacKeySize(MD5)		= 16
definition MacKeySize(SHA)		= 20
definition MacKeySize(SHA256)	= 32
definition MacKeySize(SHA384)	= 48
val macKeySize: a:hashAlg -> l:nat{l=MacKeySize(a)}
val macSize:    a:hashAlg -> l:nat{l=MacKeySize(a)}
val hashSize:   a:hashAlg -> l:nat{l=MacKeySize(a)}

(* SSL Constants *)

val ssl_pad1_md5:  bytes  
val ssl_pad2_md5:  bytes
val ssl_pad1_sha1: bytes
val ssl_pad2_sha1: bytes

(* ------------------------------------------------------------------------ *)
(* Key parameters *)
type dsaparams = { p : bytes; q : bytes; g : bytes; }

type skeyparams =
| SK_RSA of bytes * bytes (* modulus x exponent *)
| SK_DSA of bytes * dsaparams

type pkeyparams =
| PK_RSA of bytes * bytes
| PK_DSA of bytes * dsaparams

function val sigalg_of_skeyparams : skeyparams -> sigAlg
function val sigalg_of_pkeyparams : pkeyparams -> sigAlg

private definition !m, e. sigalg_of_skeyparams (SK_RSA (m, e)) = SA_RSA
private definition !x, p. sigalg_of_skeyparams (SK_DSA (x, p)) = SA_DSA

private definition !m, e. sigalg_of_pkeyparams (PK_RSA (m, e)) = SA_RSA
private definition !y, p. sigalg_of_pkeyparams (PK_DSA (y, p)) = SA_DSA
