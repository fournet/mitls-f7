module ENC

(* Bulk encryption for TLS record, agile & assumed conditionally CPA with "Encode" *) 
(* This module is trusted *)
(* TODO write a well-typed ideal functionality; reduce it to its non-agile underlying algorithms, e.g. AES-CBC and GCM *) 

open Bytes
open Encode 
open TLSInfo
open Error

(* CF
// TLSConstant should define  
predicate IND_CPA of epoch 
val ind_cpa: e:epoch -> b:bool{ b = true <=> IND_CPA(e) }
// actually depending only on pv and eAlg in cs
// may be true for all version when trusting RC4 is IND CPA
// may be true for TLS_1p2 when trusting the encAlg is IND CPA
// false in all other cases
*)

// ciphers consist of one or more blocks of bytes.
type cipher = b:bytes{Length(b) <= max_TLSCipher_fragment_length}

private type (;ki:epoch) key = {k:bytes}

type iv = bytes
private type (;ki:epoch) iv3 =
	| SomeIV of iv // SSL_3p0 and TLS_1p0
	| NoIV         // TLS_1p0 and TLS_1p2

private type (;ki:epoch)state =
	{key: (;ki)key;  iv: (;ki)iv3}

type (;ki:epoch)encryptor = (;ki)state
type (;ki:epoch)decryptor = (;ki)state

// We do not use the state, but an abstract ID over it, so that we can link
// encryptor and decryptor states
private function val StateID: ki:epoch * (;ki)state -> int

//val GEN: ki:epoch -> e:(;ki)encryptor * d:(;ki)decryptor{StateID(e)=0 /\ StateID(d)=0}
val GEN: ki:epoch -> (e:(;ki)encryptor{StateID(ki,e)=0}) * (d:(;ki)decryptor{StateID(ki,d)=0}) //syntax error
val LEAK:   ki:epoch{not Safe(ki)} -> (;ki)state -> key:bytes * iv:bytes
val COERCE: ki:epoch{not Safe(ki)} -> key:bytes -> iv:bytes -> (;ki)state

predicate ENCrypted of
  (ki:epoch * tlen:int * int * (;ki,tlen) plain * cipher)

// TODO: We need to refine cipher before applying CPA

val ENC: ki:epoch -> s:(;ki) encryptor -> tlen:nat{tlen <= max_TLSCipher_fragment_length} -> p:(;ki,tlen) plain -> 
  ( (s':(;ki) encryptor{StateID(ki,s') = StateID(ki,s)+1}) *
   (c:cipher{(Safe(ki) => ENCrypted(ki,tlen,StateID(ki,s),p,c)) 
             /\ Length(c)=tlen}) )

val DEC: ki:epoch -> s:(;ki) decryptor -> c:cipher
  {Safe(ki) => (?t,n,p'. ENCrypted(ki,t,n,p',c))} -> 
  ( (s':(;ki) decryptor{StateID(ki,s') = StateID(ki,s)+1}) *
   (p:(;ki,Length(c))plain
   {!t',n',p'. ENCrypted(ki,t',n',p',c) => p=p'}))


type entry = (ki:epoch * tlen:nat * p:(;ki,tlen)Encode.plain * cipher)
val log: entry list ref
val cfind: e:epoch -> c:cipher -> xs: entry list -> (;e,Length(c)) Encode.plain

(*
val ENC: ki:epoch -> s:(;ki) encryptor -> tlen:int -> p:(;ki,tlen) plain -> 
  ( s':(;ki)encryptor *
   c:cipher{StateID(s') = StateID(s)+1 /\ ENCrypted(ki,tlen,StateID(s),p,c) /\ Length(c)=tlen})

val DEC: ki:epoch -> s:(;ki) decryptor -> c:cipher -> 
  (s':(;ki)decryptor *
   p:(;ki,Length(c))plain{StateID(s') = StateID(s)+1 /\ !p'. ENCrypted(ki,Length(c),StateID(s),p',c) => p=p'})
*)

