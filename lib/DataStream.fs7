module DataStream

(* Application-level bytes streams exchanged over TLS;            *)
(* depending on the safety of their indexes,                      *) 
(* these streams are treated abstractly by our TLS implementation *)

open TLSInfo
open Bytes
open Error
open TLSError
open Range

/// Auxiliary functions for ranges

private val min: a:nat -> b:nat -> c:nat{(a<=b /\ c=a) \/ (a>b /\ c=b)}
private val max: a:nat -> b:nat -> c:nat{(a>=b /\ c=a) \/ (a<b /\ c=b)}

val splitRange: e:succEpoch -> r:range -> (r0:range * r1:range){r = Sum(r0,r1)} 
//AP /\ RangeFragment(EpochSI(ki),r0)

/// Bytestreams

// we communicate deltas indexed by all preceding bytes on the stream.  
// TLS guarantees abstraction for every delta with a safe index; 
// this is the main basis for application-level integrity and secrecy 

// used only as a ghost index:
// streams have no destructors, so they do not leak secrets
// they are used abstractly by TLS, except that
// their logical definition is needed for authentication in application code.
private type (;ki:epoch) stream = {sb:bytes list}

// the implementation of this type is application-specific 
// but it must provide the following functions to TLS
private type (;ki:epoch, h:(;ki)stream, r:range) delta = {contents: (;r) rbytes}

function val Payload: e:epoch * s:(;e)stream * r:range * (;e,s,r)delta -> cbytes
private definition !e,s,r,d. Payload(e,s,r,d) = B(d.contents)

ask !e,e',s,s',r,r',d. Payload(e,s,r,d) = Payload(e',s',r',d)

function val EmptyStream: e:epoch -> (;e)stream 
private definition !e. EmptyStream(e) = {sb = []}

function val ExtendStream: 'a * 'b * 'c * 'd -> 'e
private definition !ki,s,r,b. ExtendStream(ki,s,r,b) = {sb = b :: s.sb } 

function val ExtendStreamDelta: 'a * 'b * 'c * 'd -> 'e
definition !ki,s,r,d. ExtendStreamDelta(ki,s,r,d) = ExtendStream(ki,s,r,Payload(ki,s,r,d))

ask !ki,ki',s,s',r,r',d,d'.
  Payload(ki,s,r,d) = Payload(ki',s',r',d') =>
  ExtendStreamDelta(ki,s,r,d) = ExtendStreamDelta(ki,s,r,d')

function val StreamBytes: e:epoch * (;e)stream -> cbytes
private definition !e,s,h,t.
 (s.sb = []   /\ StreamBytes(e,s) = [||]) \/
 (s.sb = h::t /\ StreamBytes(e,s) = (StreamBytes(e,{sb=t}) @| B(h)))

ask !e. StreamBytes(e,EmptyStream(e)) = [||]
ask !e,s,r,b. StreamBytes(e,ExtendStream(e,s,r,b)) = ( StreamBytes(e,s) @| b )

// The following two functions are 
// used only by the application.
// They are never called from TLS.
val createDelta: 
  ki:epoch -> s:(;ki) stream -> r:range -> 
  b:(;r) rbytes -> c: (;ki,s,r) delta  
val deltaBytes: 
  ki:epoch -> s:(;ki) stream -> r:range -> 
  c: (;ki,s,r) delta -> b:(;r) rbytes 

//CF we need a better verification pattern for multi-user interfaces.
//CF a cheap one is to use different names plus ifdefs in the .fsi

// used by TLS
val init: e:epoch -> s:(;e)stream{s=EmptyStream(e)}
val append: 
  ki:epoch -> s: (;ki) stream -> r:range ->
  d:(;ki,s,r) delta -> 
  s':(;ki) stream{s' = ExtendStreamDelta(ki,s,r,d)}

val deltaPlain: 
  ki:epoch{not Auth(ki)} -> s:(;ki) stream -> r:range -> 
  b:(;r) rbytes -> d: (;ki,s,r) delta {B(b) = Payload(ki,s,r,d)} 
val deltaRepr: 
  ki:epoch{not Safe(ki)} -> s:(;ki) stream -> r:range -> 
  d: (;ki,s,r) delta -> b:(;r) rbytes{B(b) = Payload(ki,s,r,d)}

val split: ki:epoch -> s:(;ki) stream -> 
  r0:range -> r1:range -> d:(;ki,s,Sum(r0,r1)) delta -> 
  (d0:(;ki,s,r0) delta * d1:(;ki,ExtendStreamDelta(ki,s,r0,d0),r1) delta){
	Payload(ki,s,Sum(r0,r1),d) =
		Payload(ki,s,r0,d0) @| Payload(ki,ExtendStreamDelta(ki,s,r0,d0),r1,d1)
  }

val widen: ki:epoch -> s:(;ki) stream -> 
  r0:range -> r1:range{SubRange(r0,r1)} -> d0:(;ki,s,r0) delta ->
  d1:(;ki,s,r1) delta{Payload(ki,s,r0,d0) = Payload(ki,s,r1,d1)}

//CF: We need linearity on the stream! 

(*CF This would be the application interface: 

val deltaPlain: 
  ki:epoch -> s:(;ki) stream -> r:range -> 
  b:(;r) rbytes -> c: (;ki,s,r) delta  
val deltaRepr: 
  ki:epoch -> s:(;ki) stream -> r:range -> 
  c: (;ki,s,r) delta -> (;r) rbytes 

*)


(* CF notes on the "plaintext cascade"

- we need something stronger than Auth, e.g. Auth /\ Complete.
- document ghost status of some indexes (so that we can "fake" them)

// AppData ??

// DataStream   (provided by the application)

  private type (;e:epoch, h:(;e)stream, r:range) delta = {contents: (;r) rbytes}

// AppFragment  (s,d) re-indexing from epochs ot indexes. FIX COMMENTS.
// we generate a dummy epoch, Ok. 

- Extend is wrong: not a function.
- Sent is too strong. As we decrypt, we only know ?e'. I(e) = I(e') /\ ... 

  private type (;i:id,r:range) fragment = 
    {frag: (e':epoch * s:(;e)stream * d:(;e',s,r) delta
	       { i = Id(e') /\ (Auth(e') => DeltaFragment(e',s,r,d))}) }

  type (;e:epoch,s:(;e)stream,r:range) plain = f:(;Id(e),r) fragment {Auth(e) => Sent(e,s,r,f)}

// HSFragment, for the other payloads. BROKEN?

  type (;i:id,s:(;i)stream,r:range)plain = f:(;i,r)fragment{AuthId(i) => Sent(i,s,r,f)}

// TLSFragment, multiplexing 4 protocols.

  private type (;i:id,ct:ContentType,rg:range) fragment =
    | FHandshake of f:(;i,rg)HSFragment.fragment {ct=Handshake}
    | FCCS       of f:(;i,rg)HSFragment.fragment {ct=Change_cipher_spec}
    | FAlert     of f:(;i,rg)HSFragment.fragment {ct=Alert}
    | FAppData   of f:(;i,rg)AppFragment.fragment{ct=Application_data}

// StatefulPlain, for StatefulAEAD

  private type (;i:id,ad:cbytes,r:range) fragment = 
    {contents: (;i,ParseAD(e,ad),r)TLSFragment.fragment}

// LHAEPlain, for LHAE

  private type (;i:id,ad:cbytes,r:range) fragment = 
    {contents: (;i,ParseAD(i,ad),r)StatefulPlain.fragment}

// Encode, for ENC

  private type (;i:id,ad:(;i)LHAEPlain.adata,rg:range) plain =
	{ plain: (;i,ad,rg)LHAEPlain.plain;
	  tag  : (;i)MAC.tag;
	  ok   : b:bool { EncAlg(i) = Stream_RC4_128 => b = true }

*) 

