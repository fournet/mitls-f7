module Fragment
open Bytes
open TLSInfo
open DataStream
private type (;ki:KeyInfo,r:range) fragment = {frag: s:(;ki)stream * (;ki,s,r) delta}
predicate DeltaFragment of ki:KeyInfo * (;ki) stream * r:range * (;ki,r) fragment
function val Extend: 'a * 'b * 'c * 'd -> 'e

val fragment: ki:KeyInfo -> s:(;ki) stream -> r:range -> (;ki,s,r) delta -> 
  (f:(;ki,r) fragment * s':(;ki) stream){DeltaFragment(ki,s,r,f) /\ s' = Extend(ki,s,r,f)}

val delta: ki:KeyInfo -> s:(;ki) stream -> r:range -> f:(;ki,r) fragment{DeltaFragment(ki,s,r,f)} -> 
  (;ki,s,r) delta * s':(;ki) stream{s' = Extend(ki,s,r,f)}

val fragmentPlain: ki:KeyInfo{not Safe(ki)} -> r:range -> (;r) rbytes ->  (;ki,r) fragment
val fragmentRepr: ki:KeyInfo{not Safe(ki)} -> r:range -> (;ki,r) fragment -> (;r) rbytes

private theorem !ki,s,r1,r2,f1,f2. DeltaFragment(ki,s,r1,f1) /\ DeltaFragment(ki,s,r2,f2) => 
    (r1 = r2 /\ f1 = f2)
private theorem !ki,s,r,f. DeltaFragment(ki,s,r,f) => (?d. f.frag = (s,d))
private definition !ki,s,r,s,d. Extend(ki,s,r,{frag = (s,d)}) = ExtendStream(ki,s,r,d)


 

