module MAC_SHA1

(* Core HMAC algorithms, idealized for INT-CMA:
   compared with MAC.fs7, we are still abstractly indexed (for multi-instance)
   but the algorithm is fixed, the keys are abstract, and security is unconditional *)
   
open Bytes
open TLSConstants
open TLSInfo

val a: a:macAlg{ a = MA_HMAC(SHA) } // symbolic constant

type (;ki:succEpoch) keyrepr = k:bytes {Length(k) = MacKeySize(a)}
private type (;ki:succEpoch) key = {k:(;ki) keyrepr}

type text = bytes
predicate val Msg: epoch * text -> bool

type tag = m:bytes {Length(m) = MacKeySize(a)}

val Mac:       
  ki:succEpoch -> (;ki) key -> 
  t:text {Msg(ki,t)} -> tag
val Verify: 
  ki:succEpoch -> (;ki) key -> t:text -> 
  tag -> b:bool { b=true => Msg(ki,t) }

val GEN: 
  ki:succEpoch -> (;ki) key

(* typing the log for the ideal functionality *)
 
type entry = (ki:epoch * t:text * tag){Msg(ki,t)}
private val log: entry list ref
private val tmem: ki:epoch -> t:text -> entry list -> b:bool{ b=true => Msg(ki,t) }
