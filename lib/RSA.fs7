module RSA

// RSA asymmetric encryption & decryption, used for PMS
// we currently exclude RSA keys used both for signing and decryption

open Bytes
open Error
open RSAKey
open TLSConstants
open TLSInfo

private function val Fst: 'a -> 'b
private function val Snd: 'a -> 'b
private definition !e1,e2,e3. Fst((e1,e2,e3)) = e1
private definition !e1,e2,e3. Snd((e1,e2,e3)) = e2

// For concrete security, see also 
// On the Security of RSA Encryption in TLS
// Jakob Jonsson and Burton S. Kaliski Jr.
// http://www.iacr.org/archive/crypto2002/24420127/24420127.pdf   


private type entry = i:(pk:pk * pv:ProtocolVersion * (;48) lbytes) * 
                     (;Fst(i),Snd(i)) CRE.rsapms

private val log: entry list ref 



val encrypt: pk:pk -> pv:ProtocolVersion -> pms:(;pk,pv) CRE.rsapms -> b:bytes {CRE.EncryptedRSAPMS(pk,pv,pms,b)} (*MK suspicious  /\ HonestRSAPMSData(pk,pv,b)} *)

// TLS specific, timing-attack-resistant variant
val decrypt_int: sk ->
  	             si:SessionInfo -> 
                 cv:TLSConstants.ProtocolVersion -> (* highest client version, as above *) 
                 cv_check:bool -> (* flag whether we should check protocol version in old TLS versions *)
                 ct:bytes -> (* encrypted PMS *)
			     pmsb:CRE.rsarepr { cv_check=true => ?b. pmsb= VersionBytes(cv) @| b} (* No Result type: in case of error, we return a fresh random PMS *)

//Specialized assoc function
val pmsassoc: i:(pk:RSAKey.pk * pv:ProtocolVersion * bytes) -> 
             (i':(pk':RSAKey.pk * pv':ProtocolVersion * bytes) * (;Fst(i'),Snd(i'))CRE.rsapms) list -> 
			 (;Fst(i),Snd(i))CRE.rsapms option


val decrypt: sk ->
  	         si:SessionInfo -> 
             cv:TLSConstants.ProtocolVersion -> (* highest client version, as above *) 
             bool -> (* flag whether we should check protocol version in old TLS versions *)
             bytes -> (* encrypted PMS *)
			 (;Cert.RSAPKCert(si.serverID),cv) CRE.rsapms (* No Result type: in case of error, we return a fresh random PMS *)




(* CF 

 Markulf: this is an old discussion of the joint RSAPMS assumption. 
 May still contain some interesting insights, but has mostly been rewritten by me in the techreport.

 Some draft assumption discussed with Markulf on 13/9/12
 
 let sk, pk = keyGen() // sk is private  
 
 let sample v = v @| random 46
 
 let compliantClient a v Cr Sr = 
   // a determines the prf algorithm 
   // check that Cr is used at most once; probably irrelevant 
   let pms  = sample v
   let pms0 = sample v
   log := (pms0,pms)::!log
   encrypt pk (if b then pms else pms0),
   prf a (pms, Cr @| Sr)  
     
 let decryptRO a v Cr Sr c =
   // check that Sr is used at most once
   let pms0 = 
     let fake = sample v
     match decrypt sk c with 
     | pms0 when length pms0 = 48 -> let (_,r) = split (decrypt sk c) 2 in v @| r
     | _                          -> fake 
   let pms = 
     match assoc !log pms0 with 
 	| Some(pms) when b -> pms
 	| None             -> pms0
   prf a (pms, Cr @| Sr)
    
  The adversary get pk, compliantClient, decryptRO, and prf. Its goal is to guess b. 
    
  when b = 0, we have a simplification of concrete TLS
  when b = 1, the protocol is parametric in "compliant" PMSs, so we get good session keys 
              pms becomes abstract.    
  Hopefully we can reduce it to RSA with an extra oracle:
 
 let old_decryptRO a v Cr Sr c =
   // check that Sr is used at most once 
   let (_,r) = split (decrypt sk c) 2 
   let pms0 = v @| r 
   let pms = try assoc !log pms0 with not_found -> pms0
   prf a (pms, Cr @| Sr)
    
    
 let ptxt plain cipher = (decrypt sk cipher = plain) // possibly after erasing some bytes 
    
  I am puzzled that we do not use the cipher-integrity guarantee provided by the ClientFinished check
  informally, the adversary would need to extract the pms to forge a Finished for any related ciphertext  

*)