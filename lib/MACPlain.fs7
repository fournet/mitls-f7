module MACPlain

open Bytes
open TLSInfo

// Plaintext of MAC (addData + TLSFragment.fragment)
private type (;ki:KeyInfo,tlen:int) MACPlain = {p:bytes}

predicate Msg of ki:KeyInfo * tlen:int * (;ki,tlen)MACPlain.MACPlain

assume !ki,tlen,pl. Msg(ki,tlen,pl) <=>
  (Corrupt(ki) \/
     (?ad,x. pl.p = (ad @| IntBytes(2,Length(x))) @| x /\
	  TLSFragment.Fragment(ki,tlen,
		    TLSFragment.ADseqn(ki.sinfo.protocol_version,ad),
                    TLSFragment.ADct(ki.sinfo.protocol_version,ad),
                    x)))

ask !ki,tlen,t. Corrupt(ki) => Msg(ki,tlen,t)

val MACPlain: ki:KeyInfo -> tlen:int -> 
  ad:TLSFragment.addData -> 
  (;ki,tlen,ad)TLSFragment.AEADMsg -> 
  p:(;ki,tlen)MACPlain{Msg(ki,tlen,p)}

val reprMACPlain: ki:KeyInfo -> tlen:int -> (;ki,tlen)MACPlain -> bytes

// Result of MAC
type (;ki:KeyInfo,tlen:int) MACed = {m:bytes}
val MACed: ki:KeyInfo -> tlen:int -> bytes -> (;ki,tlen)MACed
val reprMACed: ki:KeyInfo -> tlen:int -> (;ki,tlen)MACed -> bytes

// MAC-only ciphersuites
val parseNoPad: ki:KeyInfo -> tlen:int -> ad:TLSFragment.addData -> b:bytes -> 
  ((;ki,tlen,ad)TLSFragment.AEADPlain * (;ki,tlen)MACed)
