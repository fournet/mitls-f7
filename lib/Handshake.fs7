// Merge of Handshake.fs7 and Handshake3.fs7.
// Not fully detailed, to fit in the paper.
// Agreed to be implemented, once refined.
module Handshake

open Error
open CipherSuites
open TLSInfo
open DataStream
open Certificate

(* Control Interface *)
type (;ci:ConnectionInfo) hs_state
function val Config: ci:ConnectionInfo * s:(;ci)hs_state -> config
predicate val Authorize: config * cert -> bool
predicate val Complete: ConnectionInfo * config -> bool
// AP: Not sure the SentCCS event is useful;
// rather I'd welome a SentFinished event, to model False Start
predicate val SentCCS: epoch -> bool
type (;ci:ConnectionInfo,c:config) nextState = s:(;ci)hs_state {Config(ci,s) = c}

val init:        r:Role            -> c:config  -> (ci:ConnectionInfo * s:(;ci)hs_state){ Config(ci,s) = c }
val resume:      nextSID:sessionID -> c:config  -> (ci:ConnectionInfo * s:(;ci)hs_state){ Config(ci,s) = c }
val rehandshake: ci:ConnectionInfo -> s:(;ci)hs_state -> c:config  ->
	b:bool * s':(;ci)hs_state{ (b = true /\ Config(ci,s') = c) \/ (b = false /\ Config(ci,s') = Config(ci,s))}
val rekey:       ci:ConnectionInfo -> s:(;ci)hs_state -> c:config  ->
	b:bool * s':(;ci)hs_state{ (b = true /\ Config(ci,s') = c) \/ (b = false /\ Config(ci,s') = Config(ci,s))}
val request:     ci:ConnectionInfo -> s:(;ci)hs_state -> c:config  ->
	b:bool * s':(;ci)hs_state{ (b = true /\ Config(ci,s') = c) \/ (b = false /\ Config(ci,s') = Config(ci,s))}
val authorize:   ci:ConnectionInfo -> s:(;ci)hs_state -> c:cert  ->
	(;ci,Config(ci,s))nextState { Authorize(Config(ci,s),c) }
val invalidateSession: ci:ConnectionInfo -> s:(;ci)hs_state -> (;ci,Config(ci,s))nextState

(* Network Interface*)
type (;ci:ConnectionInfo,c:config) outgoing =
  | OutIdle of (;ci,c)nextState
  | OutSome of (rg:range * (;ci.id_out,rg)Fragment.fragment) * (;ci,c)nextState
  | OutCCS of  (rg:range * (;ci.id_out,rg)Fragment.fragment) * 
               ((ci':ConnectionInfo * cs:(;ci'.id_out)StatefulAEAD.state * (;ci',c)nextState)
               { SentCCS(ci'.id_out) /\ ci.id_out = Pred(ci'.id_out) /\
                 ci.id_in = ci'.id_in})
  | OutFinished of (rg:range * (;ci.id_out,rg)Fragment.fragment) * (;ci,c)nextState
  | OutComplete of (rg:range * (;ci.id_out,rg)Fragment.fragment) * (;ci,c)nextState 
                   {Complete(ci,c)}
val next_fragment: ci:ConnectionInfo -> s:(;ci)hs_state -> (;ci,Config(ci,s))outgoing

type (;ci:ConnectionInfo,c:config)incoming =
  | InAck of (;ci,c)nextState
  | InVersionAgreed  of (;ci,c)nextState
  | InQuery of Certificate.cert * (;ci,c)nextState
  | InFinished of (;ci,c)nextState
  | InComplete of (;ci,c)nextState {Complete(ci,c)}
  | InError of ErrorCause * ErrorKind * (;ci,c)nextState
val recv_fragment: ci:ConnectionInfo -> s:(;ci)hs_state -> rg:range -> (;ci.id_in,rg)Fragment.fragment -> 
                   (;ci,Config(ci,s))incoming

type (;ci:ConnectionInfo,c:config)incomingCCS =
  | InCCSAck of ci':ConnectionInfo * (;ci'.id_in)StatefulAEAD.state * (;ci',c)nextState
				{ci.id_out = ci'.id_out /\ ci.id_in = Pred(ci'.id_in)}
  | InCCSError of ErrorCause * ErrorKind * (;ci,c)nextState
val recv_ccs     : ci:ConnectionInfo -> s:(;ci)hs_state -> rg:range -> (;ci.id_in,rg)Fragment.fragment -> 
                   (;ci,Config(ci,s))incomingCCS

val getNegotiatedVersion: ci:ConnectionInfo -> (;ci)hs_state -> ProtocolVersion
val getMinVersion: ci:ConnectionInfo -> (;ci)hs_state -> ProtocolVersion