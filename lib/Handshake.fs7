module Handshake

// We haven't yet verified the Handshake implementation against this interface.

open Error
open CipherSuites
open TLSInfo
open DataStream
open Certificate
open StatefulAEAD

(*--- controlinterface *)
(* Control Interface *)

type (;ci:ConnectionInfo) hs_state
function val Config: ci:ConnectionInfo * s:(;ci)hs_state -> config
predicate val Authorize: config * cert -> bool
predicate val Complete: ConnectionInfo * config -> bool
predicate EvSentFinishedFirst of ConnectionInfo * bool
// AP: Not sure the SentCCS event is useful;
// rather I'd welcome a SentFinished event, to model False Start
predicate val SentCCS: epoch -> bool

function val HSOutStream:  ci:ConnectionInfo * (;ci)hs_state -> 'a //(;ci.id_out)stream
function val CCSOutStream: ci:ConnectionInfo * (;ci)hs_state -> 'a //(;ci.id_out)stream
function val HSInStream:   ci:ConnectionInfo * (;ci)hs_state -> 'a //(;ci.id_in) stream
function val CCSInStream:  ci:ConnectionInfo * (;ci)hs_state -> 'a //(;ci.id_in) stream

predicate EmptyStreams of ci:ConnectionInfo * (;ci)hs_state
predicate SameStreams of ci:ConnectionInfo * (;ci)hs_state * (;ci)hs_state
assume !ci,s. EmptyStreams(ci,s) <=> (
		EmptyStream(ci.id_in,HSInStream(ci,s)) /\
		EmptyStream(ci.id_in,CCSInStream(ci,s)) /\
		EmptyStream(ci.id_out,HSOutStream(ci,s)) /\
		EmptyStream(ci.id_out,CCSOutStream(ci,s)) )
assume !ci,s,s'. SameStreams(ci,s,s') <=> (
		HSInStream(ci,s') = HSInStream(ci,s) /\
		CCSInStream(ci,s') = CCSInStream(ci,s) /\
		HSOutStream(ci,s') = HSOutStream(ci,s) /\
		CCSOutStream(ci,s') = CCSOutStream(ci,s) )

type (;ci:ConnectionInfo,c:config) nextState = s:(;ci)hs_state {Config(ci,s) = c}

val init:        r:Role            -> c:config  ->
	(ci:ConnectionInfo * s:(;ci)hs_state){ Config(ci,s) = c /\ ci.role = r /\
		IsNullCiphersuite(EpochSI(ci.id_in).cipher_suite) /\
		IsNullCiphersuite(EpochSI(ci.id_out).cipher_suite) /\
		EmptyStreams(ci,s)
		}
val resume:      nextSID:sessionID -> c:config  ->
	(ci:ConnectionInfo * s:(;ci)hs_state){ Config(ci,s) = c /\ ci.role = Client /\
		IsNullCiphersuite(EpochSI(ci.id_in).cipher_suite) /\
		IsNullCiphersuite(EpochSI(ci.id_out).cipher_suite) /\
		EmptyStreams(ci,s)}
val rehandshake: ci:ConnectionInfo -> s:(;ci)hs_state -> c:config  ->
	b:bool * s':(;ci)hs_state{
		((b = true /\ Config(ci,s') = c) \/ (b = false /\ Config(ci,s') = Config(ci,s))) /\
		SameStreams(ci,s,s')
		}
val rekey:       ci:ConnectionInfo -> s:(;ci)hs_state -> c:config  ->
	b:bool * s':(;ci)hs_state{
		((b = true /\ Config(ci,s') = c) \/ (b = false /\ Config(ci,s') = Config(ci,s))) /\
		SameStreams(ci,s,s')
		}
val request:     ci:ConnectionInfo -> s:(;ci)hs_state -> c:config  ->
	b:bool * s':(;ci)hs_state{
		((b = true /\ Config(ci,s') = c) \/ (b = false /\ Config(ci,s') = Config(ci,s))) /\
		SameStreams(ci,s,s')
		}
val authorize:   ci:ConnectionInfo -> s:(;ci)hs_state -> c:cert  ->
	s':(;ci,Config(ci,s))nextState { Authorize(Config(ci,s),c) /\ SameStreams(ci,s,s') }
val invalidateSession: ci:ConnectionInfo -> s:(;ci)hs_state -> s':(;ci,Config(ci,s))nextState{SameStreams(ci,s,s')}

(*--- networkinterface *)
(* Network Interface*)

type (;ci:ConnectionInfo, hs:(;ci) hs_state) outgoing =
  | OutIdle of s':(;ci,Config(ci,hs))nextState{SameStreams(ci,hs,s')}
  | OutSome of (rg:range * f:(;ci.id_out,rg)Fragment.fragment * s':(;ci,Config(ci,hs))nextState){
				(Auth(ci.id_out) => Fragment.Fragment(ci.id_out,HSOutStream(ci,hs),rg,f) ) /\
				HSOutStream(ci,s') = Fragment.Extend(ci.id_out,HSOutStream(ci,hs),rg,f) /\
				CCSOutStream(ci,s') = CCSOutStream(ci,hs) /\
				HSInStream(ci,s') = HSInStream(ci,hs) /\
				CCSInStream(ci,s') = CCSInStream(ci,hs)
				}
  | OutCCS of  (rg:range * f:(;ci.id_out,rg)Fragment.fragment * 
               ci':ConnectionInfo * cs:(;ci'.id_out)StatefulAEAD.state * s':(;ci',Config(ci,hs))nextState)
               { SentCCS(ci'.id_out) /\
			     StatefulPlain.EmptyHistory(ci'.id_out,cs.history) /\
			      ci.id_out = Pred(ci'.id_out) /\
                              ci.id_in = ci'.id_in /\
                              ci.role = ci'.role /\
				 (Auth(ci.id_out) => Fragment.Fragment(ci.id_out,CCSOutStream(ci,hs),rg,f) ) /\
				 EmptyStream(ci'.id_out,HSOutStream(ci',s')) /\
				 EmptyStream(ci'.id_out,CCSOutStream(ci',s')) /\
				 HSInStream(ci',s') = HSInStream(ci,hs) /\
				 CCSInStream(ci',s') = CCSInStream(ci,hs)
				 }
  | OutFinished of (rg:range * f:(;ci.id_out,rg)Fragment.fragment * s':(;ci,Config(ci,hs))nextState){
				EvSentFinishedFirst(ci,true) /\
				(Auth(ci.id_out) => Fragment.Fragment(ci.id_out,HSOutStream(ci,hs),rg,f) ) /\
				HSOutStream(ci,s') = Fragment.Extend(ci.id_out,HSOutStream(ci,hs),rg,f) /\
				CCSOutStream(ci,s') = CCSOutStream(ci,hs) /\
				HSInStream(ci,s') = HSInStream(ci,hs) /\
				CCSInStream(ci,s') = CCSInStream(ci,hs)
				}
  | OutComplete of (rg:range * f:(;ci.id_out,rg)Fragment.fragment * s':(;ci,Config(ci,hs))nextState)
                   {Complete(ci,Config(ci,hs)) /\
					(Auth(ci.id_out) => Fragment.Fragment(ci.id_out,HSOutStream(ci,hs),rg,f) ) /\
					HSOutStream(ci,s') = Fragment.Extend(ci.id_out,HSOutStream(ci,hs),rg,f) /\
					CCSOutStream(ci,s') = CCSOutStream(ci,hs) /\
					HSInStream(ci,s') = HSInStream(ci,hs) /\
					CCSInStream(ci,s') = CCSInStream(ci,hs)
				   }
val next_fragment: ci:ConnectionInfo -> s:(;ci)hs_state -> (;ci,s)outgoing

type (;ci:ConnectionInfo,c:config)incoming =
  | InAck of (;ci,c)nextState
  | InVersionAgreed  of (;ci,c)nextState
  | InQuery of Certificate.cert * (;ci,c)nextState
  | InFinished of (;ci,c)nextState {EvSentFinishedFirst(ci,false)}
  | InComplete of (;ci,c)nextState {Complete(ci,c)}
  | InError of ErrorCause * ErrorKind * (;ci,c)nextState
val recv_fragment: ci:ConnectionInfo -> s:(;ci)hs_state -> rg:range -> (;ci.id_in,rg)Fragment.fragment -> 
                   (;ci,Config(ci,s))incoming

type (;ci:ConnectionInfo,c:config)incomingCCS =
  | InCCSAck of ci':ConnectionInfo * (;ci'.id_in)StatefulAEAD.state * (;ci',c)nextState
				{ci.id_out = ci'.id_out /\ ci.id_in = Pred(ci'.id_in)}
  | InCCSError of ErrorCause * ErrorKind * (;ci,c)nextState
val recv_ccs     : ci:ConnectionInfo -> s:(;ci)hs_state -> rg:range -> (;ci.id_in,rg)Fragment.fragment -> 
                   (;ci,Config(ci,s))incomingCCS

val getNegotiatedVersion: ci:ConnectionInfo -> (;ci)hs_state -> ProtocolVersion
val getMinVersion:        ci:ConnectionInfo -> (;ci)hs_state -> ProtocolVersion



(* INTERNAL HS VERIFICATION (ALL THESE DEFS ARE PRIVATE) *)

/// Misc

//$? change sessionID to uniformally use [||] instead of None.

/// Handshake message format 

// we need a precise spec, as verifyData is a series of such messages.

function val MessageBytes: HandshakeType * bytes -> bytes 
definition !ht,payload. MessageBytes(ht,payload) = HTBytes(ht) @| VLBytes(3,data)

val makeMessage: ht:HandshakeType -> payload:bytes -> msg:bytes { msg = MessageBytes(ht,payload) }
val parseMessage: hs_state -> (hs_state * ht:HandshakeType * payload:bytes * msg:bytes { msg = MessageBytes(ht,payload) }) option
//$ unclear how to usefully maintain hs_state invariant; pass instead state.incoming? 

/// Client Hello 

function val ClientHelloBytes: ... 
definition !cv,clRdm,sid,clientCipherSuites,cm,ext.
  ClientHelloBytes(cv,clRdm,sid,clientCipherSuites,cm,ext) = 
    MessageBytes(
	  HT_client_hello, 
      VersionBytes cv @| CRBytes clRdm @| SidBytes sid @| CipherSuitesBytes clientCipherSuites @| CompressionsBytes cm @| ext )

//$ get rid of the intermediate record
//$ factor out extension processing
val makeClientHelloBytes: ... -> msg:bytes { msg = ClientHelloBytes(...) } 
val parseClientHello: payload:bytes -> ( cv,clRdm,sid,clientCipherSuites,cm,ext { MessageBytes(HT_client_hello,payload) =  ClientHelloBytes(...) }  ) Result

/// Server Hello 

function val ServerHelloBytes: ... // (sv,sr,sid,cs,cm,extensions) 
definition !sv,sr,sid,cs,cm,ext.
  ServerHelloBytes(sv,sr,sid,cs,cm,ext) =
    MessageBytes(
	  HT_server_hello, 
      VersionBytes sv @| CRBytes sr @| SidBytes sid @| CipherSuiteBytes cs @| CompressionsBytes cm @| ext )

val makeServerHelloBytes: ... -> msg:bytes { msg = ServerHelloBytes(...) } 
val parseClientHello: payload:bytes -> ( sv,sr,sid,cs,cm,ext { MessageBytes(HT_server_hello,payload) = ServerHelloBytes(sv,sr,sid,cs,cm,ext) } ) Result

/// Certificate chains

function val CertificateListBytes: cert list -> bytes
definition CertificateListBytes([]) = [||] 
definition !c,cs. CertificateListBytes(c::cs) = CertificateBytes(c) @| CertificateListBytes(cs)

function val CertsBytes: cert list -> bytes
definition !cs. CertsBytes(cs) = VLBytes 3 (CertificateListBytes(cs))

function val CertificateBytes: cert list -> bytes
definition !certs. CertificateBytes(certs) = MessageBytes(HT_certificate,CertsBytes(certs))

val makeCertificateBytes: certs:cert list -> msg:bytes { msg = CertificateBytes(certs) }
val parseCertificate: payload:bytes -> (certs:cert list{ MessageBytes(HT_certificate,CertsBytes(certs)) = CertificateBytes(certs) } ) Result

/// Server Hello Done

val serverHelloDoneBytes: msg:bytes { msg = Message(HT_server_hello_done,[||]) }

/// Client Key Exchange (for now only for RSA); note that this message is randomized.

predicate val ClientKeyExchangeBytes: pms * pkey * bytes -> bool (* with some injectivity properties *)
definition !pms,pkey. ClientKeyExchangeBytes(pms,pkey,msg) =
  ?cipher. Encrypted(pms,pkey,cipher) /\ msg = MessageBytes(HT_client_key_exchange, cipher)

//$ makeClientKeyExchangeBytes actually generates the pms?!

val makeClientKexRsaBytes: pms:pms -> pkey:pkey -> msg:bytes { ClientKeyExchangeBytes(pms,pkey,msg) }  
val parseClientKexRsa: si:SessionInfo -> payload:bytes -> pms:pms { !cs. si.serverID = Some(cs)  = ClientKeyExchangeBytes(pms,CertsPKey(cs),MessageBytes(HT_client_key_exchange,payload)) } 

/// State-machine invariants (sample)

// Full handshake, RSA with anonymous client, waiting for ClientKeyExchange:

config, si, log { 
// ? clientVer clientSid, clientCipherSuites, clientCm, clientExt,    certs, ts 
    log = ClientHelloBytes(clientVer         , si.crand, clientSid   , clientCipherSuites, clientCm      , clientExt)
      @|  ServerHelloBytes(si.protocolVersion, si.srand, si.sessionID, si.cipherSuite    , si.compression, serverExt)
      @|  CertificateBytes(certs)
      @|  serverHelloDoneBytes
     
 /\ (si.sessionID = [||] \/ si.sessionID <> clientSid) (* full handshake *)
 /\ si.protocolVersion = Min(clientVer, config.maxVer) 
 /\ si.cipherSuite in clientCipherSuites 
 /\ si.cipherSuite in config.cipherSuites 
 /\ si.compression in clientCm
 /\ si.compression in config.compressions
 /\ Extensions(clientExt,serverExt)

 (* RSA-specific *)
 //\ config says anon client
 /\ si.cipherSuite = CipherSuite(RSA,ts)
 /\ si.clientID = None
 /\ si.serverID = Some(certs)
}

// Idem, after a few more steps

config, si, log, pms {
// ? clientVer clientSid, clientCipherSuites, clientCm, clientExt,     cs, ts,    cipher  
    log = ClientHelloBytes(clientVer         , si.crand, clientSid   , clientCipherSuites, clientCm      , clientExt)
      @|  ServerHelloBytes(si.protocolVersion, si.srand, si.sessionID, si.cipherSuite    , si.compression, serverExt)
      @|  CertificateBytes(cs)
      @|  serverHelloDoneBytes
	  @|  ClientKeyExchangeBytes(cipher)
     
 /\ si.sessionID <> clientSid (* full handshake *)
 /\ si.protocolVersion = Min(clientVer, config.ver) 
 /\ si.cipherSuite in clientCipherSuites 
 /\ si.cipherSuite in config.cipherSuites 
 /\ si.compression in clientCm
 /\ Extensions(clientExt,serverExt)

 (* RSA-specific *)
 //\ config says anon client
 /\ si.cipherSuite = CipherSuite(RSA,ts)
 /\ si.clientID = None
 /\ si.serverID = Some(cs)

 (* after ClientKeyExchange *)
 /\ ...

 (* after accepting Finished *) 
 /\ ( Honest(pms) /\ StrongHS(si.cipherSuite) -> ?clientConfig. ClientFinished(clientConfig,si) /\ clientVer = clientConfig.maxVer /\ ...  (* we may also rewrite the whole invariant by unification *) ) 

}


