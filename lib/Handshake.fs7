module Handshake

(* 
 MK. Comments about Handshake from other modules:
 
 TODO from Sig.fs7: there is some adhocness processing of sigHashAlg, sigAlg, hashAlg left in Handshake.fs

 CF
 --- summary of our discussion on Apr 29, towards typechecking the HS.

 MK. factually a bit outdated, but moved here from PRF to mark the 1 year anniversary. :)

 The following predicate controls StAE idealization
 (relative to StAE's algorithmic strength)
 it is ideally used much before it can be proved as the HS completes.

From its definition in TLSInfo.fs7 we know that
SafeHS_SI(si) <=> !r:Role.
     HonestMS(MsI(si)) /\
     SafeKDF(SiId(id,r) /\ 
     SafeVD(si)

 In HS, we have 
  - KeyGenClient(id.csrConn, id.pv, id.aeAlg, id.ext) for id=Id(e) is a precondition to the event ClientSentCCS(e)
  - KeyCommit(id.csrConn, id.pv, id.aeAlg, id.ext)    for id=Id(e) is a precondition to the event ServerSentCCS(e)
  - HonestMS /\ StrongVD are sufficient to guarantee 
    matching ClientSentCCS(e) and ServerSentCCS(e), hence getting 
     (1) SafeKDF, and 
     (2) e is the only wide index associated with Id(e)       

    This enables us to prove Complete, roughly as currently defined:
    Complete <=> (HonestPMS /\ StrongHS => SafeHS)
*)


open Bytes
open Error
open TLSError
open TLSInfo
open Range
open StatefulLHAE
open TLSConstants
open TLSExtensions
open HandshakeMessages

predicate Configure of Role * epoch * config
predicate Authorize of Role * SessionInfo
// If the user Authorize, we can put the session in the DB
private definition !r,si. Authorize(r,si) => SessionDB.Authorize(r,si)
// If we select a session from the DB, the user previously authorized it
private theorem !r,si. SessionDB.Authorize(r,si) => Authorize(r,si)

predicate EvSentFinishedFirst of ConnectionInfo * bool
predicate Negotiated of Role * SessionInfo * config * config
predicate Complete of ConnectionInfo * config

val check_negotiation: r:Role -> si:SessionInfo -> cfg:config -> unit{?cfg'. Negotiated(r,si,cfg,cfg')}

(* Anonymous clients are authorized for client-unauthenticated sessions *)
private assume !si. (si.client_auth = false /\ si.clientID = []) => Authorize(Server,si)
private assume !r,si,si'. Authorize(Client,si) /\ SessionHelloParams(si,()) =
  SessionHelloParams(si',()) /\ si'.serverID = si.serverID => Authorize(Client,si')

private assume !r,si,si'. Authorize(Server,si) /\ SessionHelloParams(si,()) = 
  SessionHelloParams(si',()) /\ si'.serverID = si.serverID /\ si'.clientID = si.clientID /\ si'.client_auth = si.client_auth => Authorize(Server,si')

private definition !a,k,t. Sig.Msg(a,k,t) 
  <=> ((?si,pk,pv,r. 
             ClientLogBeforeCertificateVerifyRSA_Auth(si,t) /\
	     si.pmsId = PmsId(PMS.RSAPMS(pk,pv,r)) /\
             HonestPMS(si.pmsId) /\
             k = Cert.SigPKCert(si.clientID,a)) \/
        (?si,p,g,gc,gs,r. 
           ClientLogBeforeCertificateVerifyDHE_Auth(si,t) /\
	   si.pmsId = PmsId(PMS.DHPMS(p,g,gc,gs,r)) /\
           DH.HonestExponential(p,g,gs) => HonestPMS(si.pmsId) /\  
           k = Cert.SigPKCert(si.clientID,a)) \/
        (?si,p,g,gs. B(t) = B(si.init_crand) @| B(si.init_srand) @| 
           DHEParamBytes(p,g,gs) /\
           DH.HonestExponential(p,g,gs) /\ 
           k = Cert.SigPKCert(si.serverID,a)))

private definition !msi,r,b. PRF.VerifyData(msi,r,b) 
  <=> ((?si. msi = MsI(si) /\
        r = Client /\
        SentCCS(Client,si.init_crand,si.init_srand,si) /\
        ClientLogBeforeClientFinished(si,b)) \/
       (?si. msi = MsI(si) /\
        r = Server /\
        SentCCS(Server,si.init_crand,si.init_srand,si) /\
        ServerLogBeforeServerFinished(si,b)) \/
       (?si,si'. msi = MsI(si) /\
        r = Client /\
        SentCCS(Client,si'.init_crand,si'.init_srand,si) /\
        si.sessionID = si'.sessionID /\
        ClientLogBeforeClientFinishedResume(si',b)) \/
       (?si,si'. msi = MsI(si) /\
        r = Server /\
        SentCCS(Server,si'.init_crand,si'.init_srand,si) /\
        si.sessionID = si'.sessionID /\
        ServerLogBeforeServerFinishedResume(si',b)))

ask !si,b. PRF.VerifyData(MsI(si),Client,b) /\
    ClientLogBeforeClientFinished(si,b) => SentCCS(Client,si.init_crand,si.init_srand,si)

ask !si,b. PRF.VerifyData(MsI(si),Server,b) /\
    ServerLogBeforeServerFinished(si,b) => SentCCS(Server,si.init_crand,si.init_srand,si)

assume !r,si,cr,sr,si'.
       SentCCS(r,si.init_crand,si.init_srand,si) /\
       SentCCS(r,cr,sr,si') /\
       MsI(si) = MsI(si') => si = si'

ask !si,si',b. PRF.VerifyData(MsI(si),Server,b) /\
    SentCCS(Server,si.init_crand,si.init_srand,si) /\
    ServerLogBeforeServerFinishedResume(si',b) 
    => SentCCS(Server,si'.init_crand,si'.init_srand,si)

ask !si,si',b. PRF.VerifyData(MsI(si),Server,b) /\
    SentCCS(Client,si.init_crand,si.init_srand,si) /\
    ClientLogBeforeClientFinishedResume(si',b) 
    => SentCCS(Client,si'.init_crand,si'.init_srand,si)

(* Negotiated remains to be defined but it can be a nice global spec of what HS is meant to achieve.
   Especially interesting would be proving that the result is the "best possible" *)

definition !ci,cfg. Complete(ci,cfg) <=>
        ( EpochSI(ci.id_in) = EpochSI(ci.id_out) /\
	  EpochCSRands(ci.id_in) = EpochCSRands(ci.id_out) /\
	  EpochWriter(ci.id_in) = DualRole(EpochWriter(ci.id_out)) /\
          CompleteEpoch(ci.role,ci.id_in,cfg) /\
          CompleteEpoch(ci.role,ci.id_out,cfg))
         
ask !ci,cfg.	
    Complete(ci,cfg) /\
    HonestPMS(EpochSI(ci.id_in).pmsId) /\	
    StrongKEF(KefAlg(EpochSI(ci.id_in))) /\
    StrongVD(VdAlg(EpochSI(ci.id_in))) /\
    StrongKDF(KdfAlg(EpochSI(ci.id_in))) /\
    StrongAE(ci.id_in) => Safe(ci.id_in)

ask !ci,cfg.	
    Complete(ci,cfg) /\
    HonestPMS(EpochSI(ci.id_in).pmsId) /\	
    StrongKEF(KefAlg(EpochSI(ci.id_in))) /\
    StrongVD(VdAlg(EpochSI(ci.id_in))) /\
    StrongKDF(KdfAlg(EpochSI(ci.id_in))) /\
    StrongAuth(ci.id_in) => Auth(ci.id_in)

ask !ci,cfg.	
    Complete(ci,cfg) /\
    HonestPMS(EpochSI(ci.id_out).pmsId) /\	
    StrongKEF(KefAlg(EpochSI(ci.id_out))) /\
    StrongVD(VdAlg(EpochSI(ci.id_out))) /\
    StrongKDF(KdfAlg(EpochSI(ci.id_out))) /\
    StrongAE(ci.id_out) => Safe(ci.id_out)

ask !ci,cfg.	
    Complete(ci,cfg) /\
    HonestPMS(EpochSI(ci.id_out).pmsId) /\	
    StrongKEF(KefAlg(EpochSI(ci.id_out))) /\
    StrongVD(VdAlg(EpochSI(ci.id_out))) /\
    StrongKDF(KdfAlg(EpochSI(ci.id_out))) /\
    StrongAuth(ci.id_out) => Auth(ci.id_out)

 

type (;ci:ConnectionInfo) serverState =  (* note that the CertRequest bits are determined by the config *) 
                    (* we may omit some ProtocolVersion, mostly a ghost variable *)
   | ClientHello                  of cVerifyData * sVerifyData

   | ClientCertificateRSA         of (si:SessionInfo * pv:ProtocolVersion * sk:RSAKey.sk * l:log){ServerLogBeforeClientCertificateRSA(si,pv,l)}
   | ServerCheckingCertificateRSA of (si:SessionInfo * pv:ProtocolVersion * sk:RSAKey.sk * l:log * certs:Cert.chain * b:bytes){ServerLogBeforeClientCertificateRSA(si,pv,l) /\ B(b) = CertificateMsg(certs)}
   | ClientKeyExchangeRSA         of (si:SessionInfo * pv:ProtocolVersion * sk:RSAKey.sk * l:log){ServerLogBeforeClientKeyExchangeRSA(si,pv,l) /\ Authorize(Server,si)}

   | ClientCertificateDH          of si:SessionInfo * l:log
   | ServerCheckingCertificateDH  of si:SessionInfo * l:log * b:bytes
   | ClientKeyExchangeDH          of si:SessionInfo * l:log

   | ClientCertificateDHE         of si:SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * (;p,g,gx)DH.secret * l:log{
       ServerLogBeforeClientCertificateDHE(si,l)}
    
   | ServerCheckingCertificateDHE of si:SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * (;p,g,gx)DH.secret * l:log * c:Cert.chain * b:bytes{
       ServerLogBeforeClientCertificateDHE(si,l) /\
       B(b) = CertificateMsg(c)}

   | ClientKeyExchangeDHE         of si:SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * (;p,g,gx)DH.secret * l:log{
       ServerLogBeforeClientKeyExchangeDHE(si,l) /\ Authorize(Server,si)}


   | ClientKeyExchangeDH_anon     of SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * (;p,g,gx)DH.secret * log

   | CertificateVerify            of (si:SessionInfo * (;si)PRF.masterSecret * l:log){si.client_auth = true /\ ServerLogBeforeClientCertificateVerify(si,l) /\ Authorize(Server,si)}
   | ClientCCS                    of (si:SessionInfo * (;si)PRF.masterSecret * l:log){ServerLogBeforeClientFinished(si,l) /\ Authorize(Server,si)}
   | ClientFinished               of (si:SessionInfo * (;si)PRF.masterSecret * e:succEpoch * (;Id(e))StatefulLHAE.writer * l:log){
       IsSuccEpoch(ci.id_in) /\ EpochSI(e)=si /\ ServerLogBeforeClientFinished(si,l) /\ Authorize(Server,si)}
   (* by convention, the parameters are named si, cv, cr', sr', ms, log *)
   | ServerWritingCCS             of (si:SessionInfo * (;si)PRF.masterSecret * e:succEpoch * (;Id(e))StatefulLHAE.writer * cv:cVerifyData * l:log){
                                       EpochSI(e)=si /\ ServerLogBeforeServerFinished(si,l) /\ 
         (* PRF.VerifyData(e,Client,cv) /\ *)
         Authorize(Server,si)}
   | ServerWritingFinished        of si:SessionInfo * (;si)PRF.masterSecret * e:succEpoch * cv:cVerifyData * sv:sVerifyData{
       EpochSI(e)=si /\ 
         (* PRF.VerifyData(e,Client,cv) /\ PRF.VerifyData(e,Server,sv) /\ *)
         Authorize(Server,si)}

   | ServerWritingCCSResume       of (ew:succEpoch * (;Id(ew))StatefulLHAE.writer * er:succEpoch * (;Id(er))StatefulLHAE.reader * (;EpochSI(ew))PRF.masterSecret * l:log){EpochSI(ew)=EpochSI(er) /\ ServerLogBeforeServerFinishedResume(EpochSI(ew),l) /\ Authorize(Server,EpochSI(ew))}
   | ClientCCSResume              of e:succEpoch * (;Id(e))StatefulLHAE.reader * sVerifyData * (;EpochSI(e))PRF.masterSecret * l:log{ServerLogBeforeClientFinishedResume(EpochSI(e),l) /\ ci.id_in = Pred(e) /\ Authorize(Server,EpochSI(e))}
   | ClientFinishedResume         of si:SessionInfo * (;si)PRF.masterSecret * e:succEpoch * sv:sVerifyData * log{
       EpochSI(e)=si /\ 
(* PRF.VerifyData(e,Server,sv) /\ *)
         Authorize(Server,EpochSI(e))}

   | ServerIdle                   of cVerifyData * sVerifyData
   (* the ProtocolVersion is the highest TLS version proposed by the client *)

type (;ci:ConnectionInfo) clientState = 
   | ServerHello                  of cr:crand * sid:sessionID * cl:(clientExtension list) * cvd:cVerifyData * svd:sVerifyData * l:log{ClientLogBeforeServerHello(cr,l)}

   | ServerCertificateRSA         of si:SessionInfo * l:log{ClientLogBeforeServerCertificate(si,l)}
   | ClientCheckingCertificateRSA of si:SessionInfo * l:log * ser:Cert.cert list * pv:ProtocolVersion option * b:bytes{ClientLogBeforeServerCertificate(si,l) /\ b = CertificateMsg(ser)}
   | CertificateRequestRSA        of si:SessionInfo * l:log{ClientLogBeforeCertificateRequestRSA(si,l) /\ Authorize(Client,si)} (* both certificate request and hellodone will be accepted *)
   | ServerHelloDoneRSA           of si:SessionInfo * c:Cert.sign_cert * l:log{ClientLogBeforeServerHelloDoneRSA(si,l) /\ Authorize(Client,si)}

   | ServerCertificateDH          of SessionInfo * log
   | ClientCheckingCertificateDH  of SessionInfo * log * ProtocolVersion option * bytes
   | CertificateRequestDH         of SessionInfo * log (* We pick our cert and store it in sessionInfo as soon as the server requests it.
                                                         We put None if we don't have such a certificate, and we know whether to send
                                                         the Certificate message or not based on the state when we receive the Finished message *)
   | ServerHelloDoneDH            of SessionInfo * log

   | ServerCertificateDHE         of si:SessionInfo * l:log{ClientLogBeforeServerCertificate(si,l)}
   | ClientCheckingCertificateDHE of si:SessionInfo * l:log * ProtocolVersion option * b:bytes{ClientLogBeforeServerCertificate(si,l) (* /\ b = CertificateMsg(ser) *) }
   | ServerKeyExchangeDHE         of si:SessionInfo * l:log{ClientLogBeforeServerKeyExchangeDHE(si,l) /\ Authorize(Client,si)}
   | CertificateRequestDHE        of si:SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * l:log{ClientLogBeforeCertificateRequestDHE(si,l) /\ Authorize(Client,si)}
   | ServerHelloDoneDHE           of si:SessionInfo * Cert.sign_cert * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * l:log{ClientLogBeforeServerHelloDoneDHE(si,l) /\ Authorize(Client,si)}

   | ServerKeyExchangeDH_anon of SessionInfo * log (* Not supported yet *)
   | ServerHelloDoneDH_anon of SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * log

   | ClientWritingCCS       of si:SessionInfo * (;si)PRF.masterSecret * l:log{ClientLogBeforeClientFinished(si,l) /\ Authorize(Client,si)}
   | ServerCCS              of (si:SessionInfo * (;si)PRF.masterSecret * e:succEpoch * (;Id(e))StatefulLHAE.reader * cv:cVerifyData * l:log){ 
(*     	 EpochSI(e)=si  /\ ClientLogBeforeServerFinished(si,l) /\ *)
         ci.id_in = Pred(e) /\
         (* PRF.VerifyData(e,Client,cv) /\ *)
         Authorize(Client,si)}
   | ServerFinished         of si:SessionInfo * (;si)PRF.masterSecret * e:succEpoch * cv:cVerifyData * l:log{ClientLogBeforeServerFinished(si,l) /\
                                                                                                               EpochSI(e)=si  /\ 
         (* ci.id_in = Pred(e) /\ *)
         (* PRF.VerifyData(e,Client,cv) /\ *)
         Authorize(Client,si)}

   | ServerCCSResume        of (ew:succEpoch * (;Id(ew))StatefulLHAE.writer * er:succEpoch * (;Id(er))StatefulLHAE.reader * (;EpochSI(ew))PRF.masterSecret * l:log){EpochSI(ew)=EpochSI(er) /\ ci.id_in = Pred(er) /\ ClientLogBeforeServerFinishedResume(EpochSI(ew),l) /\ Authorize(Client,EpochSI(ew))}
   | ServerFinishedResume   of e:succEpoch * (;Id(e))StatefulLHAE.writer * (;EpochSI(e))PRF.masterSecret * l:log{ClientLogBeforeServerFinishedResume(EpochSI(e),l) /\ Authorize(Client,EpochSI(e))}
   | ClientWritingCCSResume of e:succEpoch * w:(;Id(e))StatefulLHAE.writer * (;EpochSI(e))PRF.masterSecret * sv:sVerifyData * l:log{
   (?si'. ClientLogBeforeClientFinishedResume(si',l) /\ 
          si'.init_crand = EpochCRand(e) /\
          si'.init_srand = EpochSRand(e) /\
          si'.sessionID = EpochSI(e).sessionID ) /\
   Authorize(Client,EpochSI(e)) /\
   ci.id_out = Pred(e) /\
   StatefulLHAE.History(Id(e),Writer,w) = 
   StatefulPlain.EmptyHistory(Id(e)) }
   | ClientWritingFinishedResume of cVerifyData * sVerifyData

   | ClientIdle             of cVerifyData * sVerifyData

type (;ci:ConnectionInfo) protoState = // Cannot use Client and Server, otherwise clashes with Role
  | PSClient of (;ci) clientState
  | PSServer of (;ci) serverState

val clientState: ci:ConnectionInfo -> c:(;ci) clientState -> p:(;ci) protoState{p = PSClient(c)}
val serverState: ci:ConnectionInfo -> c:(;ci) serverState -> p:(;ci) protoState{p = PSServer(c)}

private type (;ci:ConnectionInfo) hs_state = {
  (* I/O buffers *)
  hs_outgoing    : bytes;                  (* outgoing data *)
  hs_incoming    : bytes;                  (* partial incoming HS message *)
  (* local configuration *)
  poptions: config; 
  sDB: SessionDB.t;
  (* current handshake & session we are establishing *) 
  pstate: (;ci) protoState;
}

(*--- controlinterface *)
(* Control Interface *)

function val Config: ci:ConnectionInfo * s:(;ci)hs_state -> config
private definition !ci,s. Config(ci,s) = s.poptions

// AP: Commenting out until we restore streams for HS. Should be ported to EmptyStream as functions
// AP: function val HSOutStream:  ci:ConnectionInfo * (;ci)hs_state -> 'a //(;ci.id_out)stream
// AP: function val CCSOutStream: ci:ConnectionInfo * (;ci)hs_state -> 'a //(;ci.id_out)stream
// AP: function val HSInStream:   ci:ConnectionInfo * (;ci)hs_state -> 'a //(;ci.id_in) stream
// AP: function val CCSInStream:  ci:ConnectionInfo * (;ci)hs_state -> 'a //(;ci.id_in) stream
// AP: 
// AP: predicate EmptyStreams of ci:ConnectionInfo * (;ci)hs_state
// AP: predicate SameStreams of ci:ConnectionInfo * (;ci)hs_state * (;ci)hs_state
// AP: definition !ci,s. EmptyStreams(ci,s) <=> (
// AP: 		HSFragment.EmptyStream(ci.id_in,HSInStream(ci,s)) /\
// AP: 		HSFragment.EmptyStream(ci.id_in,CCSInStream(ci,s)) /\
// AP: 		HSFragment.EmptyStream(ci.id_out,HSOutStream(ci,s)) /\
// AP: 		HSFragment.EmptyStream(ci.id_out,CCSOutStream(ci,s)) )
// AP: definition !ci,s,s'. SameStreams(ci,s,s') <=> (
// AP: 		HSInStream(ci,s') = HSInStream(ci,s) /\
// AP: 		CCSInStream(ci,s') = CCSInStream(ci,s) /\
// AP: 		HSOutStream(ci,s') = HSOutStream(ci,s) /\
// AP: 		CCSOutStream(ci,s') = CCSOutStream(ci,s) )

type (;ci:ConnectionInfo,c:config) nextState = s:(;ci)hs_state {Config(ci,s) = c}

val init:  rl:Role  -> c:config  ->
	(ci:ConnectionInfo * s:(;ci)hs_state){Config(ci,s) = c /\ 
                ci.role = rl /\
		IsInitEpoch(ci.id_in) /\
		IsInitEpoch(ci.id_out)}
		                    
val resume: nextSID:sessionID -> c:config  ->
	(ci:ConnectionInfo * s:(;ci)hs_state){ Config(ci,s) = c /\ 
                ci.role = Client /\          
		IsInitEpoch(ci.id_in) /\
		IsInitEpoch(ci.id_out)}

val rehandshake: ci:ConnectionInfo -> s:(;ci)hs_state -> c:config  ->
	b:bool * s':(;ci)hs_state{
		((b = true /\ Config(ci,s') = c) \/ 
                 (b = false /\ Config(ci,s') = Config(ci,s)))}

val rekey: ci:ConnectionInfo -> s:(;ci)hs_state -> c:config  ->
	   b:bool * s':(;ci)hs_state{((b = true /\ Config(ci,s') = c) \/ (b = false /\ Config(ci,s') = Config(ci,s)))}
		
val request:     ci:ConnectionInfo -> s:(;ci)hs_state -> c:config  ->
                 b:bool * s':(;ci)hs_state{
		((b = true /\ Config(ci,s') = c) \/ (b = false /\ Config(ci,s') = Config(ci,s)))}

val getPrincipal:  ci:ConnectionInfo -> s:(;ci)hs_state -> string
val invalidateSession: ci:ConnectionInfo -> s:(;ci)hs_state -> s':(;ci,Config(ci,s))nextState
(*{SameStreams(ci,s,s')} *)

val getNextEpochs: ci:ConnectionInfo -> si:SessionInfo -> crand -> srand -> ci':ConnectionInfo{
    IsSuccEpoch(ci'.id_in) /\ 
    IsSuccEpoch(ci'.id_out) /\ 
    EpochCSRands(ci'.id_in) = EpochCSRands(ci'.id_out) /\ 
    EpochSI(ci'.id_in) = si /\ 
    EpochSI(ci'.id_out) = si /\
    ci.id_out = Pred(ci'.id_out) /\
    ci.id_in = Pred(ci'.id_in) /\
    ci.role = ci'.role 
(*    Id(ci'.id_out) = Swap(Id(ci'.id_in)) /\*)
(*    Id(ci'.id_in) = Swap(Id(ci'.id_out)) *)
}

(*--- networkinterface *)
(* Network Interface*)

type (;ci:ConnectionInfo, hs:(;ci) hs_state) outgoing =
  | OutIdle of s':(;ci,Config(ci,hs))nextState
  | OutSome of (rg:range * f:(;Id(ci.id_out),HSFragment.EmptyStream(Id(ci.id_out)),rg)HSFragment.plain * s':(;ci,Config(ci,hs))nextState)
  | OutCCS of  (rg:range * f:(;Id(ci.id_out),HSFragment.EmptyStream(Id(ci.id_out)),rg)HSFragment.plain * 
               ci':ConnectionInfo * cs:(;Id(ci'.id_out),Writer)StatefulLHAE.state * s':(;ci',Config(ci,hs))nextState)
               { StatefulLHAE.History(Id(ci'.id_out),Writer,cs) = StatefulPlain.EmptyHistory(Id(ci'.id_out)) /\ 
                 ci.id_out = Pred(ci'.id_out) /\ IsSuccEpoch(ci'.id_out) /\
                 ci.id_in = ci'.id_in /\
                 ci.role = ci'.role /\
		 ci.id_rand = ci'.id_rand}
  | OutFinished of (rg:range * f:(;Id(ci.id_out),HSFragment.EmptyStream(Id(ci.id_out)),rg)HSFragment.plain * s':(;ci,Config(ci,hs))nextState){
				EvSentFinishedFirst(ci,true)}
  | OutComplete of (rg:range * f:(;Id(ci.id_out),HSFragment.EmptyStream(Id(ci.id_out)),rg)HSFragment.plain * s':(;ci,Config(ci,hs))nextState)
                   {Complete(ci,Config(ci,hs)) /\ EvSentFinishedFirst(ci,false)}
val next_fragment: ci:ConnectionInfo -> s:(;ci)hs_state -> (;ci,s)outgoing

type (;ci:ConnectionInfo,c:config)incoming =
  | InAck of (;ci,c)nextState
  | InVersionAgreed  of (;ci,c)nextState * ProtocolVersion
  | InQuery of Cert.chain * advice:bool * (;ci,c)nextState
  | InFinished of (;ci,c)nextState {EvSentFinishedFirst(ci,false)}
  | InComplete of (;ci,c)nextState {Complete(ci,c) /\ EvSentFinishedFirst(ci,true)}
  | InError of alertDescription * string * (;ci,c)nextState
val recv_fragment: ci:ConnectionInfo -> s:(;ci)hs_state -> rg:range -> (;Id(ci.id_in),rg)HSFragment.fragment -> 
                   (;ci,Config(ci,s))incoming
val authorize:     ci:ConnectionInfo -> s:(;ci)hs_state -> 
                   c:Cert.chain -> (;ci,Config(ci,s))incoming

type (;ci:ConnectionInfo,c:config)incomingCCS =
  | InCCSAck of ci':ConnectionInfo * cs:(;Id(ci'.id_in),Reader)StatefulLHAE.state * (;ci',c)nextState
				{StatefulLHAE.History(Id(ci'.id_in),Reader,cs) = StatefulPlain.EmptyHistory(Id(ci'.id_in)) /\
				ci.id_out = ci'.id_out /\
				ci.id_in = Pred(ci'.id_in) /\ IsSuccEpoch(ci'.id_in) /\
				ci.role = ci'.role /\
				ci.id_rand = ci'.id_rand}
  | InCCSError of alertDescription * string * (;ci,c)nextState
val recv_ccs     : ci:ConnectionInfo -> s:(;ci)hs_state -> rg:range -> (;Id(ci.id_in),rg)HSFragment.fragment -> 
                   (;ci,Config(ci,s))incomingCCS

function val GetMinVersion: ci:ConnectionInfo * (;ci)hs_state -> ProtocolVersion
private definition !ci,s. GetMinVersion(ci,s) = s.poptions.minVer
val getMinVersion: ci:ConnectionInfo -> s:(;ci)hs_state ->
	pv:ProtocolVersion{pv = GetMinVersion(ci,s)}

(*--- end *)

(* INTERNAL HS VERIFICATION (ALL THESE DEFS ARE PRIVATE) *)
val extract:
    si:SessionInfo ->
	pms: PMS.pms { si.pmsId = PmsId(pms) } -> bytes ->
	(si':SessionInfo * (;si) PRF.masterSecret){si' = si}

// For the next two functions, the returned encpms is a ghost variable used to
// avoid an existential.
val clientKEXBytes_RSA: si:SessionInfo -> c:config ->
	((b:bytes * pms:(;Cert.RSAPKCert(si.serverID),c.maxVer)PMS.rsapms){
           ?encpms. b=ClientKeyExchangeMsg_RSA(si.protocol_version,encpms)
		}) Result

val parseClientKEX_RSA: si:SessionInfo -> RSAKey.sk -> pv:ProtocolVersion -> config -> b:bytes ->
	((
         (;Cert.RSAPKCert(si.serverID),pv)PMS.rsapms){
           ?encpms. ClientKeyExchangeMsg_RSA(si.protocol_version,encpms) = MessageBytes(HT_client_key_exchange,b)
	}) Result

val find_client_cert_sign: certType list -> Sig.alg list -> string list ->
	ProtocolVersion -> Cert.hint -> Cert.sign_cert
val getCertificateBytes: si:SessionInfo ->
  cert_req:(Cert.chain * a:Sig.alg * (;a)Sig.skey) option -> 
  (b:bytes * cl:Cert.chain){
    (si.client_auth = true /\  B(b) = CertificateMsg(cl)) \/
    (si.client_auth = false /\ B(b) = [||])}

val getCertificateVerifyBytes: si:SessionInfo -> (;si) PRF.masterSecret ->
  cert_req:(Cert.chain * a:Sig.alg * (;a)Sig.skey) option -> 
  l:log{!cl,a,k. cert_req = Some((cl,a,k)) => Sig.Msg(a,Sig.PK(k),l)} ->
  b:bytes{(!cl,a,k. (cert_req = Some((cl,a,k)) /\ si.client_auth = true) => 
                    (?sign. B(b) = CertificateVerifyMsg(si.protocol_version,a,sign))) /\
          ((cert_req = None \/ si.client_auth = false) => B(b) = [||])}

val prepare_client_output_full_RSA: ci:ConnectionInfo -> (;ci)hs_state ->
	si:SessionInfo -> (Cert.chain * a:Sig.alg * (;a)Sig.skey) option -> l:log ->
	((;ci)hs_state * si':SessionInfo * (;si)PRF.masterSecret * log) Result
val prepare_client_output_full_DHE: ci:ConnectionInfo -> (;ci)hs_state ->
	si:SessionInfo -> (Cert.chain * a:Sig.alg * (;a)Sig.skey) option ->
	p:DHGroup.p -> (;p)DHGroup.g -> (;p)DHGroup.elt -> log ->
	((;ci)hs_state * si':SessionInfo * (;si)PRF.masterSecret * log) Result
val on_serverHello_full: ci:ConnectionInfo -> cr:crand -> l:log -> to_log:bytes ->
         (pv:ProtocolVersion * sr:random * sid:sessionID * cs:cipherSuite * cm:Compression * ext:bytes){
         ClientLogBeforeServerHello(cr,l) /\
         to_log = ServerHelloMsg(pv,sr,sid,cs,cm,ext)} ->
	 negotiatedExtensions ->
 	 (;ci) protoState
val parseMessageState: ci:ConnectionInfo -> hs:(;ci)hs_state ->
	(hs':(;ci)hs_state * ht:HandshakeType * pl:bytes * to_log:bytes{Config(ci,hs) = Config(ci,hs') /\
                                                                     B(to_log) = MessageBytes(ht,B(pl))}) option Result
val recv_fragment_client: ci:ConnectionInfo -> s:(;ci)hs_state -> ProtocolVersion option ->
	(;ci,Config(ci,s))incoming

val prepare_server_output_full_RSA: ci:ConnectionInfo -> s:(;ci)hs_state -> si:SessionInfo ->
	pv:ProtocolVersion -> Sig.alg list -> serverExtension list -> l:log{
          ?csid,cs,cm,ex. B(l) = ClientHelloMsg(pv,si.init_crand,csid,cs,cm,ex)
        }->
	((s':(;ci)hs_state{Config(ci,s) = Config(ci,s')}) * ProtocolVersion) Result
val prepare_server_output_full_DH: 'a -> 'b -> 'c -> 'd -> 'e -> res:('f Result){?z. res = Error(z)}
val prepare_server_output_full_DHE: ci:ConnectionInfo -> s:(;ci)hs_state -> SessionInfo ->
	Sig.alg list -> serverExtension list -> log ->
	((s':(;ci)hs_state{Config(ci,s) = Config(ci,s')}) * ProtocolVersion) Result
val prepare_server_output_full_DH_anon: ci:ConnectionInfo -> s:(;ci)hs_state -> SessionInfo ->
	serverExtension list -> log ->
	((s':(;ci)hs_state{Config(ci,s) = Config(ci,s')}) * ProtocolVersion) Result
val prepare_server_output_full: ci:ConnectionInfo -> s:(;ci)hs_state -> si:SessionInfo ->
	pv:ProtocolVersion -> serverExtension list -> l:log{
          ?csid,cs,cm,ex. B(l) = ClientHelloMsg(pv,si.init_crand,csid,cs,cm,ex)
        } ->
	((s':(;ci)hs_state{Config(ci,s) = Config(ci,s')}) * ProtocolVersion) Result
val negotiate: 'a list -> 'a list -> 'a option
val prepare_server_output_resumption: ci:ConnectionInfo -> s:(;ci)hs_state -> crand ->
	cl:clientExtension list -> (si:SessionInfo * (;si)PRF.masterSecret) -> cVerifyData -> sVerifyData -> log ->
	s':(;ci)hs_state{Config(ci,s) = Config(ci,s')}
val startServerFull: ci:ConnectionInfo -> s:(;ci)hs_state -> 
  ch:(ProtocolVersion * crand * sessionID * cipherSuites * Compression list * bytes) ->// CHello
  clientExtension list -> cVerifyData -> sVerifyData -> 
  l:log{!pv,cr,sid,cs,cms,ex. ch = (pv,cr,sid,cs,cms,ex) =>
        (?cs',cm'. B(l) = ClientHelloMsg(pv,cr,sid,cs',cm',ex))} -> 
  ((s':(;ci)hs_state{Config(ci,s') = Config(ci,s)}) * ProtocolVersion) Result
val recv_fragment_server: ci:ConnectionInfo -> s:(;ci)hs_state -> pv:ProtocolVersion option ->
	(;ci,Config(ci,s))incoming
val enqueue_fragment: ci:ConnectionInfo -> s1:(;ci)hs_state -> bytes -> s2:(;ci)hs_state{Config(ci,s1) = Config(ci,s2)}

(* CF removed large commented out stuff; see prior revisions *) 

val sessionInfoCertBytesAuth: (si:SessionInfo) -> 
  (clo: (Cert.chain * a:Sig.alg * (;a)Sig.skey) option) ->
  (si':SessionInfo * b:bytes){
    (si.client_auth = false /\ si' = si /\ B(b) = [||]) \/
    (si.client_auth = true /\ clo = None /\ B(b) = CertificateMsg([]) /\ si = si') \/
    (si.client_auth = true /\  (?cl,a',b'. clo = Some((cl,a',b')) /\ B(b) = CertificateMsg(cl) /\ si'.clientID = cl))}

val certificateVerifyBytesAuth: si:SessionInfo -> 
  (;si) PRF.masterSecret -> 
  cert_req: (Cert.chain * a:Sig.alg * (;a)Sig.skey) option ->
  log:bytes{!cl,a,sk. cert_req = Some((cl,a,sk)) => Sig.Msg(a,Sig.PK(sk),log)} -> 
  b:bytes{
    ((si.client_auth = false \/ cert_req = None) /\ B(b) = [||]) \/
     (si.client_auth = true /\ 
         (?cl,a,sk,sign. 
            cert_req = Some((cl,a,sk)) /\
            B(b) = CertificateVerifyMsg(si.protocol_version,a,sign)))}

