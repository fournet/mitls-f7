module Handshake

// We haven't yet verified the Handshake implementation against this interface.

open Error
open CipherSuites
open TLSInfo
open DataStream
open Certificate
open StatefulAEAD

(* Control Interface *)

type (;ci:ConnectionInfo) hs_state
function val Config: ci:ConnectionInfo * s:(;ci)hs_state -> config
predicate val Authorize: config * cert -> bool
predicate val Complete: ConnectionInfo * config -> bool
predicate EvSentFinishedFirst of ConnectionInfo * bool
// AP: Not sure the SentCCS event is useful;
// rather I'd welome a SentFinished event, to model False Start
predicate val SentCCS: epoch -> bool

function val HSOutStream:  ci:ConnectionInfo * (;ci)hs_state -> 'a //(;ci.id_out)stream
function val CCSOutStream: ci:ConnectionInfo * (;ci)hs_state -> 'a //(;ci.id_out)stream
function val HSInStream:   ci:ConnectionInfo * (;ci)hs_state -> 'a //(;ci.id_in) stream
function val CCSInStream:  ci:ConnectionInfo * (;ci)hs_state -> 'a //(;ci.id_in) stream

predicate EmptyStreams of ci:ConnectionInfo * (;ci)hs_state
predicate SameStreams of ci:ConnectionInfo * (;ci)hs_state * (;ci)hs_state
assume !ci,s. EmptyStreams(ci,s) <=> (
		EmptyStream(ci.id_in,HSInStream(ci,s)) /\
		EmptyStream(ci.id_in,CCSInStream(ci,s)) /\
		EmptyStream(ci.id_out,HSOutStream(ci,s)) /\
		EmptyStream(ci.id_out,CCSOutStream(ci,s)) )
assume !ci,s,s'. SameStreams(ci,s,s') <=> (
		HSInStream(ci,s') = HSInStream(ci,s) /\
		CCSInStream(ci,s') = CCSInStream(ci,s) /\
		HSOutStream(ci,s') = HSOutStream(ci,s) /\
		CCSOutStream(ci,s') = CCSOutStream(ci,s) )

type (;ci:ConnectionInfo,c:config) nextState = s:(;ci)hs_state {Config(ci,s) = c}

val init:        r:Role            -> c:config  ->
	(ci:ConnectionInfo * s:(;ci)hs_state){ Config(ci,s) = c /\ ci.role = r /\
		IsNullCiphersuite(Epoci,sI(ci.id_in).cipher_suite) /\
		IsNullCiphersuite(Epoci,sI(ci.id_out).cipher_suite) /\
		EmptyStreams(ci,s)
		}
val resume:      nextSID:sessionID -> c:config  ->
	(ci:ConnectionInfo * s:(;ci)hs_state){ Config(ci,s) = c /\ ci.role = Client /\
		IsNullCiphersuite(Epoci,sI(ci.id_in).cipher_suite) /\
		IsNullCiphersuite(Epoci,sI(ci.id_out).cipher_suite) /\
		EmptyStreams(ci,s)}
val rehandshake: ci:ConnectionInfo -> s:(;ci)hs_state -> c:config  ->
	b:bool * s':(;ci)hs_state{
		((b = true /\ Config(ci,s') = c) \/ (b = false /\ Config(ci,s') = Config(ci,s))) /\
		SameStreams(ci,s,s')
		}
val rekey:       ci:ConnectionInfo -> s:(;ci)hs_state -> c:config  ->
	b:bool * s':(;ci)hs_state{
		((b = true /\ Config(ci,s') = c) \/ (b = false /\ Config(ci,s') = Config(ci,s))) /\
		SameStreams(ci,s,s')
		}
val request:     ci:ConnectionInfo -> s:(;ci)hs_state -> c:config  ->
	b:bool * s':(;ci)hs_state{
		((b = true /\ Config(ci,s') = c) \/ (b = false /\ Config(ci,s') = Config(ci,s))) /\
		SameStreams(ci,s,s')
		}
val authorize:   ci:ConnectionInfo -> s:(;ci)hs_state -> c:cert  ->
	s':(;ci,Config(ci,s))nextState { Authorize(Config(ci,s),c) /\ SameStreams(ci,s,s') }
val invalidateSession: ci:ConnectionInfo -> s:(;ci)hs_state -> s':(;ci,Config(ci,s))nextState{SameStreams(ci,s,s')}

(* Network Interface*)

type (;ci:ConnectionInfo,(;ci)hs_state) outgoing =
  | OutIdle of s':(;ci,Config(ci,s))nextState{SameStreams(ci,s,s')}
  | OutSome of (rg:range * f:(;ci.id_out,rg)Fragment.fragment * s':(;ci,Config(ci,s))nextState){
				(Auth(ci.id_out) => Fragment.Fragment(ci.id_out,HSOutStream(ci,s),rg,f) ) /\
				HSOutStream(ci,s') = Fragment.Extend(ci.id_out,HSOutStream(ci,s),rg,f) /\
				CCSOutStream(ci,s') = CCSOutStream(ci,s) /\
				HSInStream(ci,s') = HSInStream(ci,s) /\
				CCSInStream(ci,s') = CCSInStream(ci,s)
				}
  | OutCCS of  (rg:range * f:(;ci.id_out,rg)Fragment.fragment * 
               ci':ConnectionInfo * cs:(;ci'.id_out)StatefulAEAD.state * s':(;ci',Config(ci,s))nextState)
               { SentCCS(ci'.id_out) /\
			     StatefulPlain.EmptyHistory(ci'.id_out,cs.history) /\
			     ci.id_out = Pred(ci'.id_out) /\
                 ci.id_in = ci'.id_in /\
				 (Auth(ci.id_out) => Fragment.Fragment(ci.id_out,CCSOutStream(ci,s),rg,f) ) /\
				 EmptyStream(ci'.id_out,HSOutStream(ci',s')) /\
				 EmptyStream(ci'.id_out,CCSOutStream(ci',s')) /\
				 HSInStream(ci',s') = HSInStream(ci,s) /\
				 CCSInStream(ci',s') = CCSInStream(ci,s)
				 }
  | OutFinished of (rg:range * f:(;ci.id_out,rg)Fragment.fragment * s':(;ci,Config(ci,s))nextState){
				EvSentFinishedFirst(ci,true) /\
				(Auth(ci.id_out) => Fragment.Fragment(ci.id_out,HSOutStream(ci,s),rg,f) ) /\
				HSOutStream(ci,s') = Fragment.Extend(ci.id_out,HSOutStream(ci,s),rg,f) /\
				CCSOutStream(ci,s') = CCSOutStream(ci,s) /\
				HSInStream(ci,s') = HSInStream(ci,s) /\
				CCSInStream(ci,s') = CCSInStream(ci,s)
				}
  | OutComplete of (rg:range * f:(;ci.id_out,rg)Fragment.fragment * s':(;ci,Config(ci,s))nextState)
                   {Complete(ci,Config(ci,s)) /\
					(Auth(ci.id_out) => Fragment.Fragment(ci.id_out,HSOutStream(ci,s),rg,f) ) /\
					HSOutStream(ci,s') = Fragment.Extend(ci.id_out,HSOutStream(ci,s),rg,f) /\
					CCSOutStream(ci,s') = CCSOutStream(ci,s) /\
					HSInStream(ci,s') = HSInStream(ci,s) /\
					CCSInStream(ci,s') = CCSInStream(ci,s)
				   }
val next_fragment: ci:ConnectionInfo -> s:(;ci)hs_state -> (;(ci,s))outgoing

type (;ci:ConnectionInfo,c:config)incoming =
  | InAck of (;ci,c)nextState
  | InVersionAgreed  of (;ci,c)nextState
  | InQuery of Certificate.cert * (;ci,c)nextState
  | InFinished of (;ci,c)nextState {EvSentFinishedFirst(ci,false)}
  | InComplete of (;ci,c)nextState {Complete(ci,c)}
  | InError of ErrorCause * ErrorKind * (;ci,c)nextState
val recv_fragment: ci:ConnectionInfo -> s:(;ci)hs_state -> rg:range -> (;ci.id_in,rg)Fragment.fragment -> 
                   (;ci,Config(ci,s))incoming

type (;ci:ConnectionInfo,c:config)incomingCCS =
  | InCCSAck of ci':ConnectionInfo * (;ci'.id_in)StatefulAEAD.state * (;ci',c)nextState
				{ci.id_out = ci'.id_out /\ ci.id_in = Pred(ci'.id_in)}
  | InCCSError of ErrorCause * ErrorKind * (;ci,c)nextState
val recv_ccs     : ci:ConnectionInfo -> s:(;ci)hs_state -> rg:range -> (;ci.id_in,rg)Fragment.fragment -> 
                   (;ci,Config(ci,s))incomingCCS

val getNegotiatedVersion: ci:ConnectionInfo -> (;ci)hs_state -> ProtocolVersion
val getMinVersion:        ci:ConnectionInfo -> (;ci)hs_state -> ProtocolVersion