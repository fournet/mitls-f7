module Encode

open Bytes
open TLSInfo

open DataStream
open Fragment
open TLSConstants


//------------------------------------------------------------------------------------------------------
// Interface towards ENC 
//------------------------------------------------------------------------------------------------------
function val PlainLength: ki:epoch * tlen:nat -> plen:nat
private type (;ki:epoch,tlen:nat) plain = {p: (x:bytes){Length(x) = PlainLength(ki,tlen) /\ tlen <= DataStream.max_TLSCipher_fragment_length}}
val plain: ki:epoch{not Safe(ki)} -> tlen:nat{tlen <= DataStream.max_TLSCipher_fragment_length} -> b:bytes{Length(b) = PlainLength(ki,tlen)} -> (;ki,tlen) plain
val repr:  ki:epoch{not Safe(ki)} -> tlen:nat -> (;ki,tlen) plain -> b:bytes{Length(b) = PlainLength(ki,tlen)}


val pad: l:int -> b:bytes{Length(b) = l}

val check_split: 
  b:bytes -> i:int -> 
  b1:bytes * b2:bytes { Length(b1) = i /\ b = b1 @| b2 }


//------------------------------------------------------------------------------------------------------
// Interface towards AEAD
//------------------------------------------------------------------------------------------------------
function val IVSize: epoch -> nat
val ivLength: ki:succEpoch -> l:nat{l=IVSize(ki)}
type (;ki:epoch) data = (b:bytes){Length(b) = 8 + StatefulPlain.ADLength(ki)}
predicate AESays of ki:epoch * r:range * ad:(;ki) data * (;ki,r)fragment 

// Plaintext for AE
private type (;ki:epoch,r:range,ad:(;ki)data)AEPlain = {contents: (x:(;ki,r)fragment{Auth(ki) => AESays(ki,r,ad,x)})}
val AEPlain: ki:epoch{not Auth(ki)} -> r:range -> ad:(;ki)data -> (;r)rbytes -> (;ki,r,ad)AEPlain
val AERepr:  ki:epoch{not Safe(ki)} -> r:range -> ad:(;ki)data -> (;ki,r,ad)AEPlain -> (;r)rbytes

val AEConstruct: ki:epoch -> r:range -> ad:(;ki)data -> f:(;ki,r)fragment{Auth(ki) => AESays(ki,r,ad,f)} -> (;ki,r,ad)AEPlain
val AEContents:  ki:epoch -> r:range -> ad:(;ki)data -> (;ki,r,ad)AEPlain -> f:(;ki,r)fragment{Auth(ki) => AESays(ki,r,ad,f)}

// Plaintext of MAC
private type (;ki:epoch) MACPlain = {macP:bytes}
// Result of MAC
private type (;ki:epoch) tag = {macT:bytes}

function val MACPlain : 'a * 'b * 'c * 'd -> 'e
val macPlain: ki:epoch -> r:range -> 
  ad:(;ki)data ->
  f:(;ki,r,ad)AEPlain ->
  p:(;ki)MACPlain{p = MACPlain(ki,r,ad,f)}

predicate MACed of ki:epoch * (;ki) MAC.key * (;ki) MACPlain * (;ki) tag

val mac: ki:succEpoch -> k:(;ki) MAC.key -> t:(;ki) MACPlain{?r,ad,f. t = MACPlain(ki,r,ad,f) /\ 
                                                         (Auth(ki) => AESays(ki,r,ad,f.contents))}
  -> tag:(;ki) tag{Length(tag.macT) = MacKeySize(CipherSuiteMACAlg(EpochSI(ki).cipher_suite)) /\ MACed(ki,k,t,tag)}
val verify: ki:succEpoch -> k:(;ki) MAC.key -> text:(;ki) MACPlain -> tag:(;ki) tag ->
  v:bool{v = true => (?r,ad,f. text = MACPlain(ki,r,ad,f) /\ (Auth(ki) => AESays(ki,r,ad,f.contents))) /\ (MACed(ki,k,text,tag) => v = true)}

// Padding computations
val padLength: ki:succEpoch -> nat -> nat
function val RangeCipher: epoch * range -> nat // not injective
val rangeCipher: ki:succEpoch -> r:range -> tlen:nat{tlen = RangeCipher(ki,r) /\ tlen <= DataStream.max_TLSCipher_fragment_length}
val cipherRange: ki:succEpoch -> tlen:nat{tlen <= DataStream.max_TLSCipher_fragment_length} -> r:range{tlen = RangeCipher(ki,r)}

predicate val Encoded: 'e * 'a * 'b * 'c * 'd -> bool
val encode: ki:succEpoch{IsAEADCiphersuite(EpochSI(ki).cipher_suite)} ->
	rg:range -> ad:(;ki) data -> pl:(;ki,rg,ad) AEPlain -> tag:(;ki) tag ->
	(tlen:nat * p:(;ki,tlen) plain){tlen=RangeCipher(ki,rg) /\ tlen <= DataStream.max_TLSCipher_fragment_length /\ Encoded(ki,ad,pl,tag,p)}
val decode: ki:succEpoch{IsAEADCiphersuite(EpochSI(ki).cipher_suite)} ->
	ad:(;ki) data -> tlen:nat -> p:(;ki,tlen) plain ->
	(rg:range * pl:(;ki,rg,ad)AEPlain * tag:(;ki)tag * ok:bool){
          tlen=RangeCipher(ki,rg) /\
          (Encoded(ki,ad,pl,tag,p) => ok = true)}
val encodeNoPad: ki:succEpoch{IsOnlyMACCiphersuite(EpochSI(ki).cipher_suite) \/
                    CipherSuiteENCAlg(EpochSI(ki).cipher_suite) = RC4_128} ->
	rg:range -> ad:(;ki) data -> (;ki,rg,ad) AEPlain -> (;ki) tag ->
	(tlen:nat * (;ki,tlen) plain){tlen=RangeCipher(ki,rg) /\ tlen <= DataStream.max_TLSCipher_fragment_length}
val decodeNoPad: ki:succEpoch{IsOnlyMACCiphersuite(EpochSI(ki).cipher_suite) \/
                    CipherSuiteENCAlg(EpochSI(ki).cipher_suite) = RC4_128} ->
	ad:(;ki) data -> tlen:nat -> (;ki,tlen) plain ->
	(rg:range * (;ki,rg,ad)AEPlain * (;ki)tag){tlen=RangeCipher(ki,rg)}
// TODO: Say that the result of encode is "block-aligned" (more generally: compatible with the current enc algorithm)


//------------------------------------------------------------------------------------------------------
// Auxiliary definitions and Assumes for typing (CHECK!)
//------------------------------------------------------------------------------------------------------

function val MsgBytes: ki:epoch * (;ki) data * bytes -> bytes
assume !ki,ad,x. MsgBytes(ki,ad,x) = (ad @| IntBytes(2,Length(x))) @| x 
assume !ki,ad1,x1,ad2,x2. (Length(ad1) = Length(ad2) /\
                        MsgBytes(ki,ad1,x1) = MsgBytes(ki,ad2,x2)) => 
                       (ad1 = ad2 /\ x1=x2)

assume !ki,tlen,pl. MAC.Msg(ki,pl) <=>
  (not Auth(ki) \/
     (?ad,x. Length(ad) = (8 + StatefulPlain.ADLength(ki)) /\
	  pl = MsgBytes(ki,ad,x)))

ask !ki,t. not Auth(ki) => MAC.Msg(ki,t)



predicate type preds = Unsafe of epoch
private assume !ki. Unsafe(ki) <=> not Auth(ki)
assume !ki. IVSize(ki) >= 0
assume !ki,si. si = EpochSI(ki) =>
	( si.protocol_version = SSL_3p0 \/ si.protocol_version = TLS_1p0
		=> IVSize(ki) = 0 ) /\
	( si.protocol_version = TLS_1p1 \/ si.protocol_version = TLS_1p2
		=> IVSize(ki) = BlockSize(CipherSuiteENCAlg(si.cipher_suite)) )
assume !ki,si,tlen. si = EpochSI(ki) =>
	( IsOnlyMACCiphersuite(si.cipher_suite) => PlainLength(ki,tlen) = tlen ) /\
    ( IsAEADCiphersuite(si.cipher_suite) /\ tlen >= IVSize(ki) =>
	  PlainLength(ki,tlen) = tlen - IVSize(ki) )


// The following conversions embed AEADPlains into AEPlains 
val AEADPlainToAEPlain: ki:epoch -> r:range -> ad:(;ki)AEADPlain.data -> (;ki,r,ad) AEADPlain.AEADPlain -> (;ki,r,ad) AEPlain
val AEPlainToAEADPlain: ki:epoch -> r:range -> ad:(;ki)AEADPlain.data -> (;ki,r,ad) AEPlain -> (;ki,r,ad) AEADPlain.AEADPlain
assume !ki,r,d,f. AESays(ki,r,d,f) <=> AEADPlain.AEADSays(ki,r,d,f)

//Comments:

// AP and CF agree: Encode is indexed by (ki and) its public length, after encoding (and not by range).
// We define function from:
// - public length of ciphertext to public length of encoded plaintext (either identity, or minus iv length)
// - from tlen to public range of decoded authenticated fragment
// - (and the inverse functions)
