module CRE

open Bytes
open TLSConstants
open TLSInfo
open TLSPRF
open Error
open PMS

(*  extractMS is internal and extracts entropy from both rsapms and dhpms bytes 

    Intuitively we require extractMS to be at least a deterministic computational randomness extractor for both 
    of the distributions generated by genRSA and sampleDH. 

    PRF.sample si ~_C extractMS si genRSA pk vc //for related si and pk vc
    PRF.sample si ~_C extractMS si sampleDH p g //for related si and p g

    In reality honest clients and servers can be tricked by an active adversary to run different 
    and multiple extraction algorithms on the same pms. We call this an agile extractor, following:
    http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.187.6929&rep=rep1&type=pdf

    There may be some relations to non-malleable extractors, we are however deterministic and computational setting:
    https://www.cs.nyu.edu/~dodis/ps/it-aka.pdf . 

*)

let extractMS sinfo pmsBytes: PRF.masterSecret =
    let pv = sinfo.protocol_version in
    let cs = sinfo.cipher_suite in
    let data = csrands sinfo in
    let res = prf pv cs pmsBytes tls_master_secret data 48 in
    PRF.coerce sinfo res


(*  Idealization strategy: to guarantee that in ideal world mastersecrets (ms) are completely random
    extractRSA samples a ms at radom when called first on arguments pk,cv,pms,csrands si. 
    
    When called on the same values again, the corresponding master secret is retrieved from a secret log. 

    This is done only for pms for which honestRSAPMS is true. Note that in this way many idealized master 
    secrets can be derived from the same pms.
 *)


#if ideal
let todo s = failwith s 

// We maintain a log for looking up good ms values using their pms values
type rsaentry = RSAKey.pk * ProtocolVersion * rsapms * bytes * PRF.prfAlg * PRF.ms

let rsalog = ref []

let rec rsaassoc (pk:RSAKey.pk) (cv:ProtocolVersion) (pms:rsapms)  (csr:bytes) (pa:PRF.prfAlg) (mss:rsaentry list): PRF.ms option = 
    match mss with 
    | [] -> None 
    | (pk',cv',pms',csr',pa', ms)::mss' when pk=pk' && cv=cv' && pms=pms' && csr=csr' && pa=pa' -> Some(ms) 
    | _::mss' -> rsaassoc pk cv pms csr pa mss'

#else
let todo s = ()
#endif

(*private*) 
let accessRSAPMS (pk:RSAKey.pk) (cv:ProtocolVersion) pms = 
  match pms with 
  #if ideal
  | IdealRSAPMS(b) -> b.seed
  #endif
  | ConcreteRSAPMS(b) -> b 

let extractRSA_new si (cv:ProtocolVersion) pms: PRF.masterSecret = 
    let pk = 
        match (Cert.get_chain_public_encryption_key si.serverID) with 
        | Correct(pk) -> pk
        | _           -> unexpected "server must have an ID"    
    #if ideal
    if PRF.safeMS_msIndex (RSAPMS(pk,cv,pms), csrands si, PRF.prfAlgOf si) then
        //We assoc on pk, cv, pms,  csrands, and prfAlg
        match rsaassoc pk cv pms (csrands si) (PRF.prfAlgOf si) !rsalog with 
        | Some(ms) -> ms
        | None -> 
                 let ms = PRF.sample si 
                 rsalog := (pk,cv,pms,csrands si, PRF.prfAlgOf si, ms)::!rsalog
                 ms
    else
        todo "SafeMS_SI ==> SafeMS_msIndex"; extractMS si (accessRSAPMS pk cv pms)
    #else
    extractMS si (accessRSAPMS pk cv pms)
    #endif

let extractRSA si (cv:ProtocolVersion) pms = 
  match pms with
  #if ideal
  | IdealRSAPMS(s) (* TODO: when StrongCRE(prfAlg si); otherwise extractMS si s *) ->
        let pk = 
            match (Cert.get_chain_public_encryption_key si.serverID) with 
            | Correct(pk) -> pk
            | _           -> unexpected "server must have an ID"    
        //We assoc on pk, cv, pms and csrands 
        match rsaassoc pk cv pms (csrands si) (PRF.prfAlgOf si) !rsalog with 
        | Some(ms) -> ms
        | None -> 
                 let ms = PRF.sample si 
                 rsalog := (pk,cv,pms,csrands si, PRF.prfAlgOf si, ms)::!rsalog
                 ms
  #endif  
  | ConcreteRSAPMS(s) -> todo "SafeMS_SI ==> HonestRSAPMS"; extractMS si s


// The trusted setup for Diffie-Hellman computations
open DHGroup

#if ideal
// We maintain a log for looking up good ms values using their pms values
type dhentry = p * g * elt * elt * dhpms * csrands * PRF.prfAlg * PRF.masterSecret
let dhlog = ref []
#endif

let sampleDH p g (gx:DHGroup.elt) (gy:DHGroup.elt) = 
    let gz = DHGroup.genElement p g in
    #if ideal
    IdealDHPMS({seed=gz}) 
    #else
    ConcreteDHPMS(gz)  
    #endif

let coerceDH (p:DHGroup.p) (g:DHGroup.g) (gx:DHGroup.elt) (gy:DHGroup.elt) b = ConcreteDHPMS(b) 

#if ideal

let rec dhassoc (p:p) (g:g) (gx:elt) (gy:elt) (pms:dhpms)  (csr:csrands) (pa:PRF.prfAlg) (mss:dhentry list): PRF.masterSecret option = 
    match mss with 
    | [] -> None 
    | (p',g',gx',gy',pms',csr',pa',ms)::mss' when p=p' && g=g' && gx=gx' && gy=gy' && pms=pms' && csr=csr' && pa'=pa-> Some(ms) 
    | _::mss' -> dhassoc p g gx gy pms csr pa mss'

#endif

let extractDHE (si:SessionInfo) (p:DHGroup.p) (g:DHGroup.g) (gx:DHGroup.elt) (gy:DHGroup.elt) (pms:dhpms): PRF.masterSecret =
    match pms with
    //#begin-ideal 
    #if ideal
    | IdealDHPMS(s) -> 
        match dhassoc p g gx gy pms (csrands si) (PRF.prfAlgOf si) !dhlog with
           | Some(ms) -> ms
           | None -> 
                 let ms=PRF.sample si 
                 dhlog := (p, g, gx, gy, pms, csrands si, PRF.prfAlgOf si, ms)::!dhlog;
                 ms 
    #endif
    //#end-ideal
    | ConcreteDHPMS(s) -> todo "SafeHS_SI ==> HonestDHPMS"; extractMS si s
   