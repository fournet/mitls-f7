module HSFragment
open Bytes
open TLSInfo
open Range

private type (;ki:epoch,r:range) fragment = {frag: (;r)rbytes}
private type (;ki:epoch) stream = {sb:bytes list}

predicate Sent of ki:epoch * (;ki) stream * r:range * (;ki,r)fragment
assume !ki,s,r,f. Sent(ki,s,r,f) (*KB No Handshake/Alert/CCS Authentication *)

type (;e:epoch,s:(;e)stream,r:range)plain = f:(;e,r)fragment{Auth(e) => Sent(e,s,r,f)}

function val Payload: e:epoch * r:range * (;e,r)fragment -> 'a // (;r)rbytes
private definition !e,r,f. Payload(e,r,f) = f.frag

function val EmptyStream: e:epoch -> (;e)stream
private definition !e. EmptyStream(e) = {sb = []}
val init: e:epoch -> s:(;e)stream{s = EmptyStream(e)}

val fragmentPlain: ki:epoch -> r:range -> b:(;r) rbytes -> f:(;ki,EmptyStream(ki),r) plain{b = Payload(ki,r,f)}
val fragmentRepr:  ki:epoch -> r:range -> f:(;ki,r) fragment -> b:(;r) rbytes{b = Payload(ki,r,f)}

//AP Unless the two streams are the same, this functions breaks the streaming
//AP authentication property (which we currently don't prove for HS/CCS/Alert) 
val reStream: e:epoch -> s:(;e)stream -> r:range -> p:(;e,s,r)plain -> s':(;e)stream ->
	p':(;e,s',r)plain{Payload(e,r,p) = Payload(e,r,p')}

val widen: e:epoch -> r0:range -> r1:range {r1 = RangeClass(e,r0)} -> 
    f0:(;e,r0)fragment -> f1:(;e,r1)fragment{Payload(e,r0,f0) = Payload(e,r1,f1) /\ !s. Sent(e,s,r0,f0) => Sent(e,s,r1,f1)}

function val Extend: e:epoch * s:(;e)stream * r:range * (;e,r)fragment -> 'a // (;e)stream
private definition !ki,s,r,f. Extend(ki,s,r,f) = {sb = f.frag :: s.sb }
val extend: e:epoch -> s:(;e)stream -> r:range -> f:(;e,r)fragment -> s':(;e)stream{s'=Extend(e,s,r,f)}

 

