module TLS

open Error
open Bytes
open DataStream
open AppDataStream
open Dispatch
open TLSInfo 
// for ConnectionInfo, Client, Server, ... 

//TODO: change Direction to role 
//KB: I disagree. Directions are the right abstraction for epoch. 
//    If need be, it would be better to define a role in ConnectionInfo.
//CF: ?? Client is more natural than CtoS here. For now we have a painful mix of the two. 

type role = Direction

type index = ConnectionInfo
type params = protocolOptions
type cn //= Dispatch.Connection

// type epoch, as defined in TLSInfo

function val Role: cn -> Direction
assume !c. Role(c) = ConnectionOutKeyInfo(c).dir

// Peer(i) ghostly refers to the remote peer's index 
function val Peer: index -> index 
assume !ki. Peer(ki) = { id_in = ki.id_out; id_out = ki.id_in }

// Security predicates and events; may be defined elsewhere
predicate val TXT: index -> bool
predicate val SEC: index -> bool

predicate val Write:   (index * bytes) -> bool
predicate val Warning: (index * bytes) -> bool // missing argument
predicate val Close:   (index * bytes) -> bool
predicate val Fatal:   (index * bytes) -> bool // missing argument
// Write records increasing prefixes of the stream, for each written data fragment, 
// interleaved with warnings, ended by Fatal or Close [we may distinguish between two kinds of close too]
// Write(i,p0), ..., Write(i,p0 @| ... @| pi), Warning(i,p0 @| ... @| pi), ..., Close(i, p0 @| ... @| pn)

// predicate val Read :   (index * bytes) -> bool //AP: Unused. Everything is defined as a correspondence on Write

function val CnId: c:cn -> index
function val CnStream_i: c:cn -> (;ConnectionInKeyInfo(c)) stream // FIXME move to epoch
function val CnStream_o: c:cn -> (;ConnectionOutKeyInfo(c)) stream
assume !id, s. CnId(Conn(id, s)) = id
assume !id, s. CnStream_i(Conn(id, s)) =  InStream(id, s.appdata)
assume !id, s. CnStream_o(Conn(id, s)) = OutStream(id, s.appdata)  //TODO: should we index appdata with id??
//CF redundant?
function val Bytes_o: cn -> bytes
function val Bytes_i: cn -> bytes
assume !c. Bytes_o(c) = CnStream_i(c)
assume !c. Bytes_i(c) = CnStream_o(c)

val getInKI:  c:Connection -> k:epoch{k=ConnectionInKeyInfo(c)}
val getOutKI: c:Connection -> k:epoch{k=ConnectionOutKeyInfo(c)}
val getSessionInfo: k:epoch -> s:SessionInfo{s=EpochSI(k)}
val getInStream:  c:Connection -> s:(;ConnectionInKeyInfo(c)) stream{s=CnStream_i(c)}
val getOutStream: c:Connection -> s:(;ConnectionOutKeyInfo(c))stream{s=CnStream_o(c)}

//TODO define Bytes_o from Pending.
// !ci,s. ci.pending      => Bytes_o(Conn(ci,s)) = OutStream(ci.next,    s.appdata)
// !ci,s. not(ci.pending) => Bytes_o(Conn(ci,s)) = OutStream(ci.current, s.appdata)

// These types embed a precise range for message lengths
type (;c:cn) msg_i = r:range * (;ConnectionInKeyInfo(c),  CnStream_i(c), r) delta
type (;c:cn) msg_o = r:range * (;ConnectionOutKeyInfo(c), CnStream_o(c), r) delta

predicate val Split_o: (cn * msg_o * msg_o * cn * msg_o)  -> bool

// Abbreviations for specifying connection invariants 
predicate val Extend:   (c:cn * c':cn) -> bool
predicate val Extend_o: (c:cn * c':cn * (;c) msg_o) -> bool
predicate val Extend_i: (c:cn * c':cn * (;c) msg_i) -> bool

// updating c within the same epoch
type (;c:cn) nextCn = c':cn {  Role(c')    = Role(c) 
                            /\ CnId(c')    = CnId(c)
                            /\ Params(c')  = Params(c) }
definition !c, c'. 
  Extend(c, c') <=>            Bytes_i(c') = Bytes_i(c)
                            /\ Bytes_o(c') = Bytes_o(c)
definition !c, c', msg. 
  Extend_o(c, c', msg) <=>   Bytes_i(c') = Bytes_i(c)
                            /\ Bytes_o(c') = Bytes_o(c) @| msg
definition !c, c', msg. 
  Extend_i(c, c', msg) <=>   Bytes_i(c') = Bytes_i(c) @| msg
                            /\ Bytes_o(c') = Bytes_o(c)

//TODO: in SameConnection, enforce the chaining for all HS-specific data, in particular to chain successive handshakes.
//TODO: fix alertDescription, so that it only represents the second byte. 
//TODO: check that we are not too restrictive for the ongoing connection once we start negotiating.
//TODO: regroup the bits of the TLS library that are needed in the API.
//TODO: write the "toplevel" automata, from the user viewpoint; consider enforcement by typing, session-style.

// authorization query; TBD with principals
type (;c:cn) query

type (;c:cn) ioresult_i =
| Read      of c':(;c) nextCn * d:(;c) msg_i
  {Extend_i(c,c',d) /\ (TXT(CnId(c)) => Write(Peer(CnId(c)), Bytes_i(c'))) }
  // We received a data fragment, appended to the input stream)

| Close     of Tcp.NetworkStream  {TXT(CnId(c)) => Close(Peer(CnId(c)), Bytes_i(c))}
  // We received an alert notifying the normal closure of the connection; 
  // we learn that we have read everything sent by our peer,
  // and we get back the underlying TCP connection. 

| ReadError of alertDescription option 
  // We encountered an error while reading, so the connection dies. 
  // we return the fatal alert we may have sent, if any,
  // or None in case of an internal error.

| Fatal     of a:alertDescription {TXT(CnId(c)) => Fatal(Peer(CnId(c)), a, Bytes_i(c))}
  // We received an alert notifying the abnornal closure of the connection by our peer
  // We learn that we have read everything sent by our peer.
  
| Warning   of c':(;c) nextCn * a:alertDescription 
  {Extend(c,c') /\ TXT(CnId(c)) => Warning(Peer(CnId(c)), a, Bytes_i(c))}
  // We received a warning (at this point in the input stream)

| CertQuery of c':(;c) nextCn * (;c') query {Extend(c, c')} 
  // We received the peer certificates for the next epoch, to be authorized before proceeding.

| Handshake of c':cn {
    Role(c') = Role(c) /\ 
	Bytes_i(c') = [||] /\ 
	((Pending(c) /\ Bytes_o(c') = Bytes_o(c)) \/ Bytes_o(c') = [||]) /\ 
	Pred(Current(c')) = Current(c) /\
	(Next(c) = None \/ Next(c) = Some(Current(c'))) /\
	// Epoch(c') = ci::Epoch(c) /\ ci is the next connection info of c, if any
	Close(Peer(CnId(c)),Bytes_i(c))
	// informally: !b. Close(c,b) => CloseAck(Peer(CnId(c),b)
	}
  // We completed a run of the Handshake, moving to the next epoch.
  // we learn that we have read everything sent by our peer in the closing epoch
  // LATER: with additional "Read" events, we could also learn that our peer has read everything we sent in the closing epoch
	
	//Cedric: ?? 
	//AP: /\ Close(CnId(c),Bytes_o(c)) /\  -- and same for Alert protocol, and hanshake.
	// We need to show agreement on the content of all protocols in previous and current connection to express the Alert attack (and therefore authentication)

| NoWrite of c':cn 
	// Mashup of ioresult_i.Read and ioresult_o.MustRead
	{	   Role(c') = Role(c)
		/\ Params(c') = Params(c)
		/\ ConnectionInKeyInfo(c') = ConnectionInKeyInfo(c)
		/\ Bytes_i(c') = Bytes_i(c)
		/\ Bytes_o(Next(c')) = [||] //?
    } // AP: TXT(index) is not precise enough here:
	  // in/out directions are not the same, and we want to only refer to the incoming direction
  // We must wait till the next epoch before writing application data again.  
  // Without false start, we have the global invariant that Pending(c) => Bytes_o(c) = [||]

val read : c:cn -> (;c) ioresult_i
// TODO: document the events possibly recorded by calls to read

type (;c:cn,d:(;c) msg_o) ioresult_o =
| WriteComplete of c':(;c) nextCn {Extend_o(c,c',d)}
  // We wrote the message in full. appended to the output stream

	//AP: /\ Write(CnId(c'),Bytes_o(c')) -- we need to generate the Write event somewhere, and this (and WritePartial) looks like a good place.

| WritePartial  of c':(;c) nextCn * d':(;c') msg_o 
  { ?d0. Extend_o(c,c',d0) /\ Split_o(c, d, d0, c', d') }
  // We wrote a fragment of the message, appended to the output stream, and return the rest

| WriteError    of alertDescription option 
  // We encountered an error while writing; 
  // we return the fatal alert we may have sent, if any,
  // or None in case of an internal error.

| MustRead      of c':cn 
    {   Role(c')    = Role(c) 
     /\ Params(c')  = Params(c)
	 /\ Current(c') = Current(c)
	 /\ (Next(c) = None \/ Next(c') = Next(c))  
     /\ Bytes_i(c') = Bytes_i(c)
	 /\ not(Pendinc(c)) /\ Pending(c') 
	 /\ Bytes_o(c') = [||]
	 // and we assumed write completion on Bytes_o(c)
	  }
  // We need to read towards the next epoch 

// ? 
// this assumes that Bytes_o(c') does a test on Pending.
// we can still access the bytes written in c using Current(c)

val write: c:cn -> d:(;c,rg) msg_o -> (;c,d) ioresult_o
// On the write side, the following events may be generated:
// - Write(ki,Bytes_o(c')) 
// - Close(ki,Bytes_o(c))
// WriteError reports a local error
// WriteComplete reports write completion
// WritePartial reports partial write completion, and returns the rest
// MustRead signals that the connection cannot be used anymore for writing until a new handshake completes. 
// (it may be a bit too restrictive) 


// special NULL_NULL initial connection index
// cannot be used for data writing (by typing)
val null: i:index{NullKeyInfo(i.id_in) /\ NullKeyInfo(i.id_out)}
type (;r:role,p:params) nullCn = c:cn {CnId(c) = null /\ Params(c) = p /\ Role(c) = r}

val connect: Tcp.NetworkStream -> p:params                  -> (;Client,p) nullCn Result
val resume:  Tcp.NetworkStream -> p:params -> sid:sessionID -> (;Client,p) nullCn Result 
// even if the server declines, we authenticate the client's intent to resume from this sid.

val accept:  Tcp.NetworkStream -> p:params                  -> (;Server,p) nullCn Result

val shutdown: c:cn -> Tcp.NetworkStream Result
//was: (c':(;c) nextCn {Extend(c,c')}) Result
// [shutdown] will internally generate a Close(ki, Bytes_o(c)); releases the TCP socket after shutdown
// AP: I don't agree with current shutdown. With the current interface we cannot have a one-way shutdown.
// Not even if shutdown just sets some flag, and then we have to read. I propose two different
// specialized functions for each behavior:
// - full_shutdown, which returns immediately, and then the user must read until she gets a Close event
// - half_shutdown, where we internally send (write) our close notify, and then we drop the connection.
// Cedric: is it a live comment? do we really need both? 

val rekey:       c:cn {Role(c)=CtoS} -> (c':(;c) nextCn {Extend(c,c')}) Result
val rehandshake: c:cn {Role(c)=CtoS} -> (c':(;c) nextCn {Extend(c,c')}) Result
val request:     c:cn {Role(c)=StoC} -> (c':(;c) nextCn {Extend(c,c')}) Result

// we echo the query so that we have an explicit user decision to blame.
val authorize: c:cn -> (;c) query -> (c': (;c) nextCn {Extend(c,c')}) Result
val refuse:    c:cn -> (;c) query -> unit //AP: we will have to internally send a fatal alert,
	// and this might fail. We might want to give some feedback to the user. Same as half_shutdown

(* For each call through this API, say connect(x,p) returning r,
   we may use homonymous events, say Connect(x,p) & Connected(x,p,r), 
   or something more ad hoc, like Writing, generated internally between Write & Written
   (s/Write/Writing/ later) 

   Missing: 

   predicate val Nego(cp,sp,ki) 
   // ki (or some other part of ci?) is an outcome of negotiating 
   // with initial parameters cp and sp; we will write its logical def.
   // it would be great if ki was unique, and non-existent if cp, sp are not compatible. 

   We miss some "Finished" event, 
   generated by the Handshake for each party, as it sends the CCS, carried by the Finished message
   To generate this event, we have a precise precondition that depends on the ciphersuite etc
   (from Handshake), to support fast start
   
   The other end logically receives that event after verifying the other guy's Finished message
   We reveal that event in the TLS interface, as a consequence of read returning Handshake.
   We may reveal that event early, using another ioresult_i, e.g. to enable "fast start".

   Example: as the client receives notification of a complete handshake, we have a thm:
   
   !c,c'. Read(c,Handshake(c')) => 
          ?sp.   Nego(cp(c),sp,ki(c'))
		      /\ Next(c,c') /\ Epoch(c') = Epoch(c)+1  
		      /\ ?c''. (Authorized(c'',serverCerts(c')) /\ Prior(c'',c))
			  /\ ( StrongHandshakeCipherSuite(ki(c')) /\ Honest(serverCerts(ki(c'))) 
			       => ServerFinished(sp,ki(*?*))

   Problem: intuitively, events tracking calls & returns are threaded by their connections,
   but logically that information is missing. To this end, we may explicitly thread connections,
   using 
   
   Next(c,c') <=> UID(c') = UID(c) /\ Seqn(c') = Seqn(c) + 1
   Prior(c,c') <=> UID(c') = UID(c) /\ Epoch(c') = Epoch(c) /\ Seqn(c) < Seqn(c')
     
   *)
 