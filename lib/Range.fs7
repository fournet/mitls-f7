module Range

(* This modules defines the range computations for length-hiding *) 

open Bytes
open TLSConstants
open TLSInfo

type range = low:nat * high:nat { low <= high }
type (;r:range) rbytes = b:bytes { ?l,h. r = (l,h) /\ l <= Length(b) /\ Length(b) <= h }   
function val Sum: range * range -> range
definition !l0,h0,l1,h1. Sum((l0,h0),(l1,h1)) = (l0+l1,h0+h1)
val sum: r0:range -> r1:range -> r:range{r = Sum(r0,r1)}

predicate SubRange of range * range
definition !l0,l1,h0,h1. SubRange((l0,h0),(l1,h1)) <=> l1 <= l0 && h0 <= h1

//TODO MK whole file from epoch to id 
function val RangeClass: id * range -> range
function val TargetLength: id * range -> nat
function val CipherRangeClass: id * nat -> range

definition !e,r. RangeClass(e,r) = CipherRangeClass(e,TargetLength(e,r))
theorem !e,t,rg.  rg = CipherRangeClass(e,t) => t = TargetLength(e,rg)
theorem !e,r. SubRange(r,RangeClass(e,r))

function val IVSize: id -> nat
definition 
	(!e,mac. CipherSuiteAuthEncAlg(EpochSI(e).cipher_suite,EpochSI(e).protocol_version) = MACOnly(mac) => IVSize(e) = 0) /\
	(!e,mac. CipherSuiteAuthEncAlg(EpochSI(e).cipher_suite,EpochSI(e).protocol_version) = MtE(Stream_RC4_128,mac) => IVSize(e) = 0 ) /\ 
	(!e,mac,alg. CipherSuiteAuthEncAlg(EpochSI(e).cipher_suite,EpochSI(e).protocol_version) = MtE(CBC_Stale(alg),mac) => IVSize(e) = 0 ) /\ 
	(!e,mac,alg. CipherSuiteAuthEncAlg(EpochSI(e).cipher_suite,EpochSI(e).protocol_version) = MtE(CBC_Fresh(alg),mac) => IVSize(e)= BlockSize(alg))

ask !e. (?mac. CipherSuiteAuthEncAlg(EpochSI(e).cipher_suite,EpochSI(e).protocol_version) = MACOnly(mac) \/
	  CipherSuiteAuthEncAlg(EpochSI(e).cipher_suite,EpochSI(e).protocol_version) = MtE(Stream_RC4_128,mac)) => IVSize(e) = 0

val ivSize: e:succEpoch -> l:nat{l=IVSize(e)}

function val KeyDerivationIVSize: id -> nat
definition !e. KeyDerivationIVSize(e)=KeyDerivationIVSize_AEAlg(CipherSuiteAuthEncAlg(EpochSI(e).cipher_suite,EpochSI(e).protocol_version))


val fixedPadSize: id:id -> l:nat{l=1}
//AP (si.extended_record_padding = true /\ l=2) \/
//AP (si.extended_record_padding = false /\ l=1)}

function val MaxPadSize: i:id * unit -> nat //TODO MK fix spec
private definition !i,mac,alg.
    (i.aeAlg = MACOnly(mac) 	        => MaxPadSize(i,()) = 0)  /\
    (i.aeAlg = MtE(Stream_RC4_128,mac) 	=> MaxPadSize(i,()) = 0 ) /\
    (i.aeAlg = MtE(CBC_Fresh(alg),mac) /\ (PvOfId(i) = TLS_1p0 \/ PvOfId(i) = TLS_1p1 \/ PvOfId(i) = TLS_1p2) 
	                                    => MaxPadSize(i,()) = 255) /\
    (i.aeAlg = MtE(CBC_Stale(alg),mac) /\ (PvOfId(i) = TLS_1p0 \/ PvOfId(i) = TLS_1p1 \/ PvOfId(i) = TLS_1p2) 
                                        => MaxPadSize(i,()) = 255) /\
    (i.aeAlg = MtE(CBC_Fresh(alg),mac) /\ PvOfId(i) = SSL_3p0
										=> MaxPadSize(i,()) = BlockSize(alg)) /\
    (i.aeAlg = MtE(CBC_Stale(alg),mac) /\ PvOfId(i) = SSL_3p0
										=> MaxPadSize(i,()) = BlockSize(alg))

val maxPadSize: i:id -> l:nat{l = MaxPadSize(i,())}

val minMaxPad: i:id -> l:nat * h:nat{
	(MaxPadSize(i,()) = 0 /\ l = 0 /\ h = 0 ) \/
	 MaxPadSize(i,()) > 0 /\ l = 1 /\ h = MaxPadSize(i,())}

//AP (* A range that can be conveyed in one fragment *)
//AP predicate RangeFragment of SessionInfo * range
//AP definition !si,l,h. RangeFragment(si,(l,h)) <=>
//AP 	( h <= fragmentLength /\ h - l <= MaxPadSize(si,()))
//AP type (;si:SessionInfo) rangeF = r:range{RangeFragment(si,r)}

// Padding computations
function val Modulus: int * int -> int
//private definition !x,y. Modulus(x,y) = bop_Modulus(x,y)
 
function val BlockAlignedPadding: id * nat -> nat
definition !e,mac,alg,l.
	(CipherSuiteAuthEncAlg(EpochSI(e).cipher_suite,EpochSI(e).protocol_version) = MACOnly(mac)  => BlockAlignedPadding(e,l) = 0 ) /\
	(CipherSuiteAuthEncAlg(EpochSI(e).cipher_suite,EpochSI(e).protocol_version) = MtE(Stream_RC4_128,mac)  => BlockAlignedPadding(e,l) = 0 ) /\
	
	(CipherSuiteAuthEncAlg(EpochSI(e).cipher_suite,EpochSI(e).protocol_version) = MtE(CBC_Fresh(alg),mac) /\ Modulus(l + 1,BlockSize(alg)) = 0 =>  
                                 BlockAlignedPadding(e,l) = 1) /\
	(CipherSuiteAuthEncAlg(EpochSI(e).cipher_suite,EpochSI(e).protocol_version) = MtE(CBC_Stale(alg),mac) /\ Modulus(l + 1,BlockSize(alg)) = 0 =>  
                                 BlockAlignedPadding(e,l) = 1) /\
	(CipherSuiteAuthEncAlg(EpochSI(e).cipher_suite,EpochSI(e).protocol_version) = MtE(CBC_Fresh(alg),mac) /\ Modulus(l + 1,BlockSize(alg)) <> 0 =>  
                                 BlockAlignedPadding(e,l) = 1 + BlockSize(alg) - Modulus(l + 1,BlockSize(alg))) /\
	(CipherSuiteAuthEncAlg(EpochSI(e).cipher_suite,EpochSI(e).protocol_version) = MtE(CBC_Stale(alg),mac) /\ Modulus(l + 1,BlockSize(alg)) <> 0 =>  
                                 BlockAlignedPadding(e,l) = 1 + BlockSize(alg) - Modulus(l + 1,BlockSize(alg)))



private val blockAlignPadding: e:succEpoch -> l:nat -> l':nat{l' = BlockAlignedPadding(e,l)}

definition !e,l,h.
	TargetLength(e,(l,h)) =
		IVSize(e) + h + MacKeySize(CipherSuiteMACAlg(EpochSI(e).cipher_suite,EpochSI(e).protocol_version)) +
		BlockAlignedPadding(e,h + MacKeySize(CipherSuiteMACAlg(EpochSI(e).cipher_suite,EpochSI(e).protocol_version)))

val targetLength: e:succEpoch -> r:range -> 
  tlen:nat {tlen = TargetLength(e,r) /\ tlen <= max_TLSCipher_fragment_length}

(*KB
definition !e,tlen,alg,mac.
	((CipherSuiteAuthEncAlg(EpochSI(e).cipher_suite,EpochSI(e).protocol_version) = MtE(CBC_Fresh(alg),mac) \/
	  CipherSuiteAuthEncAlg(EpochSI(e).cipher_suite,EpochSI(e).protocol_version) = MtE(CBC_Stale(alg),mac)) =>
         (!x. x = tlen - IVSize(e) - MacKeySize(CipherSuiteMACAlg(EpochSI(e).cipher_suite,EpochSI(e).protocol_version)) - 1 /\ x >= 0 =>
             ((x < 255 => CipherRangeClass(e,tlen) = (0,x)) /\
              (x >= 255 => CipherRangeClass(e,tlen) = (x-255,x))))) /\
	((CipherSuiteAuthEncAlg(EpochSI(e).cipher_suite,EpochSI(e).protocol_version) = MACOnly(mac) \/
	  CipherSuiteAuthEncAlg(EpochSI(e).cipher_suite,EpochSI(e).protocol_version) = MtE(Stream_RC4_128,mac)) =>
         (!x. x = tlen - IVSize(e) - MacKeySize(CipherSuiteMACAlg(EpochSI(e).cipher_suite,EpochSI(e).protocol_version)) /\ x >= 0 =>
             CipherRangeClass(e,tlen) = (x,x)))
*)
definition 
	(!e,tlen,alg,mac,x. 
           CipherSuiteAuthEncAlg(EpochSI(e).cipher_suite,EpochSI(e).protocol_version) = MtE(CBC_Fresh(alg),mac) /\ 
            x = tlen - IVSize(e) - MacKeySize(mac) - 1 /\ 
            x >= 0 =>
             ((x < 255 /\ CipherRangeClass(e,tlen) = (0,x)) \/
              (x >= 255 /\ CipherRangeClass(e,tlen) = (x-255,x)))) /\
	(!e,tlen,alg,mac,x. 
	  CipherSuiteAuthEncAlg(EpochSI(e).cipher_suite,EpochSI(e).protocol_version) = MtE(CBC_Stale(alg),mac) /\
            x = tlen - IVSize(e) - MacKeySize(mac) - 1 /\ 
            x >= 0 =>
             ((x < 255 /\ CipherRangeClass(e,tlen) = (0,x)) \/
              (x >= 255 /\ CipherRangeClass(e,tlen) = (x-255,x)))) /\
	(!e,tlen,mac,x. 
	  CipherSuiteAuthEncAlg(EpochSI(e).cipher_suite,EpochSI(e).protocol_version) = MACOnly(mac) /\
          x = tlen - MacKeySize(mac) /\ 
          x >= 0 => CipherRangeClass(e,tlen) = (x,x)) /\
	(!e,tlen,mac,x. 
	  CipherSuiteAuthEncAlg(EpochSI(e).cipher_suite,EpochSI(e).protocol_version) = MtE(Stream_RC4_128,mac) /\
          x = tlen - IVSize(e) - MacKeySize(mac) /\ x >= 0 =>
             CipherRangeClass(e,tlen) = (x,x))

val cipherRangeClass: e:succEpoch -> 
  tlen:nat{tlen <= max_TLSCipher_fragment_length} -> 
  r:range {r = CipherRangeClass(e,tlen)}

val rangeClass: e:succEpoch -> r0:range -> r1:range{r1 = RangeClass(e,r0)}

//AP type (;e:id)frange = l:nat * h:nat{l<=h /\ TargetLength(e,rg) <= max_TLSCipher_fragment_length
//AP									/\ h-l <= MaxPad(e)}
