module TLSInfo

(* This module gathers the definitions of 
   public datatypes, parameters, and predicates for our TLS API.
   
   Its interface is used by most TLS modules; its implementation is typechecked. *)

open Bytes
open Date
open TLSConstants

(* 

- We need to typecheck ideal code, so write all modules in the style
   #if ideal
   if safe...(...) 
     ... GEN ...
   else 
   #endif
     .... COERCE ...
  This requires concrete safe/auth/strong/honest functions

*)

// -------------------------------------------------------------------

// polarity for reading and writing, e.g. for stateful encryption
type rw =
    | Reader
    | Writer


type preRole =
	| Client
	| Server
type Role = r:preRole{r = Client \/ r = Server}

function val DualRole: Role -> Role
definition DualRole(Client) = Server
definition DualRole(Server) = Client

// -------------------------------------------------------------------
// Client/Server randomness (implemented in Nonce) 

// their first 4 bytes give the local time, 
// so that they are locally pairwise-distinct
type random = (;32) lbytes 
type crand = random
type srand = random
type csrands = (;64) lbytes
//CF 04-09 the randoms are not just bytes; where do we rely on collision-resistance?


// -------------------------------------------------------------------
// SPECIFYING HONESTY (TRUST ASSUMPTIONS) 

// Predicates specifying the honesty of keys and key material

predicate HonestSig of a:sigHashAlg * (;a) Sig.pkey
definition !a,k. HonestSig(a,k) <=> Sig.Honest(a,k)

// ``The associated sk is used only by compliant TLS''
predicate HonestRSAKey of RSAKey.pk
definition !pk. HonestRSAKey(pk) <=> RSAKey.Honest(pk)

//MK: predicate HonestLTKey (See also Cert.fs7)

// -------------------------------------------------------------------
// pre-master-secret index and encrypted data 

// we use pmsId as an opaque index to pms
private type pmsId = 
    | NoPmsId 
	| SomePmsId of PMS.pms
val noPmsId: pmsId

function val PmsId: PMS.pms -> pmsId
private definition !pms. PmsId(pms) = SomePmsId(pms)

val pmsId: pms:PMS.pms -> id:pmsId{ id = PmsId(pms) } 


// ``this pms is honestly generated and used for extraction''
predicate HonestPMS of pmsId 
definition !pk,cv,rsapms.    HonestPMS(SomePmsId(PMS.RSAPMS(pk,cv,rsapms)))   <=> PMS.HonestRSAPMS(pk,cv,rsapms)  
definition !p,g,gx,gy,dhpms. HonestPMS(SomePmsId(PMS.DHPMS(p,g,gx,gy,dhpms))) <=> PMS.HonestDHPMS(p,g,gx,gy,dhpms) 

val honestPMS: (pi:pmsId) -> b:bool {b=true => HonestPMS(pi)} //MK <= TODO currently can't typecheck other direction.


//CF unclear what its purpose is besides pmsId
type pmsData =
    | PMSUnset
    | RSAPMS of pk:RSAKey.pk * ProtocolVersion * encpms:bytes
    | DHPMS  of p:DHGroup.p * g:(;p)DHGroup.g *
		  	      gx:(;p)DHGroup.elt (* Client *) *
			      gy:(;p)DHGroup.elt (* Server *)

// To be defined 
predicate HonestRSAPMSData of pk:RSAKey.pk * pv:ProtocolVersion * encpms:bytes
predicate HonestDHPMSData of p:DHGroup.p * g:(;p)DHGroup.g *
		  	      gx:(;p)DHGroup.elt (* Client *) *
			      gy:(;p)DHGroup.elt (* Server *)

predicate HonestPMSData of pmsData
definition !pd. HonestPMSData(pd) <=>
      ((?pk,pv,e. pd = RSAPMS(pk,pv,e) /\ HonestRSAPMSData(pk,pv,e)) \/
       (?p,g,gx,gy. pd = DHPMS(p,g,gx,gy) /\ HonestDHPMSData(p,g,gx,gy)))

// -------------------------------------------------------------------
// master-secret indexes

// CF We cannot use just csr, because of MiTM forwarding honest nonces
type msId =        // We record the parameters used to derive this MS: 
  pms   : pmsId *     // the pms and its indexes  
  csr   : csrands *   // the nonces  
  creAlg: creAlg      // the PMS-PRF algorithm

// ``creAlg is a strong randomness extractor, despite all other creAlgs''
// guarding idealization in CRE
predicate StrongCRE of creAlg 
val strongCRE: ca:creAlg -> b:bool {b=true <=> StrongCRE(ca)}

// ``the MS at this index is abstractly generated and used within PRF''
predicate HonestMS of msId 
definition !pmsId,csr,creAlg. 
  HonestMS((pmsId,csr,creAlg)) <=> HonestPMS(pmsId) /\ StrongCRE(creAlg)
//CF are we missing a correlation with csr? 
//MK we don't allow leak, so every MS derived from an 
//MK HonestPMS with strong CRE algorithms is honest?
//MK More uniformally this would go through a definition of SafeCRE.

predicate StrongKDF   of kdfAlg
predicate StrongVD    of vdAlg

// -------------------------------------------------------------------
// Session information (public immutable data)

type sessionID = b:bytes {Length(b) <= 32}
// "An arbitrary byte sequence chosen by the server 
// to identify an active or resumable session state."
// We treat empty_bytes as the absence of identifier.

// TODO this is out of sync with the paper, on client_auth.
type SessionInfo = {
    init_crand: crand;
    init_srand: srand;
    protocol_version: ProtocolVersion;
    cipher_suite: cipherSuite;
    compression: Compression;
	pmsId: pmsId;
    pmsData: pmsData;
    client_auth: bool;
    clientID: Cert.cert list;
    serverID: Cert.cert list;
    sessionID: sessionID;
    // Extensions:
    extended_record_padding: bool;
    }
// for certificates, the empty list represents the absence of identity 
// (possibly refusing to present requested certs) 
//   
// for sessionID, the empty bytes empty_bytes represents the absence of ID,
// that is, the session is not resumable. 

function val CSRands: SessionInfo -> csrands
definition !si,csr. csr=CSRands(si) <=> B(csr)=B(si.init_crand) @| B(si.init_srand) 
val csrands: si:SessionInfo -> csr:csrands {csr=CSRands(si)}


// Getting algorithms from SessionInfo

function val PrfAlg:  SessionInfo -> prfAlg
definition !si.  PrfAlg(si) = (si.protocol_version,si.cipher_suite)
val prfAlg: si:SessionInfo -> a:prfAlg {a=PrfAlg(si)}

function val CreAlg:  SessionInfo -> creAlg
definition !si. (si.protocol_version = SSL_3p0 => CreAlg(si) = CRE_SSL3_nested ) /\
				(si.protocol_version = TLS_1p0 => CreAlg(si) = CRE_TLS_1p01(extract_label)    ) /\
				(si.protocol_version = TLS_1p1 => CreAlg(si) = CRE_TLS_1p01(extract_label)    ) /\
				(si.protocol_version = TLS_1p2 => CreAlg(si) = CRE_TLS_1p2(extract_label,CiphersuitePrfMacAlg(si.cipher_suite) ) )
val creAlg: si:SessionInfo -> a:creAlg {a=CreAlg(si)}

function val KdfAlg:  SessionInfo -> kdfAlg
definition !si.  KdfAlg(si) = (si.protocol_version,si.cipher_suite)
val kdfAlg: si:SessionInfo -> a:kdfAlg {a=KdfAlg(si)}

function val VdAlg:  SessionInfo -> vdAlg
definition !si.  VdAlg(si) = (si.protocol_version,si.cipher_suite)
val vdAlg: si:SessionInfo -> a:vdAlg {a=VdAlg(si)}

function val SIaeAlg: SessionInfo -> aeAlg
definition !si. SIaeAlg(si) = CipherSuiteAuthEncAlg(si.cipher_suite,si.protocol_version)


// Getting master-secret indexes out of SessionInfo

function val MsI: SessionInfo -> msId
definition !si. MsI(si) = (si.pmsId, CSRands(si), CreAlg(si)) 
val msi: si:SessionInfo -> i:msId { i = MsI(si) }

// Strengths of Handshake algorithms defined on pmsId and SessionInfo

// Here we consider the strength of the parameters in pmsId
predicate StrongRSAKEX of pmsId 
definition !pk,cv,rsapms.    StrongRSAKEX(SomePmsId(PMS.RSAPMS(pk,cv,rsapms)))   <=> PMS.SafeRSA(pk,cv) 

predicate StrongDHKEX  of pmsId 
definition !p,g,gx,gy,dhpms.  StrongDHKEX(SomePmsId(PMS.DHPMS(p,g,gx,gy,dhpms))) <=> PMS.SafeDH(p,g,gx,gy)

//CF Safe???KEX was a synonym of Honest???PMS?
//MK I think it's only coincidental in the current PMS that HonestPMS implies SafeKEX. Lets keep it for discussions.
//MK They replace StrongRSAPMS and StrongDHPMS.


predicate StrongSig    of SessionInfo
definition !si. StrongSig(si) <=> Sig.Strong(CipherSuiteSigHashAlg(si.cipher_suite))


// ``The algorithms of si are strong for both KDF and VerifyData, despite all others''
// guarding idealization in PRF
predicate StrongPRF of SessionInfo
definition !si. StrongPRF(si) <=> StrongKDF(KdfAlg(si)) /\ StrongVD(VdAlg(si))
// MK I think having this joint strenghth predicate 
// MK guaranteeing the idealization of the complete module is useful

// Summarizing all assumptions needed for a strong handshake
// CF derived & to be used in the public API only
predicate StrongHS of SessionInfo 
definition !si. StrongHS(si) <=> 
  (   (StrongRSAKEX(si.pmsId) \/ StrongDHKEX(si.pmsId)) /\ 
      StrongCRE(CreAlg(si)) /\ 
	  StrongPRF(si) /\ 
	  StrongSig(si) ) //CF * hashAlg for certs?

// safety of SessionInfo crypto processing

predicate SafeCRE of SessionInfo // Safe handshake for PMS-based extraction
definition !si. HonestMS(MsI(si)) <=> SafeCRE(si)    
val safeCRE:   (si:SessionInfo) -> b:bool { b=true <=> SafeCRE(si) }

predicate SafeVD  of SessionInfo // Safe handshake for MS-based VerifyData
definition !si. SafeVD(si) <=> HonestMS(MsI(si)) /\ StrongVD(VdAlg(si))
val safeVD:    (si:SessionInfo) -> b:bool { b=true <=> SafeVD(si) }
//MK: safeVD is used for idealization even if ciphersuites don't match.
//MK: this is needed to guarantee security of finished message MACs


// SafeHS depends on having an 'idealized' mastersecret, 
// and performing both strong session key generation and finished message verification
// both are implied by StrongHS
predicate SafeHS_SI of SessionInfo // Safe handshake for this sessioninfo
definition !si. SafeHS_SI(si) <=> HonestMS(MsI(si)) /\ StrongHS(si) 
val safeHS_SI: (si:SessionInfo) -> b:bool { b=true <=> SafeHS_SI(si)}


predicate StrongAuthSI of SessionInfo
definition !si. StrongAuthSI(si) <=> 
  (?e,m. CipherSuiteAuthEncAlg(si.cipher_suite,si.protocol_version) = MtE(e,m) /\ INT_CMA_M(m))

predicate StrongAESI of SessionInfo
definition !si. StrongAESI(si) <=> 
                StrongAEAlg(si.protocol_version,CipherSuiteAuthEncAlg(si.cipher_suite,si.protocol_version))




// -------------------------------------------------------------------
// Epoch descriptors (public immutable data)

private type preEpoch =
  | InitEpoch of writer:Role
  | SuccEpoch of crand * srand  (* the latest randoms     *)
               * si:SessionInfo
               * pred:preEpoch 

predicate val IsInitEpoch: preEpoch -> bool
predicate val IsSuccEpoch: preEpoch -> bool
private definition !e. IsInitEpoch(e) <=> ?r. e = InitEpoch(r)
private definition !e. IsSuccEpoch(e) <=> ?c,s,si,pe. e = SuccEpoch(c,s,si,pe)

type epoch = e:preEpoch {IsInitEpoch(e) \/ IsSuccEpoch(e)}
type succEpoch = e:preEpoch {IsSuccEpoch(e)}

function val Pred: succEpoch -> epoch
private definition !cr,sr,si,pred. Pred(SuccEpoch(cr,sr,si,pred)) = pred

function val EpochSI: succEpoch -> SessionInfo
private definition !c,s,si,p. EpochSI(SuccEpoch(c,s,si,p)) = si

function val EpochSRand: succEpoch -> bytes
function val EpochCRand: succEpoch -> bytes
private definition !b1,b2,si,pe. EpochSRand(SuccEpoch(b1,b2,si,pe)) = b2
private definition !b1,b2,si,pe. EpochCRand(SuccEpoch(b1,b2,si,pe)) = b1

val epochSRand: e:succEpoch -> b:crand{B(b) = B(EpochSRand(e))}
val epochCRand: e:succEpoch -> b:srand{B(b) = B(EpochCRand(e))}
val epochCSRands: e:succEpoch -> b:csrands{B(b) = B(EpochCRand(e)) @| B(EpochSRand(e))}

val isInitEpoch: e:epoch -> b:bool{(b = true /\ IsInitEpoch(e)) \/ (b = false /\ IsSuccEpoch(e))}
val epochSI: e:succEpoch -> si:SessionInfo{si = EpochSI(e)}

function val EpochWriter: epoch -> Role
definition !r. EpochWriter(InitEpoch(r)) = r 
definition !r. EpochWriter(InitEpoch(r)) = r 
definition !r,cr,sr,si,pred. EpochWriter(SuccEpoch(cr,sr,si,pred)) = EpochWriter(pred)
val epochWriter: e:epoch -> r:Role {r=EpochWriter(e)}

predicate StrongAuth of epoch
predicate StrongAE of epoch

definition !e. StrongAuth(e) <=> StrongAuthSI(EpochSI(e))
definition !e. StrongAE(e)   <=> StrongAESI(EpochSI(e))

// -------------------------------------------------------------------
// Connection information (public immutable data)

type ConnectionInfo =
	{ role: Role;
	  id_rand: random;
	  id_in:  epoch;
      id_out: epoch}

val connectionRole: ci:ConnectionInfo -> r:Role{r = ci.role}

val initConnection: r:Role -> ra:random -> ci:ConnectionInfo
  { ci.role = r /\ ci.id_rand = ra /\ IsInitEpoch(ci.id_in) /\ IsInitEpoch(ci.id_out)}
val nextEpoch: e:epoch -> c:crand -> s:srand -> si:SessionInfo -> e':succEpoch
  { Pred(e') = e /\ EpochSI(e') = si /\ EpochCRand(e') = c /\ EpochSRand(e') = s}

// -------------------------------------------------------------------
// the tight index we use as an abstract parameter for StatefulAEAD et al
type id = { 
  // indexes and algorithms of the session used in the key derivation
  msId   : msId;   // the index of the master secret used for key derivation
  kdfAlg : kdfAlg; // the KDF algorithm used for key derivation
  pv     : ProtocolVersion; //Should be part of aeAlg 
  aeAlg  : aeAlg;  // the authenticated-encryption algorithms
  // epoch-specific parameters
  csrConn: csrands;// the client-server random of the connection
  writer : Role    // the role of the writer 
  }

function val Swap: id -> id
definition !i:id. Swap(i)= 
  { msId    = i.msId; 
    kdfAlg  = i.kdfAlg; 
	pv      = i.pv; 
	aeAlg   = i.aeAlg; 
	csrConn = i.csrConn; 
	writer  = DualRole(i.writer); }

//MK fails, why? 
//ask !i,i'.  Swap(i)=Swap(i') => i=i'
//ask !i:id. Swap(Swap(i)) = i

function val SiId: SessionInfo * Role -> id
definition !si:SessionInfo,writer:Role. SiId(si,writer) = 
  { msId    = MsI(si); 
    kdfAlg  = KdfAlg(si);
	pv = si.protocol_version; //Should be part of aeAlg 
	aeAlg   = SIaeAlg(si);
	csrConn = CSRands(si);
	writer  = writer;
 }
 
function val Id: succEpoch -> id
definition !e. Id(e) = SiId(EpochSI(e),EpochWriter(e))
val id: s:succEpoch -> i:id {Id(s)=i}

val idInv: i:id -> s:succEpoch {Id(s)=i}

function val MacAlg: id -> macAlg
definition !id. MacAlg(id)=AEMacAlg(id.aeAlg)
val macAlg_of_id: i:id -> m:macAlg { MacAlg(i)=m } 

function val EncAlg: id -> encAlg
definition !id. EncAlg(id)=AEEncAlg(id.aeAlg)
val encAlg_of_id: i:id -> e:encAlg { EncAlg(i)=e } 

val kdfAlg_of_id: id -> kdfAlg //TODO add and specify

function val PvOfId: i:id -> pv:ProtocolVersion
definition !i. PvOfId(i)=i.pv
val pv_of_id: i:id -> pv:ProtocolVersion {pv=PvOfId(i)} 

predicate SafeKDF of id // Safe handshake for MS-based key derivation 
definition !i:id. SafeKDF(i) <=> HonestMS(i.msId) /\ StrongKDF(i.kdfAlg)
val safeKDF: (i:id) -> b:bool { b=true <=> SafeKDF(i) }

//not HonestMS(msi) excludes both idealizations in PRF.
ask !si. not HonestMS(MsI(si)) => not SafeVD(si) /\ not SafeKDF(SiId(si,Server))
 
// ``The MAC algorithm of id is INT-CMA.''
predicate StrongAuthId of id
definition !id:id. StrongAuthId(id) <=> INT_CMA_M(MacAlg(id))

predicate StrongAEId of id
definition !id:id. StrongAEId(id) <=> StrongAEAlg(id.pv,id.aeAlg)

/// Safety is conditioned on ideal algorithm match (see PRF)
type event =
  | KeyCommit of    csrands * ProtocolVersion * aeAlg 
  | KeyGenClient of csrands * ProtocolVersion * aeAlg 

// these two properties follow from the affine usage of keyCommit and keyGenClient
theorem !csr,pv0,ae0,pv1,ae1. 
  (KeyCommit(csr,pv0,ae0) /\ KeyCommit(csr,pv1,ae1)) => (pv0=pv1 /\ ae0 = ae1) 
theorem !csr,pv0,ae0,pv1,ae1. 
  (KeyGenClient(csr,pv0,ae0) /\ KeyGenClient(csr,pv1,ae1)) => (pv0=pv1 /\ ae0 = ae1) 

predicate Match of id 
definition !i:id. Match(i) <=> KeyCommit(i.csrConn,i.pv,i.aeAlg) /\ KeyGenClient(i.csrConn,i.pv,i.aeAlg)

//MK verifies, but not other direction. CF usage?
//     ask !si,r:Role. StrongAuthSI(si) => StrongAuthId(SiId(si,r))

//MK verifies
//MK   ask !i:id,e,m. StrongAuthId(i) => INT_CMA_M(MacAlg(i))

// ``We are idealizing integrity for this id''
predicate AuthId of id
definition !i.  
  AuthId(i) <=> SafeKDF(i) /\ Match(i) /\ StrongAuthId(i)
// MK was !i. AuthId(SiId(si,r)) <=> SafeHS_SI(si) /\ StrongAuthId(SiId(si,r))

ask !i. AuthId(i) => Match(i) // sanity check; just by definition

val authId: (i:id) -> b:bool {b = true <=> AuthId(i)}

ask !i. AuthId(i) => SafeKDF(i) 
//MK seems obvious but doesn't verify

ask !i:id. AuthId(i) => StrongAuthId(i)

ask !i:id. AuthId(i) => INT_CMA_M(MacAlg(i))

predicate SafeId of id
definition !i. SafeId(i) <=> SafeHS_SI(si) /\ StrongAESI(si)
val safeId : (i:id) -> b:bool {b = true <=> SafeId(i)}

// MK fails
//ask !e,mac. e.aeAlg  = MACOnly(mac) => not SafeId(e)

(* SPECIFYING SAFETY *) 

// In the code of ideal implementations only,
// we use F# functions that characterize the Safe and Auth predicates.

// Safety for epochs relies only on SessionInfo, but this would change if we introduce a finer model of compromise
// E.g. if we allowed the attacker to compromise specific epochs

predicate SafeHS of epoch          // Safe handshake for this epoch //CF Avoid?
definition !id. SafeHS(id) <=> SafeHS_SI(EpochSI(id))

val safeHS: (e:epoch) -> b:bool { b = true <=> SafeHS(e)}

// Predicates specifying the security of TLS connections 

predicate SafeSI  of SessionInfo // The session ciphersuite yields secrecy and integrity
definition !si. SafeSI(si) <=> SafeHS_SI(si) /\ StrongAESI(si)

predicate AuthSI  of SessionInfo // The session ciphersuite yields integrity (not necessarily secrecy)
definition !si. AuthSI(si) <=> SafeHS_SI(si) /\ StrongAuthSI(si)

predicate Safe   of epoch        // The epoch parameters yield privacy & integrity
definition !e. Safe(e) <=> SafeSI(EpochSI(e))
val safe:   (e:epoch) -> b:bool { b = true <=> Safe(e)}

predicate Auth   of epoch        // The epoch parameters yield integrity (not necesarily privacy)
definition !e. Auth(e) <=> AuthSI(EpochSI(e))
val auth:    (e:epoch) -> b:bool {b = true <=> Auth(e)}

ask !e. Safe(e) => Auth(e)

// so that TLS can exchange any traffic on the initial null connection
// CF suspicious! MK changed into ask, fails!
//ask !e. IsInitEpoch(e) => not Auth(e)

// -------------------------------------------------------------------
// Application configuration options
// TODO Consider repackaging client and server options 

type helloReqPolicy =
    | HRPIgnore
    | HRPFull
    | HRPResume

type config = {
    minVer: ProtocolVersion;
    maxVer: ProtocolVersion;
    ciphersuites: cipherSuites;
    compressions: Compression list;

    (* Handshake specific options *)

    (* Client side *)
    honourHelloReq: helloReqPolicy;
    allowAnonCipherSuite: bool;

    (* Server side *)
    request_client_certificate: bool;
    check_client_version_in_pms_for_old_tls: bool;

    (* Common *)
    safe_renegotiation: bool;
	server_name: Cert.hint;
	client_name: Cert.hint;

    (* Sessions database *)
    sessionDBFileName: string;
    sessionDBExpiry: TimeSpan
    }

val defaultConfig: config

//CF move those to TLSConstants? 
private val max_TLSPlaintext_fragment_length: nat
private val max_TLSCompressed_fragment_length: nat
val max_TLSCipher_fragment_length: nat
val fragmentLength: nat
