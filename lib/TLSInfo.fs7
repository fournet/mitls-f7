module TLSInfo

open Bytes
open Certificate
open CipherSuites

type sessionID = bytes
type preRole =
	| Client
	| Server
type Role = preRole

//CF 04-09
// the randoms are not just bytes.

type SessionInfo = {
    init_crand: bytes; 
    init_srand: bytes;
    protocol_version: ProtocolVersion;
    cipher_suite: cipherSuite;
    compression: Compression;
    clientID: cert option;
    serverID: cert option;
    sessionID: sessionID option; }

type preEpoch =
	| Init of Role * bytes 
	| Succ of crand:bytes * srand:bytes * si:SessionInfo * pred:preEpoch 

type epoch = p:preEpoch
    { !crand,srand,si,pred,r. p=Succ(crand,srand,si,pred) => (pred = Init(Client,r) => r = crand /\ 
	   pred = Init(Server,r) => r = srand) }


// AP: Not enough if we want to implement TLS using this index.
// We need 5 states:
// 1) None next epoch
// 2) Some next epoch, but don't use it
// 3) Some next epoch, use it for read only
// 4) Some next epoch, use it for write only
// 5) Some next epoch, use it for read/write
// CF: 04-09 This seems to duplicate some logic in dispatch and handshake. To be discussed.

type preCI = {
  current: epoch; 
  next   : epoch option;
  pending: bool; }
// AP: I propose
//type preCI = {
//  current: epoch;
//  next   : epoch option;
//  pending_read:  bool;
//  pending_write: bool;
//}
// If the user writes in state 4 (or 5), then she's using false start
// If any pending is true, then next must be Some.
// val epochIn : CI -> epoch
// val epochOut: CI -> epoch


function val Pred: epoch -> epoch

type CI = c:preCI  
  { c.next = None => c.pending = false /\
	!e. c.next = Some(e) => (* properly negotiated & *) c.current = Pred(e) }

//TODO: enforce as an invariant that the new epoch is compatible with our local parameters
//      (that the the peer certificates (if any) have been authorized is not a public invariant) 

//predicate function SameEpoch: CI * CI -> bool
predicate SameEpoch of CI * CI
definition !c,c'. SameEpoch(c,c') <=> 
  (c'.current = c.current /\ 
  (c.next = None \/ c'.next = c.next) /\ // we may need something more general, like Finer(c'.next,c.next) 
  c'.pending = c.pending)

// WAS:
//type ConnectionInfo =
//    { role: Role;
//	  id_in:  KeyInfo;
//    id_out: KeyInfo}

/// Application configuration options

type helloReqPolicy =
    | HRPIgnore
    | HRPFull
    | HRPResume

type TimeSpan

type protocolOptions = {
    minVer: ProtocolVersion;
    maxVer: ProtocolVersion;
    ciphersuites: cipherSuites;
    compressions: Compression list;

    (* Handshake specific options *)
    (* Client side *)
    honourHelloReq: helloReqPolicy;
    allowAnonCipherSuite: bool;
    (* Server side *)
    request_client_certificate: bool;
    check_client_version_in_pms_for_old_tls: bool;
    server_cert_file: string; (* FIXME: certificates should be found in a better way. To be fixed *)
    (* Common *)
    certificateValidationPolicy: cert list -> bool;
    safe_renegotiation: bool;

    (* Sessions database *)
    sessionDBFileName: string;
    sessionDBExpiry: TimeSpan
    }

val defaultProtocolOptions: protocolOptions





///////////////////// the rest is deprecated //////////////////////////


// We only store direction, which is either
// Client --> Server (CtoS for short) or
// Server --> Client (StoC for short).
// We store the direction along with the KeyInfo.
// We finally compute the role from the direction associated to the outgoing KeyInfo
type preDirection =
    | CtoS
    | StoC
type Direction = d:preDirection{d = CtoS \/ d = StoC}
(* FIXME: Automatic inference by F7 *)

function val DualDirection: Direction -> Direction
assume DualDirection(CtoS) = StoC
assume DualDirection(StoC) = CtoS

val dualDirection: d1:Direction -> d2:Direction{d2=DualDirection(d1)}


predicate UserSaysCompatibleSessions of SessionInfo * SessionInfo

predicate CompatibleSessions of SessionInfo * SessionInfo
assume !s. CompatibleSessions(s,s)
assume !s1,s2,s3. CompatibleSessions(s1,s2) /\ CompatibleSessions(s2,s3) => CompatibleSessions(s1,s3)
assume !s1,s2. UserSaysCompatibleSessions(s1,s2) => CompatibleSessions(s1,s2)

// not in the API
predicate NullSessionInfo of SessionInfo 
assume !nulls,s. NullSessionInfo(nulls) => CompatibleSessions(nulls,s)

//predicate CompatibleConnections of ConnectionInfo * ConnectionInfo
predicate CompatibleConnections of CI * CI

//assume !id1,id2. CompatibleConnections(id1,id2) <=>
//assume !id1,id2. CompatibleConnections(id1,id2) <=> CompatibleSessions(id1.id_in.sinfo, id2.id_in.sinfo ) /\
//                   CompatibleSessions(id1.id_out.sinfo,id2.id_out.sinfo) )

//MK does this make sense?
assume !id1,id2. CompatibleConnections(id1,id2) <=>
		 ?crand1,srand1,si1,pred1,crand2,srand2,si2,pred2. id1.current=Succ(crand1,srand1,si1,pred1) 
		 /\ id2.current=Succ(crand2,srand2,si2,pred2) /\ CompatibleSessions(si1, si2)



assume !si. NullSessionInfo(si) <=> (si.clientID = None /\ si.serverID = None /\ si.sessionID = None /\
    IsNullCiphersuite(si.cipher_suite) /\ si.compression = NullCompression /\ si.init_crand = [||] /\ si.init_srand = [||] )

val null_sessionInfo: pv:ProtocolVersion -> si:SessionInfo{NullSessionInfo(si)}
val isNullSessionInfo: s:SessionInfo -> b:bool{b=true => NullSessionInfo(s)}

// not in the API
type KeyInfo = {
    sinfo: SessionInfo;
    dir: Direction;
    crand: bytes;
    srand: bytes
    // cVerifyData: bytes
    // sVerifyData: bytes
    }

type ConnectionInfo =
	{ id_in:  KeyInfo;
      id_out: KeyInfo}

predicate NullKeyInfo of KeyInfo

private assume !ki. NullKeyInfo(ki) <=> (NullSessionInfo(ki.sinfo) /\ ki.crand = [||] /\ ki.srand = [||])

val null_KeyInfo: d:Direction -> pv:ProtocolVersion -> ki:KeyInfo{NullKeyInfo(ki)}

function val DualKeyInfo: (KeyInfo * unit) -> KeyInfo
assume !k1,dummy. DualKeyInfo(k1,dummy) = {
	sinfo = k1.sinfo;
	dir=DualDirection(k1.dir);
	crand=k1.crand;
	srand=k1.srand}

val dual_KeyInfo: k1:KeyInfo -> k2:KeyInfo{k2=DualKeyInfo(k1,())}
// We might need something like this -- and possibly more
// definition !ki. NullKeyInfo(ki) => NullSessionInfo(ki.sinfo)

predicate Corrupt of KeyInfo

assume !ki. CipherSuites.IsNullCiphersuite(ki.sinfo.cipher_suite) => Corrupt(ki)

/// Cryptographic assumptions [how to make them toplevel?]

predicate type cryptopreds = 
    Safe of KeyInfo
  | Auth of KeyInfo
  | CTXT of KeyInfo * bytes * bytes * bytes

assume !ki. Safe(ki) => Auth(ki)
