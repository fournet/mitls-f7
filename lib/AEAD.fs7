module AEAD

open Bytes
open Error
open TLSInfo

open TLSConstants

(* no need to be more precise on the length *)
type cipher = b:bytes{Length(b) <= max_TLSCipher_fragment_length}

private type (;ki:epoch) AEADKey =
    | MtE of ka:(;ki)MAC.key * ke:(;ki)ENC.state // {MtEKey(ki,(ka,ke))}
    | MACOnly of (;ki) MAC.key
(*  | GCM of ke:(;ki:AENC.state)  *)

// TODO: Define AEADSize. 
// In the code, (AEADSize * 2) is computed in TLSConstants.getKeyExtensionLength

function val IVSize: epoch -> nat
val ivLength: e:succEpoch -> l:nat{l=IVSize(e)}
function val AEADSize: ki:epoch -> nat
private assume !ki,si. si = EpochSI(ki) =>
	( IsOnlyMACCiphersuite(si.cipher_suite) =>
	  AEADSize(ki) = MacKeySize(TLSConstants.CipherSuiteMACAlg(si.cipher_suite)) ) /\
	( IsAEADCiphersuite(si.cipher_suite) =>
	  AEADSize(ki) = MacKeySize(TLSConstants.CipherSuiteMACAlg(si.cipher_suite)) +
					    EncKeySize(TLSConstants.CipherSuiteENCAlg(si.cipher_suite)) +
					    IVSize(ki) )

//CF '13 who wrote this? when? 
//TODO Why is this failing? Because of AEADSize not being what I want, I cannot typecheck COERCE.
//TODO ask !ki. IsOnlyMACCiphersuite(EpochSI(ki).cipher_suite) => AEADSize(ki,ki) = MacKeySize(TLSConstants.CipherSuiteMACAlg(EpochSI(ki).cipher_suite))

val GEN:    ki:succEpoch{Safe(ki)}     -> encryptor:(;ki)AEADKey * decryptor:(;ki)AEADKey
val COERCE: ki:succEpoch{not Auth(ki)} -> b:bytes{Length(b) = AEADSize(ki)} -> (;ki)AEADKey
val LEAK:   ki:succEpoch{not Auth(ki)} -> (;ki)AEADKey -> b:bytes

(* KB: 2/5. Partial implementation of CTXT in the code. *)
predicate val CTXT: 'a * 'b * 'c * 'd -> bool
predicate val NotCTXT: 'a * 'b * 'd -> bool
assume !ki,d,p,c. NotCTXT(ki,d,c) => not CTXT(ki,d,p,c)
assume !ki,d,p,p',c. (CTXT(ki,d,p,c) /\ CTXT(ki,d,p',c)) => p = p'
private val mteKey: ki:epoch -> (;ki) MAC.key -> (;ki) ENC.state -> (;ki) AEADKey

// Padding computations
private val blockAlignPadding: e:succEpoch -> nat -> nat

// Some trivial ranges
private assume !e,l.
	( IsOnlyMACCiphersuite(EpochSI(e).cipher_suite) \/ CipherSuiteENCAlg(EpochSI(e).cipher_suite) = RC4_128 ) =>
		Encode.CipherRange(e,(l,l),l+MacKeySize(CipherSuiteMACAlg(EpochSI(e).cipher_suite)))
private val rangeCipher: e:succEpoch -> r:range -> tlen:nat{Encode.CipherRange(e,r,tlen) /\ tlen <= max_TLSCipher_fragment_length}
private val cipherRange: e:succEpoch -> tlen:nat{tlen <= max_TLSCipher_fragment_length} -> r:range{Encode.CipherRange(e,r,tlen)}

//FIXME: next two should be ask
private assume !e,si. si = EpochSI(e) =>
	( si.protocol_version = SSL_3p0 \/ si.protocol_version = TLS_1p0
		=> IVSize(e) = 0 ) /\
	( si.protocol_version = TLS_1p1 \/ si.protocol_version = TLS_1p2
		=> IVSize(e) = BlockSize(CipherSuiteENCAlg(si.cipher_suite)) )
private assume !e,si,tlen. si = EpochSI(e) =>
	( IsOnlyMACCiphersuite(si.cipher_suite) => Encode.PlainLength(e,tlen) = tlen ) /\
    ( IsAEADCiphersuite(si.cipher_suite) /\ tlen >= IVSize(e) =>
	  Encode.PlainLength(e,tlen) = tlen - IVSize(e) )

// We have two variants for encryption and decryption: 
// the first (primed) is concrete; the second is idealized at safe indexes.

val encrypt': ki:succEpoch -> (;ki) AEADKey -> ad:(;ki)AEADPlain.adata ->
  rg:range -> p:(;ki,ad,rg) AEADPlain.plain ->
  ((;ki) AEADKey * c:cipher){Encode.CipherRange(ki,rg,Length(c))}

val encrypt : ki:succEpoch -> (;ki) AEADKey -> ad:(;ki)AEADPlain.adata ->
  rg:range -> p:(;ki,ad,rg) AEADPlain.plain ->
  ((;ki) AEADKey * c:cipher){Encode.CipherRange(ki,rg,Length(c)) /\
                             ((* Safe(ki) => *) CTXT(ki,ad,p,c))}

val decrypt': ki:succEpoch -> (;ki) AEADKey -> ad:(;ki)AEADPlain.adata ->
  c:cipher -> res: 
  ( ((;ki) AEADKey *  rg:range * (;ki,ad,rg) AEADPlain.plain)) Result
   {!k,r,p. res = Correct((k,r,p)) => Encode.CipherRange(ki,r,Length(c))}

//CF unclear whether the log should include the plaintext; trying without
type entry = ki:succEpoch * ad:(;ki) AEADPlain.adata * c:ENC.cipher { ?p. CTXT(ki,ad,p,c) }
private val log: entry list ref
private val cmem: ki:succEpoch -> ad:(;ki)AEADPlain.adata -> c:cipher ->  
  entry list -> r:bool { r = true => ?p. CTXT(ki,ad,p,c) } 

private val honest: ki:succEpoch -> b:bool { b = true => Auth(ki) }

//CF a corollary of affine encryptions:
assume !ki,d,p0,p1,c. (CTXT(ki,d,p0,c) /\ CTXT(ki,d,p1,c)) => p0 = p1

val decrypt : ki:succEpoch -> (;ki) AEADKey -> ad:(;ki)AEADPlain.adata ->
  c:cipher -> res: 
  ( ((;ki) AEADKey *  rg:range * (;ki,ad,rg) AEADPlain.plain)) Result
   {(!k,r,p. res = Correct((k,r,p)) => Encode.CipherRange(ki,r,Length(c))) /\
    (Auth(ki) => 
        ((!k,r,p. res = Correct((k,r,p)) => CTXT(ki,ad,p,c)) /\
         (!p. CTXT(ki,ad,p,c) => (?k,r. res = Correct((k,r,p))))))}
// The last two lines are equivalent to (but easier to verify than)
// !p. CTXT(ki,ad,p,c) <=> (?k,r. res = Correct((k,r,p)))

(* CF 04-09 discussion points: 
//
// plaintext integrity follows from abstraction:
// - a precondition for coercing to  (;ki,rg,ad) plain is that ki is un-Auth
// - a precondition for leaking from (;ki,rg,ad) plain is that ki is un-Safe
//
// additionally, the decryption refinement guarantees 
// functional correctness & ciphertext integrity
// 
// CTXT(ki,ad,p,c) is a runtime event recorded by encrypt, stating
// "c is a correct encryption for ki, ad, some rg, and p 
//
// the range for encryption is not recorded in CTXT,
// (as indeed only the secret length is authenticated, not the range).
//
// our interface is compatible with state for the underlying encryption
// (but does not rely on it); this is convenient for RC4, for IVs in old TLS
//
// how do we deal with corrupted peers? 
// why do we have two cases? I propose instead:
//
// Auth(ki) => 
// ( !p. res = Correct(CipherRange(ki,c),p) <=> CTXT(ki,ad,p,c) )
//
// We are still in-between encryptor/decryptor and keys, why? 
// Are TLS 1.0 IVs now part of the mutable key? 
// Note that CipherRange depends on the TLS version too.
*)
