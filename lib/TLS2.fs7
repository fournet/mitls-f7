module TLS

open Error
open Bytes
open AppConfig
open DataStream
open AppDataStream
open Dispatch
open TLSInfo

type index  = ConnectionInfo
type cn   = Dispatch.Connection
type params = protocolOptions

val null: i:index{NullKeyInfo(i.id_in) /\ NullKeyInfo(i.id_out)}

function val Role: cn -> Direction
assume !c. Role(c) = ConnectionOutKeyInfo(c).dir

type (;c:cn) sameCn = c':cn{Role(c) = Role(c') /\ CnId(c) = CnId(c')}

function val Dual: ConnectionInfo -> ConnectionInfo
assume !ki. Dual(ki) = { id_in = ki.id_out; id_out = ki.id_in }

predicate val TXT: index -> bool
predicate val SEC: index -> bool
predicate val Fatal: (index * bytes) -> bool
predicate val Close: (index * bytes) -> bool
predicate val Write: (index * bytes) -> bool
predicate val Read : (index * bytes) -> bool

function val  ConnInStream: c:cn -> (; ConnectionInKeyInfo(c)) stream
function val ConnOutStream: c:cn -> (;ConnectionOutKeyInfo(c)) stream

assume !id, s.  ConnInStream(Conn(id, s)) =  InStream(id, s.appdata)
assume !id, s. ConnOutStream(Conn(id, s)) = OutStream(id, s.appdata)

function val WrittenBytes: cn -> bytes
function val    ReadBytes: cn -> bytes

assume !c. WrittenBytes(c) =  ConnInStream(c)
assume !c.    ReadBytes(c) = ConnOutStream(c)

type (;c:cn, r:range)  indelta = (; ConnectionInKeyInfo(c),  ConnInStream(c), r) delta
type (;c:cn, r:range) outdelta = (;ConnectionOutKeyInfo(c), ConnOutStream(c), r) delta
type (;c:cn) query

predicate val OutSplit : // FIXME: ugly
    (rg0:range              * newrg:range                   * rg:range *
     c  :cn               * newc :cn                    *
     d0 :(;c, rg0) outdelta * newd :(;newc, newrg) outdelta * d :(;c, rg) delta)
    -> bool

predicate val WriteExtend : (c:cn * c':cn * rg:range * (;c, rg) outdelta) -> bool
predicate val  ReadExtend : (c:cn * c':cn * rg:range * (;c, rg)  indelta) -> bool
predicate val    NoExtend : (c:cn * c':cn) -> bool

definition !c, c', rg, d. WriteExtend(c, c', rg, d) <=>
       WrittenBytes(c') = WrittenBytes(c) @| d
    /\    ReadBytes(c') =    ReadBytes(c)
    /\       Params(c') =       Params(c)

definition !c, c', rg, d. ReadExtend(c, c', rg, d) <=>
          ReadBytes(c') =    ReadBytes(c) @| d
    /\ WrittenBytes(c') = WrittenBytes(c)
    /\       Params(c') =       Params(c)

definition !c, c'. NoExtend(c, c') <=>
          ReadBytes(c) =    ReadBytes(c')
    /\ WrittenBytes(c) = WrittenBytes(c')
    /\       Params(c) =       Params(c')

type (;c:cn) ioresult_i =
| ReadError of ErrorKind * ErrorCause
| Warning   of c':(;c) sameCn NoExtend(c, c') * a:alertDescription 
  {TXT(CnId(c)) => Warning(Dual(CnId(c)), a, ReadBytes(c))}
| Fatal of a:alertDescription 
  {TXT(CnId(c)) =>   Fatal(Dual(CnId(c)), a, ReadBytes(c))}
| Close of unit {TXT(CnId(c)) => Close(Dual(CnId(c)), ReadBytes(c))}
| CertQuery of c':(;c) sameCn {NoExtend(c, c')} * (;c') query
| Handshake of c':cn { Role(c) = Role(c') /\ WrittenBytes(c') = [||] /\ ReadBytes(c') = [||]}
| Read      of c':(;c) sameCn * rg:range * d:(;c, rg) indelta
  {    CnId(c) <> null /\ ReadExtend(c, c', rg, d)
    /\ TXT(CnId(c)) => Write(Dual(CnId(c)), ReadBytes(c')) }

val read : c:cn -> (;c) ioresult_i

type (;c:cn, rg:range, d:(;c, rg) outdelta) ioresult_o =
| WriteError    of ErrorKind * ErrorCause
| WriteComplete of c':(;c) sameCn { WriteExtend(c, c', rg, d) }
| WritePartial  of c':(;c) sameCn * rg':range * d':(;c', rg') outdelta
  { ?d0, rg0. WriteExtend(c, c', rg0, d0) /\ OutSplit(rg0, rg', rg, c, c', d0, d', d) }
| MustRead      of c':(;c) cn 
  { c':cn{Role(c) = Role(c') /\ ConnectionOutKeyInfo(c) = ConnectionOutKeyInfo(c') /\
    ReadBytes(c) = ReadBytes(c') /\ Params(c) = Params(c') }

// TODO: 
// document that MustRead means that we won't be able to write on that connection anymore
// in SameConnection, enforce the chaining for all HS-specific data, in particular to chain successive handshakes.
// fix ConnectionOutKeyInfo above (?) ideally removing it 
// fix alertDescription, so that it only represents the second byte. 
// check that we are not too restrictive for the ongoing connection once we start negotiating.
// regroup the bits of the TLS library that are needed in the API.
// write the "toplevel" automata, from the user viewpoint; consider enforcement by typing, session-style.
// consider hiding ranges within deltas: (';c) delta' = (rg:range * (;c', rg') outdelta), especially if they are explained elsewhere.

val write: c:cn -> rg:range -> d:(;c, rg) delta -> (;c, rg, d) ioresult_o
// On the write side, the following events may be generated:
// - Write(ki,WrittenBytes(c')) 
// - Close(ki,WrittenBytes(c))

type (;r:role,p:parameters) nullCn = c:cn { CnId(c) = null /\ Params(c) = p /\ Role(c) = r }
val connect: Tcp.NetworkStream -> p:params                  -> (;Client,p) nullCn Result
val resume:  Tcp.NetworkStream -> p:params -> sid:sessionID -> (;Client,p) nullCn Result 
val accept:  Tcp.NetworkStream -> p:params                  -> (;Server,p) nullCn Result

// even if the server declines, we authenticate the client's intent to resume from the sid.

val rekey:       c:cn {Role(c)=Client} -> (c':(;c) sameCn {NoExtend(c, c')}) Result
val rehandshake: c:cn {Role(c)=Client} -> (c':(;c) sameCn {NoExtend(c, c')}) Result
val request:     c:cn {Role(c)=Server} -> (c':(;c) sameCn {NoExtend(c, c')}) Result
val shutdown:    c:cn                  -> (c':(;c) sameCn {NoExtend(c, c')}) Result
// [shutdown] will internally generate a Close(ki, WrittenBytes(c)) 
// Cannot write afterwards (dynamically enforced)

// we echo the query so that we have an explicit user decision to blame.
val authorize: c:cn -> (;c) query -> (c': (;c) sameCn { NoExtend(c, c') }) Result
val refuse:    c:cn -> (;c) query -> unit
