module TLS

open Error
open Bytes
open AppConfig
open DataStream
open AppDataStream
open Dispatch
open TLSInfo 
// for ConnectionInfo, Client, Server, ... 

//TODO: change Direction to role 
//KB: I disagree. Directions are the right abstraction for KeyInfo. 
//    If need be, it would be better to define a role in ConnectionInfo.

type role = Direction

type index = ConnectionInfo
type params = protocolOptions
type cn //= Dispatch.Connection

function val Role: cn -> Direction
assume !c. Role(c) = ConnectionOutKeyInfo(c).dir

// Peer(i) ghostly refers to the remote peer's index 
function val Peer: index -> index 
assume !ki. Peer(ki) = { id_in = ki.id_out; id_out = ki.id_in }

// main security predicates and events; may be defined elsewhere
predicate val TXT: index -> bool
predicate val SEC: index -> bool
predicate val Fatal:   (index * bytes) -> bool
predicate val Warning: (index * bytes) -> bool
predicate val Close:   (index * bytes) -> bool
predicate val Write:   (index * bytes) -> bool
predicate val Read :   (index * bytes) -> bool //AP: Unused. Everything is defined as a correspondence on Write

function val CnId: c:cn -> index
function val CnStream_i: c:cn -> (;ConnectionInKeyInfo(c)) stream
function val CnStream_o: c:cn -> (;ConnectionOutKeyInfo(c)) stream
assume !id, s. CnId(Conn(id, s)) = id
assume !id, s. CnStream_i(Conn(id, s)) =  InStream(id, s.appdata)
assume !id, s. CnStream_o(Conn(id, s)) = OutStream(id, s.appdata)
//CF redundant?
function val Bytes_o: cn -> bytes
function val Bytes_i: cn -> bytes
assume !c. Bytes_o(c) = CnStream_i(c)
assume !c. Bytes_i(c) = CnStream_o(c)

// These types hide the precise of a range in messages
type (;c:cn) msg_i = r:range * (;ConnectionInKeyInfo(c),  CnStream_i(c), r) delta
type (;c:cn) msg_o = r:range * (;ConnectionOutKeyInfo(c), CnStream_o(c), r) delta

predicate val Split_o: (cn * msg_o * msg_o * cn * msg_o)  -> bool

// Abbreviations for specifying connection invariants 
predicate val Extend:   (c:cn * c':cn) -> bool
predicate val Extend_o: (c:cn * c':cn * (;c) msg_o) -> bool
predicate val Extend_i: (c:cn * c':cn * (;c) msg_i) -> bool

type (;c:cn) nextCn = c':cn {  Role(c')    = Role(c) 
                            /\ CnId(c')    = CnId(c)
                            /\ Params(c')  = Params(c) }
definition !c, c'. 
  Extend(c, c') <=>            Bytes_i(c') = Bytes_i(c)
                            /\ Bytes_o(c') = Bytes_o(c)
definition !c, c', msg. 
  Extend_o(c, c', msg) <=>   Bytes_i(c') = Bytes_i(c)
                            /\ Bytes_o(c') = Bytes_o(c) @| msg
definition !c, c', msg. 
  Extend_i(c, c', msg) <=>   Bytes_i(c') = Bytes_i(c) @| msg
                            /\ Bytes_o(c') = Bytes_o(c)

//TODO: in SameConnection, enforce the chaining for all HS-specific data, in particular to chain successive handshakes.
//TODO: fix alertDescription, so that it only represents the second byte. 
//TODO: check that we are not too restrictive for the ongoing connection once we start negotiating.
//TODO: regroup the bits of the TLS library that are needed in the API.
//TODO: write the "toplevel" automata, from the user viewpoint; consider enforcement by typing, session-style.

// authorization query; TBD with principals
type (;c:cn) query

type (;c:cn) ioresult_i =
| ReadError of ErrorKind * ErrorCause //AP: Here we could generate the Fatal event. But who generates the Warning event?
| Close     of Tcp.NetworkStream  {TXT(CnId(c)) => Close(Peer(CnId(c)), Bytes_i(c))}
| Fatal     of a:alertDescription {TXT(CnId(c)) => Fatal(Peer(CnId(c)), a, Bytes_i(c))}
| Warning   of c':(;c) nextCn * a:alertDescription 
  {Extend(c,c') /\ TXT(CnId(c)) => Warning(Peer(CnId(c)), a, Bytes_i(c))}
| CertQuery of c':(;c) nextCn * (;c') query {Extend(c, c')} 
| Handshake of c':cn {Role(c') = Role(c) /\ Bytes_o(c') = [||] /\ Bytes_i(c') = [||]}
	//AP: /\ Close(CnId(c),Bytes_o(c)) /\ Close(Peer(CnId(c)),Bytes_i(c)) -- and same for Alert protocol, and hanshake.
	// We need to show agreement on the content of all protocols in previous and current connectio to express the Alert attack (and therefore authentication)
| Read      of c':(;c) nextCn * d:(;c) msg_i
  {Extend_i(c,c',d) /\ TXT(CnId(c)) => Write(Peer(CnId(c)), Bytes_i(c')) } // AP: Sure? both c and c' in Write predicate? KB: Looks good to me

val read : c:cn -> (;c) ioresult_i

type (;c:cn,d:(;c) msg_o) ioresult_o =
| WriteError    of ErrorKind * ErrorCause
| WriteComplete of c':(;c) nextCn {Extend_o(c,c',d)}
	//AP: /\ Write(CnId(c'),Bytes_o(c')) -- we need to generate the Write event somewhere, and this (and WritePartial) looks like a good place.
| WritePartial  of c':(;c) nextCn * d':(;c') msg_o 
  { ?d0. Extend_o(c,c',d0) /\ Split_o(c, d, d0, c', d') }
| MustRead      of c':(;c) cn 
    {   Role(c')                = Role(c) 
     /\ Params(c')              = Params(c)
	 /\ ConnectionInKeyInfo(c') = ConnectionInKeyInfo(c) 
     /\ Bytes_i(c')             = Bytes_i(c) }

val write: c:cn -> rg:range -> d:(;c) msg_o -> (;c,d) ioresult_o
// On the write side, the following events may be generated:
// - Write(ki,Bytes_o(c')) 
// - Close(ki,Bytes_o(c))
// WriteError reports a local error
// WriteComplete reports write completion
// WritePartial reports partial write completion, and returns the rest
// MustRead signals that the connection cannot be used anymore for writing until a new handshake completes. 
// (it may be a bit too restrictive) 

// special NULL_NULL initial connection index
// cannot be used for data writing (by typing)
val null: i:index{NullKeyInfo(i.id_in) /\ NullKeyInfo(i.id_out)}
type (;r:role,p:params) nullCn = c:cn {CnId(c) = null /\ Params(c) = p /\ Role(c) = r}

val connect: Tcp.NetworkStream -> p:params                  -> (;Client,p) nullCn Result
val resume:  Tcp.NetworkStream -> p:params -> sid:sessionID -> (;Client,p) nullCn Result 
// even if the server declines, we authenticate the client's intent to resume from the sid.
val accept:  Tcp.NetworkStream -> p:params                  -> (;Server,p) nullCn Result
val shutdown: c:cn -> Tcp.NetworkStream Result
//was: (c':(;c) nextCn {Extend(c,c')}) Result
// [shutdown] will internally generate a Close(ki, Bytes_o(c)); releases the TCP socket after shutdown

val rekey:       c:cn {Role(c)=Client} -> (c':(;c) nextCn {Extend(c,c')}) Result
val rehandshake: c:cn {Role(c)=Client} -> (c':(;c) nextCn {Extend(c,c')}) Result
val request:     c:cn {Role(c)=Server} -> (c':(;c) nextCn {Extend(c,c')}) Result

// we echo the query so that we have an explicit user decision to blame.
val authorize: c:cn -> (;c) query -> (c': (;c) nextCn {Extend(c,c')}) Result
val refuse:    c:cn -> (;c) query -> unit