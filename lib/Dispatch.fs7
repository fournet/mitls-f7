module Dispatch

open Bytes
open Error
open Range
open TLSInfo
open TLSConstants

private type predispatchState =
  | Init 
  | FirstHandshake of ProtocolVersion             (* set by the ServerHello *) 
  | Finishing
  | Finished (* Only for Writing side, used to avoid sending data on a partially completed handshake *)
  | Open
  | Closing of ProtocolVersion * string (* To handle un-graceful closures *)
  | Closed

private type (;e:epoch)dispatchState = d:predispatchState{?pv,s.
	(d = Init \/ d = FirstHandshake(pv) \/ d = Finishing \/ d = Finished \/
	d = Open \/ d = Closing(pv,s) \/ d = Closed) /\
	((d = Finishing \/ d = Finished \/ d = Open) => IsSuccEpoch(e))}

private type (;e:epoch,rw:StatefulLHAE.rw) dState = {
    disp: (;e)dispatchState;
    conn: (;e,rw)Record.ConnectionState;
    }

private type (;id:ConnectionInfo) preGlobalState = {
  (* abstract protocol states for HS/CCS, AL, and AD *)
  handshake: (;id) Handshake.hs_state;
  alert    : (;id) Alert.state;
  appdata  : (;id) AppData.app_state;    

  (* connection state for reading and writing *)
  read  : (;id.id_in, StatefulLHAE.ReaderState) dState;
  write : (;id.id_out,StatefulLHAE.WriterState) dState;
  (* The actual socket *)
  ns: Tcp.NetworkStream;
  }


predicate GState of ci:ConnectionInfo * (;ci)preGlobalState
private type (;id:ConnectionInfo) globalState = gs:(;id) preGlobalState{GState(id,gs)}

private definition !ci,gs. GState(ci,gs)  <=>
  ( (Auth(ci.id_out) =>
		(
		AppData.AppOutStream(ci,gs.appdata) = TLSFragment.AppDataHistory(ci.id_out,Record.History(ci.id_out,StatefulLHAE.WriterState,gs.write.conn)) /\
		Handshake.HSOutStream(ci,gs.handshake) = TLSFragment.HandshakeHistory(ci.id_out,Record.History(ci.id_out,StatefulLHAE.WriterState,gs.write.conn)) /\
		Handshake.CCSOutStream(ci,gs.handshake) = TLSFragment.CCSHistory(ci.id_out,Record.History(ci.id_out,StatefulLHAE.WriterState,gs.write.conn)) /\
		Alert.AlOutStream(ci,gs.alert) = TLSFragment.AlertHistory(ci.id_out,Record.History(ci.id_out,StatefulLHAE.WriterState,gs.write.conn))
		)
	) /\
    (Auth(ci.id_in)  =>
		(
		AppData.AppInStream(ci,gs.appdata)  = TLSFragment.AppDataHistory(ci.id_in,Record.History(ci.id_in,StatefulLHAE.ReaderState,gs.read.conn)) /\
		Handshake.HSInStream(ci,gs.handshake) = TLSFragment.HandshakeHistory(ci.id_in,Record.History(ci.id_in,StatefulLHAE.ReaderState,gs.read.conn)) /\
		Handshake.CCSInStream(ci,gs.handshake) = TLSFragment.CCSHistory(ci.id_in,Record.History(ci.id_in,StatefulLHAE.ReaderState,gs.read.conn)) /\
		Alert.AlInStream(ci,gs.alert) = TLSFragment.AlertHistory(ci.id_in,Record.History(ci.id_in,StatefulLHAE.ReaderState,gs.read.conn))
		)
	)
  )
  

(*FIXME
	/\
	(( AppData.AppInBuf(ci,gs.appdata) = None /\
	    AppData.AppInStream( ci,gs.appdata) =
		TLSFragment.HistoryStream(ci.id_in, TLSConstants.Application_data,Record.History(ci.id_in, gs.read.conn))) \/
	  (?r,f. AppData.AppInBuf(ci,gs.appdata) = Some((r,f)) /\
	    Fragment.Extend(ci.id_in,AppData.AppInStream(ci,gs.appdata),r,f) = 
	    TLSFragment.HistoryStream(ci.id_in, TLSConstants.Application_data,Record.History(ci.id_in, gs.read.conn))
	  )
	))
 *)
private type Connection = Conn of (id:ConnectionInfo * (;id)globalState)

predicate CanWrite of ConnectionInfo
assume !ci,c. Handshake.Complete(ci,c) => CanWrite(ci)

function val ConnectionEpochOut: Connection -> epoch
private assume !id,s. ConnectionEpochOut(Conn(id,s)) = id.id_out
function val ConnectionEpochIn:  Connection -> epoch
private assume !id,s. ConnectionEpochIn(Conn(id,s))  = id.id_in


function val ConnectionSIOut: Connection -> SessionInfo
private assume !id,s. ConnectionSIOut(Conn(id,s)) = EpochSI(id.id_out)
function val ConnectionSIIn: Connection -> SessionInfo
private assume !id,s. ConnectionSIIn(Conn(id,s)) = EpochSI(id.id_in)

function val ConnectionInHistory: c:Connection -> (;ConnectionEpochIn(c))TLSFragment.history
private assume !id,s. ConnectionInHistory(Conn(id,s)) = Record.History(id.id_in,StatefulLHAE.ReaderState,s.read.conn)
function val ConnectionOutHistory: c:Connection -> (;ConnectionEpochOut(c))TLSFragment.history
private assume !id,s. ConnectionOutHistory(Conn(id,s)) = Record.History(id.id_out,StatefulLHAE.WriterState,s.write.conn)

// Returns the local index, which includes our fresh initial randomness
function val CnInfo: Connection -> ConnectionInfo
private assume !id, s. CnInfo(Conn(id, s)) = id

function val CnStream_i: c:Connection -> (;ConnectionEpochIn (c)) DataStream.stream
function val CnStream_o: c:Connection -> (;ConnectionEpochOut(c)) DataStream.stream
private assume !id, s. CnStream_i(Conn(id, s)) =  AppData.AppInStream(id, s.appdata)
private assume !id, s. CnStream_o(Conn(id, s)) = AppData.AppOutStream(id, s.appdata)

type (;e:epoch,s:(;e)DataStream.stream)msg_i = r:range * (;e,s,r)DataStream.delta
type (;e:epoch,s:(;e)DataStream.stream)msg_o = r:range * (;e,s,r)DataStream.delta

function val CnBuf_o: c:Connection -> ((;ConnectionEpochOut(c),CnStream_o(c))msg_o) option
private assume !id,s. CnBuf_o(Conn(id,s)) = AppData.AppOutBuf(id,s.appdata)

function val Bytes_o: Connection -> bytes
function val Bytes_i: Connection -> bytes
function val StreamToBytes: ki:epoch * (;ki) DataStream.stream -> bytes
private assume !c. Bytes_o(c) = StreamToBytes(ConnectionEpochIn (c), CnStream_i(c))
private assume !c. Bytes_i(c) = StreamToBytes(ConnectionEpochOut(c), CnStream_o(c))

predicate EvWrite      of epoch * bytes
predicate EvWarning    of epoch * alertDescription * bytes
predicate EvClose      of epoch * bytes
predicate EvFatal      of epoch * alertDescription * bytes
// Write records increasing prefixes of the stream, for each written data fragment, 
// interleaved with warnings, ended by Fatal or Close [we may distinguish between two kinds of close too]
// Write(i,p0), ..., Write(i,p0 @| ... @| pi), Warning(i,p0 @| ... @| pi), ..., Close(i, p0 @| ... @| pn)

function val Role: Connection -> Role
private assume !c. Role(c) = CnInfo(c).role
function val Rnd: Connection -> random
private assume !c. Rnd(c) = CnInfo(c).id_rand

predicate Extend   of c:Connection * c':Connection
predicate Extend_o of c:Connection * c':Connection * (;ConnectionEpochOut(c),CnStream_o(c)) msg_o
predicate Extend_i of c:Connection * c':Connection * (;ConnectionEpochIn (c),CnStream_i(c)) msg_i

function val MsgOBytes: c:Connection * (;ConnectionEpochOut(c),CnStream_o(c)) msg_o -> bytes
function val MsgIBytes: c:Connection * (;ConnectionEpochIn (c),CnStream_i(c)) msg_i -> bytes

predicate Split_o of
	  c:Connection
	* (;ConnectionEpochOut(c),CnStream_o(c))msg_o
	* (;ConnectionEpochOut(c),CnStream_o(c))msg_o
	* c':Connection
	* (;ConnectionEpochOut(c'),CnStream_o(c'))msg_o


private definition !c, c'. 
	Extend(c, c') <=>    Bytes_i(c') = Bytes_i(c)
                      /\ Bytes_o(c') = Bytes_o(c)

private definition !c, c', msg.
	Extend_o(c, c', msg) <=>     Bytes_i(c') = Bytes_i(c)
                              /\ Bytes_o(c') = Bytes_o(c) @| MsgOBytes(c, msg)

private definition !c, c', msg. 
	Extend_i(c, c', msg) <=>     Bytes_i(c') = Bytes_i(c) @| MsgIBytes(c, msg)
                              /\ Bytes_o(c') = Bytes_o(c)

val networkStream: Connection -> Tcp.NetworkStream

function val Config: Connection -> config
private assume !id,s. Config(Conn(id,s)) = Handshake.Config(id,s.handshake)

private type (;r:Role,c:config) nullCn = conn:Connection {
	   Config(conn) = c /\ Role(conn) = r
	/\ IsInitEpoch(ConnectionEpochOut(conn))
	/\ IsInitEpoch(ConnectionEpochIn (conn))
}


predicate NextCn of Connection * Connection
private assume !c,c'. NextCn(c,c') <=> ( Config(c')  = Config(c) /\ CnInfo(c') = CnInfo(c) )
type (;c:Connection) nextCn = c':Connection {NextCn(c,c')}
type query = Cert.chain

type writeOutcome =
    | WError of string 
    | WriteAgain (* Possibly more data to send *)
    | WAppDataDone (* No more data to send in the current state *)
    | WHSDone
    | WMustRead (* Read until completion of Handshake *)
    | SentFatal of alertDescription * string
    | SentClose

type readOutcome =
    | WriteOutcome of writeOutcome
    | RError of string 
    | RAgain
    | RAppDataDone 
    | RQuery of query * bool
    | RHSDone
    | RClose
    | RFatal of alertDescription
    | RWarning of alertDescription

predicate val IOResult_i : Connection * Connection * readOutcome * 'a -> bool
predicate val IOResult_o : Connection * 'a * Connection * writeOutcome * 'b -> bool

assume !c,m,c',wo,mo. IOResult_o(c,m,c',wo,mo)  <=>
	(
		// Cases needed by the top level interface
	(wo = WAppDataDone /\ mo = None /\ Extend_o(c,c',m) /\ NextCn(c,c'))

	\/
        (wo = WAppDataDone /\ (?m0,m'. mo = Some(m') /\ Split_o(c,m,m0,c',m') /\ Extend_o(c,c',m0) /\ NextCn(c,c'))) \/
        (wo = WHSDone /\
		  (
			   Role(c') = Role(c)
			/\ Rnd(c') = Rnd(c)
			/\ Config(c') = Config(c)
			/\ ConnectionEpochIn(c) = Pred(ConnectionEpochIn(c'))
			/\ Bytes_i(c') = [||]
			/\ EvClose(CnInfo(c).id_in, Bytes_i(c))
			/\ Handshake.Complete(CnInfo(c'),Config(c'))
			/\ (
				( Handshake.EvSentFinishedFirst(CnInfo(c'),true)
				  /\ Bytes_o(c') = Bytes_o(c)
				  /\ ConnectionEpochOut(c') = ConnectionEpochOut(c)
			    )
				\/
				(  Handshake.EvSentFinishedFirst(CnInfo(c'),false)
				   /\ Bytes_o(c') = [||]
				   /\ ConnectionEpochOut(c) = Pred(ConnectionEpochOut(c'))
				)
			   )
		   )
		 ) \/
		 (wo = WMustRead /\
		   (
			  	Role(c') = Role(c) 
			 /\ Rnd(c') = Rnd(c)
			 /\ Config(c') = Config(c)
			 /\ ConnectionEpochIn(c') = ConnectionEpochIn(c)
			 /\ Bytes_i(c') = Bytes_i(c)
			 /\ Bytes_o(c') = [||]
			 /\ ConnectionEpochOut(c) = Pred(ConnectionEpochOut(c'))                                                                                                                                                         
		   )
		 ) \/
		 // Cases needed by dispatch; in practice not giving any refinement,
		 // just completing all the cases.
		 (?err. wo = WError(err) ) \/
		 (wo = WriteAgain ) \/
		 (?ad,s. wo = SentFatal(ad,s) ) \/
		 (wo = SentClose ) 
	)

assume !c,c',ro,mo. IOResult_i(c,c',ro,mo) =>
   (
    // Cases needed by the top level interface
	(ro = RClose /\ (Auth(ConnectionEpochIn(c)) => EvClose(CnInfo(c).id_in,Bytes_i(c)))) \/
	(?ad. ro = RFatal(ad) /\ (Auth(ConnectionEpochIn(c)) => EvFatal(CnInfo(c).id_in,ad,Bytes_i(c)))) \/
	(?ad. ro = RWarning(ad) /\ Extend(c,c') /\ (Auth(ConnectionEpochIn(c)) => EvWarning(CnInfo(c).id_in,ad,Bytes_i(c))) /\ NextCn(c,c')) \/
	(?q,adv. ro = RQuery(q,adv) /\ Extend(c,c') /\ NextCn(c,c')) \/
	(ro = RHSDone /\ 
	  (
		   Role(c') = Role(c)
		/\ Rnd(c') = Rnd(c)
		/\ Config(c') = Config(c)
		/\ ConnectionEpochIn(c) = Pred(ConnectionEpochIn(c'))
		/\ Bytes_i(c') = [||]
		/\ EvClose(CnInfo(c).id_in, Bytes_i(c))

		/\ Handshake.Complete(CnInfo(c'),Config(c'))

		/\ (
			(Handshake.EvSentFinishedFirst(CnInfo(c'),true) /\
				  Bytes_o(c') = Bytes_o(c)
			   /\ ConnectionEpochOut(c') = ConnectionEpochOut(c)
			)
			\/
			(Handshake.EvSentFinishedFirst(CnInfo(c'),false) /\
				  Bytes_o(c') = [||]
			   /\ ConnectionEpochOut(c) = Pred(ConnectionEpochOut(c'))
			)
		   )
	  )
	) \/
	(?m. ro = RAppDataDone /\ mo = Some(m) /\
		Extend_i(c,c',m) /\ NextCn(c,c') /\ (Auth(ConnectionEpochIn(c)) => EvWrite(CnInfo(c).id_in, Bytes_i(c')))) \/
	(ro = WriteOutcome(WMustRead) /\ 
		   (
			  	Role(c') = Role(c) 
			 /\ Rnd(c') = Rnd(c)
			 /\ Config(c') = Config(c)
			 /\ ConnectionEpochIn(c') = ConnectionEpochIn(c)
			 /\ Bytes_i(c') = Bytes_i(c)
			 /\ Bytes_o(c') = [||]
			 /\ ConnectionEpochOut(c) = Pred(ConnectionEpochOut(c'))                                                                                                     
		   )
	) \/
	(ro = WriteOutcome(WHSDone) /\
		  (
			   Role(c') = Role(c)
			/\ Rnd(c') = Rnd(c)
			/\ Config(c') = Config(c)
			/\ ConnectionEpochIn(c) = Pred(ConnectionEpochIn(c'))
			/\ Bytes_i(c') = [||]
			/\ EvClose(CnInfo(c).id_in, Bytes_i(c))

			/\ Handshake.Complete(CnInfo(c'),Config(c'))

			/\ (
				(Handshake.EvSentFinishedFirst(CnInfo(c'),true) /\
					  Bytes_o(c') = Bytes_o(c)
				   /\ ConnectionEpochOut(c') = ConnectionEpochOut(c)
				)
				\/
				(Handshake.EvSentFinishedFirst(CnInfo(c'),false) /\
					  Bytes_o(c') = [||]
				   /\ ConnectionEpochOut(c) = Pred(ConnectionEpochOut(c'))
				)
			   )
		  )
	) \/
	(?ad,s. ro = WriteOutcome(SentFatal(ad,s)) ) \/
	(ro = WriteOutcome(SentClose) /\ (Auth(ConnectionEpochIn(c)) => EvClose(CnInfo(c).id_in,Bytes_i(c)))
	) \/
	// Cases needed by dispatch; in practice not giving any refinement,
	// just completing all the cases.
	(?err. ro = RError(err)) \/
	(ro = RAgain )
   )


val init: Tcp.NetworkStream -> r:Role -> c:config -> (;r,c)nullCn

val resume: Tcp.NetworkStream -> sessionID -> c:config -> (;Client,c)nullCn

val rehandshake: c:Connection -> conf:config ->
	(b:bool * c':Connection) {
		   Extend(c,c')
		/\ CnInfo(c') = CnInfo(c)
		/\ (   (b = false /\ Config(c') = Config(c))
			\/ (b = true  /\ Config(c') = conf    ))
	}
val rekey:       c:Connection -> conf:config ->
	(b:bool * c':Connection) {
		   Extend(c,c')
		/\ CnInfo(c') = CnInfo(c)
		/\ (   (b = false /\ Config(c') = Config(c))
			\/ (b = true  /\ Config(c') = conf    ))
	}
val request:     c:Connection -> conf:config ->
	(b:bool * c':Connection) {
		   Extend(c,c')
		/\ CnInfo(c') = CnInfo(c)
		/\ (   (b = false /\ Config(c') = Config(c))
			\/ (b = true  /\ Config(c') = conf    ))
	}

val full_shutdown:    c:Connection ->
	c':Connection{ Config(c') = Config(c) /\ Role(c') = Role(c) /\
	    Rnd(c') = Rnd(c) /\
		ConnectionEpochIn(c') = ConnectionEpochIn(c) /\ Extend(c,c')
		// Note: we cannot write anymore
		}
val half_shutdown: c:Connection -> unit

private val moveToOpenState: c:Connection ->
	(;CnInfo(c))globalState Result

private val closeConnection: c:Connection-> (;c) nextCn

private val abortWithAlert: c:Connection -> alertDescription -> string -> (;c)nextCn

private val getReason: predispatchState -> string
private val pickSendPV: c:Connection -> TLSConstants.ProtocolVersion

private val send: Tcp.NetworkStream -> e:epoch -> w:(;e,StatefulLHAE.WriterState)dState ->
	TLSConstants.ProtocolVersion -> rg:range -> ct:TLSConstants.ContentType ->
	f:(;e,ct,Record.History(e,StatefulLHAE.WriterState,w.conn),rg)TLSFragment.plain ->
	res: (;e,StatefulLHAE.WriterState) dState Result{
          !w'. (res = Correct(w') /\ Auth(e)) =>
            (Record.History(e,StatefulLHAE.WriterState,w'.conn) = TLSFragment.ExtendHistory(e,ct,Record.History(e,StatefulLHAE.WriterState,w.conn),rg,f))}
                                                                                                                                                                
private val recv: c:Connection ->
	((;ConnectionEpochIn(c),StatefulLHAE.ReaderState) Record.ConnectionState *
	 ct:TLSConstants.ContentType * r:range * 
         (;ConnectionEpochIn(c),ct,ConnectionInHistory(c),r)TLSFragment.plain) Result

private val readOne: c:Connection ->
	readOutcome * Connection

private val writeOne: c:Connection ->
	(wo:writeOutcome * c':Connection){!m. CnBuf_o(c) = Some(m) => IOResult_o(c,m,c',wo,CnBuf_o(c')) }
     
private val writeAll: c:Connection ->
	writeOutcome * Connection

private val handleHandshakeOutcome: c:Connection -> (;CnInfo(c),Config(c))Handshake.incoming ->
	readOutcome * Connection

val read: c:Connection -> 
    (c':Connection  * ro:readOutcome * mo:(;ConnectionEpochIn(c'),CnStream_i(c'))msg_i option)
    {
      IOResult_i(c,c',ro,mo)
    }

val write: c:Connection -> // CnOutBuf(c) = None
	m:(;ConnectionEpochOut(c),CnStream_o(c))msg_o ->
	(c':Connection* wo:writeOutcome * mo:(;ConnectionEpochOut(c'),CnStream_o(c'))msg_o option)
    {
      IOResult_o(c,m,c',wo,mo)
	  // /\ CnOutBuf(c') = None
    }

val authorize: c:Connection -> q:query -> 
	(c':Connection  * ro:readOutcome * mo:(;ConnectionEpochIn(c'),CnStream_i(c'))msg_i option)
    {
      IOResult_i(c,c',ro,mo)
    }
val refuse: Connection -> query -> unit

val getEpochIn:   c:Connection -> e:epoch{e=ConnectionEpochIn(c) }
val getEpochOut:  c:Connection -> e:epoch{e=ConnectionEpochOut(c)}
val getInStream:  c:Connection -> s:(;ConnectionEpochIn(c))DataStream.stream {s = CnStream_i(c)}
val getOutStream: c:Connection -> s:(;ConnectionEpochOut(c))DataStream.stream{s = CnStream_o(c)}
