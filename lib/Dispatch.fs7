module Dispatch

open Bytes
open Formats
open Tcp
open Error
open Record
open Handshake
open Alert
open AppData
open TLSInfo
open AppCommon
open TLSFragment
open SessionDB

type predispatchState =
  | Init (* of ProtocolVersion * ProtocolVersion *) (* min and max *)
  | FirstHandshake (* of ProtocolVersion *)             (* set by the ServerHello *) 
  | Finishing
  | Finished (* Only for Writing side, used to avoid sending data on a partially completed handshake *)
  | Open
  | Closing
  | Closed

type dispatchState = d:predispatchState{
	d = Init \/ d = FirstHandshake \/ d = Finishing \/ d = Finished \/
	d = Open \/ d = Closing \/ d = Closed}

type (;ki:KeyInfo) dState = {
    disp: dispatchState;
    conn: (;ki)Record.ConnectionState;
    }

type index =
    { id_in:  KeyInfo;
      id_out: KeyInfo}

type (;id:index) globalState = {
  poptions: protocolOptions;
  (* abstract protocol states for HS/CCS, AL, and AD *)
  handshake: (;id.id_out.sinfo) Handshake.hs_state;
  alert    : (;id.id_out.sinfo) Alert.state;
  appdata  : (;id.id_out.sinfo) AppData.app_state;    

  (* connection state for reading and writing *)
  read  : (;id.id_in)  dState;
  write : (;id.id_out) dState;

  (* The actual socket *)
  ns: NetworkStream;
  }

type Connection = (id:index * (;id)globalState)

function val idKIout: index -> KeyInfo
assume !id. idKIout(id)=id.id_out

function val idKIin: index -> KeyInfo
assume !id. idKIin(id)=id.id_in

function val idSIout: index -> SessionInfo
assume !id. idSIout(id)=id.id_out.sinfo

function val idSIin: Connection -> SessionInfo
assume !id. idSIin(id)=id.id_in.sinfo

type writeOutcome =
    | WriteAgain (* Possibly more data to send *)
    | Done (* No more data to send in the current state *)
    | MustRead (* Read until completion of Handshake *)

type deliverOutcome =
    | ReadAgain
    | AppDataDone
    | HSDone
    | Abort

val init: NetworkStream -> Direction -> protocolOptions -> Connection

val resume: NetworkStream -> sessionID -> protocolOptions -> unit Result * Connection

val ask_rehandshake: c:(id:index * (;id)globalState) -> protocolOptions -> (id':index * (;id')globalState){fst(c)=id'}
val ask_rekey:       c:(id:index * (;id)globalState) -> protocolOptions -> (id':index * (;id')globalState){fst(c)=id'}
val ask_hs_request:  c:(id:index * (;id)globalState) -> protocolOptions -> (id':index * (;id')globalState){fst(c)=id'}

val getSessionInfo: c:(id:index * (;id)globalState) -> si:SessionInfo{?id. id = fst(c) /\ si = id.id_out.sinfo}

val moveToOpenState: c:(id:index * (;id)globalState) ->
	(si:SessionInfo * (;si)PRFs.masterSecret * Direction){?id. id=fst(c) /\ si = id.id_out.sinfo} ->
	(;fst(c))globalState Result

val closeConnection: c:(id:index * (;id)globalState) -> (id':index * (;id')globalState){fst(c)=id'}

val send: ki:KeyInfo -> NetworkStream -> ss:(;ki)sendState -> tlen:int ->
	ct:ContentType -> f:(;ki,tlen,ct)TLSFragment.fragment ->
	ss':(;ki)sendState Result

val writeOne: c:(id:index * (;id)globalState) ->
	(writeOutcome Result) * ((id':index * (;id')globalState){fst(c)=id'})

val deliver: c:(id:index * (;id)globalState) -> ct:ContentType -> tlen:int ->
	(;idKIout(fst(c)),ct,tlen)TLSFragment.fragment ->
	(deliverOutcome Result) * ((id':index * (;id')globalState){fst(c)=id'})

val recv: c:(id:index * (;id)globalState) ->
	(((id':index * (;id')globalState){fst(c)=id'}) *
	  ct:ContentType * tlen:int * (;idKIin(fst(c)),tlen,ct)TLSFragment.fragment) Result

val readOne: c:(id:index * (;id)globalState) ->
	deliverOutcome Result * ((id':index * (;id')globalState){fst(c)=id'})

val writeFromRead: c:(id:index * (;id)globalState) ->
	unit Result * ((id':index * (;id')globalState){fst(c)=id'})

type preReadInvocation =
    | StopAtHS
    | StopAtAppData

type readInvocation = r:preReadInvocation{
	r = StopAtHS \/ r = StopAtAppData}

val read: c:(id:index * (;id)globalState) -> readInvocation ->
	unit Result * ((id':index * (;id')globalState){fst(c)=id'})

val writeAppData: c:(id:index * (;id)globalState) ->
	unit Result * ((id':index * (;id')globalState){fst(c)=id'})

val commit: c:(id:index * (;id)globalState) ->
	(;idSIout(fst(c)))AppDataPlain.lengths ->
	(;idSIout(fst(c)))AppDataPlain.appdata ->
	(id':index * (;id')globalState){fst(c)=id'}

val readAppData: c:(id:index * (;id)globalState) ->
	((;idSIin(fst(c)))AppDataPlain.appdata Result) *
	((id':index * (;id')globalState){fst(c)=id'})

val readHS: c:(id:index * (;id)globalState) ->
	unit Result * ((id':index * (;id')globalState){fst(c)=id'})
