module TLSFragment

open Bytes
open TLSInfo
open Formats

// Plain type for Dispatch
type (;ki:KeyInfo,tlen:int,ct:ContentType) fragment =
    | FHandshake of (;ki,tlen)Handshake.fragment    {ct=Formats.Handshake}
    | FCCS       of (;ki,tlen)Handshake.ccsFragment {ct=Change_cipher_spec}
    | FAlert     of (;ki,tlen)Alert.fragment        {ct=Alert}
    | FAppData   of (;ki,tlen)AppDataPlain.fragment {ct=Application_data}

val repr: ki:KeyInfo -> tlen:int -> ct:ContentType -> (;ki,tlen,ct)fragment -> bytes
val TLSfragment: ki:KeyInfo -> tlen:int -> ct:ContentType -> bytes -> (;ki,tlen,ct)fragment

// Plain type for AEAD
private type addData = bytes
predicate ADofID of (KeyInfo * int * ContentType * addData)

private type (;ki:KeyInfo,tlen:int,ad:addData) AEADFragment = {b:bytes}

function val fAEADRepr: (ki:KeyInfo * t:int * ad:addData * (;ki,t,ad) AEADFragment) -> bytes

val AEADFragment: ki:KeyInfo -> tlen:int -> ad:addData{?ct. ADofID(ki,tlen,ct,ad)} -> bytes -> (;ki,tlen,ad)AEADFragment
val AEADRepr: ki:KeyInfo -> tlen:int -> ad:addData{?ct. ADofID(ki,tlen,ct,ad)} -> f:(;ki,tlen,ad)AEADFragment -> b:bytes{b=fAEADRepr(ki,tlen,ad,f)}

val AEADToDispatch: ki:KeyInfo -> tlen:int -> ct:ContentType -> ad:addData{ADofID(ki,tlen,ct,ad)} -> (;ki,tlen,ad)AEADFragment -> (;ki,tlen,ct)fragment
val DispatchToAEAD: ki:KeyInfo -> tlen:int -> ct:ContentType -> ad:addData{ADofID(ki,tlen,ct,ad)} -> (;ki,tlen,ct)fragment -> (;ki,tlen,ad)AEADFragment
