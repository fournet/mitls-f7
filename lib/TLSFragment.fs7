module TLSFragment

open Bytes
open TLSInfo
open Formats
open CipherSuites
open DataStream

private type (;ki:epoch) prehistory = {
  handshake: (;ki) stream;
  alert: (;ki) stream; 
  ccs: (;ki) stream; 
  appdata: (;ki) stream
}
predicate TLSHistory of ki:epoch * (;ki) prehistory
type (;ki:epoch) history = p:(;ki) prehistory{TLSHistory(ki,p)}

function val Multiplexed: ki:epoch * (;ki) StatefulPlain.history -> 'b

predicate EmptyHistory of ki:epoch * (;ki)history
val emptyHistory: ki:epoch -> h:(;ki)history{EmptyHistory(ki,h)}

predicate TLSFragment of ki:epoch * ct:ContentType * h:(;ki) history * rg:range * d:(;ki,rg) Fragment.fragment
private assume !ki,ct,h,rg,d.
  TLSFragment(ki,ct,h,rg,d) <=> (
    (ct = Formats.Handshake /\ Fragment.Fragment(ki,h.handshake,rg,d)) \/
    (ct = Formats.Change_cipher_spec /\ Fragment.Fragment(ki,h.ccs,rg,d)) \/
    (ct = Formats.Alert /\ Fragment.Fragment(ki,h.alert,rg,d)) \/
    (ct = Formats.Application_data /\ Fragment.Fragment(ki,h.appdata,rg,d))
  )
 
type (;ki:epoch,ct:ContentType,h:(;ki) history,rg:range) fragment =
    | FHandshake of f:(;ki,rg)Fragment.fragment{ct=Formats.Handshake  /\ (Auth(ki) => TLSFragment(ki,ct,h,rg,f))}
    | FCCS       of f:(;ki,rg)Fragment.fragment{ct=Formats.Change_cipher_spec  /\ (Auth(ki) => TLSFragment(ki,ct,h,rg,f))}
    | FAlert     of f:(;ki,rg)Fragment.fragment{ct=Formats.Alert  /\ (Auth(ki) => TLSFragment(ki,ct,h,rg,f))}
    | FAppData   of f:(;ki,rg)Fragment.fragment{ct=Formats.Application_data  /\ (Auth(ki) => TLSFragment(ki,ct,h,rg,f))}

function val ExtendHistory: ki:epoch * ct:ContentType * ss:(;ki)history * r:range * (;ki,r)Fragment.fragment -> 'a 

function val ADBytes: (epoch * ContentType) -> bytes //(;ki)StatefulPlain.data
val addToHistory: ki:epoch -> ct:ContentType -> ss:(;ki)history -> r:range ->
	f:(;ki,r)Fragment.fragment{Auth(ki) => TLSFragment(ki,ct,ss,r,f)} ->  
        ss':(;ki)history{ss' = ExtendHistory(ki,ct,ss,r,f)}


val fragmentRepr: ki:epoch{not Safe(ki)} -> ct:ContentType -> h: (;ki) history -> rg:range ->
  (;ki,ct,h,rg)fragment -> bytes

val fragmentPlain: ki:epoch{not Auth(ki)} -> ct:ContentType -> h: (;ki) history -> rg:range ->
  (;rg)rbytes -> (;ki,ct,h,rg)fragment 


assume !ki,ct.
	( EpochSI(ki).protocol_version = SSL_3p0 /\
	  ADBytes(ki,ct) =
		CTBytes(ct) ) \/
	( EpochSI(ki).protocol_version <> SSL_3p0 /\
          ADBytes(ki,ct) =
		(CTBytes(ct) @| VersionBytes(EpochSI(ki).protocol_version)))

ask !ki,ct. Length(ADBytes(ki,ct)) = (AEPlain.ADLength(ki) - 8)

private val makeAD: ki:epoch -> ct:ContentType ->
	  ad: (;ki)StatefulPlain.data{ad=ADBytes(ki,ct)}

private assume !ki,h. EmptyHistory(ki,h) <=>
	( EmptyStream(ki,h.handshake) /\ EmptyStream(ki,h.alert) /\
	  EmptyStream(ki,h.ccs)       /\ EmptyStream(ki,h.appdata) )
private assume !ki,h,h'. EmptyHistory(ki,h) /\ EmptyHistory(ki,h') => h = h'

private assume !ki,h,r,d. ExtendHistory(ki,Formats.Handshake,h,r,d) =
	 { handshake = Fragment.Extend(ki,h.handshake,r,d);
	   alert = h.alert;
	   ccs = h.ccs;
	   appdata = h.appdata}
private assume !ki,h,r,d. ExtendHistory(ki,Formats.Alert,h,r,d) =
	 { handshake = h.handshake;
	   alert = Fragment.Extend(ki,h.alert,r,d);
	   ccs = h.ccs;
	   appdata = h.appdata}
private assume !ki,h,r,d. ExtendHistory(ki,Formats.Change_cipher_spec,h,r,d) =  
	 { handshake = h.handshake;
	   alert = h.alert;
	   ccs = Fragment.Extend(ki,h.ccs,r,d);
	   appdata = h.appdata}
private assume !ki,h,r,d. ExtendHistory(ki,Formats.Application_data,h,r,d) = 
	 { handshake = h.handshake;
	   alert = h.alert;
	   ccs = h.ccs;
	   appdata = Fragment.Extend(ki,h.appdata,r,d)}

function val HistoryStream: e:epoch * Formats.ContentType * (;e)history -> 'a //(;e)stream
private definition !e,h. HistoryStream(e,Formats.Handshake,h) = h.handshake
private definition !e,h. HistoryStream(e,Formats.Alert,h) = h.alert
private definition !e,h. HistoryStream(e,Formats.Change_cipher_spec,h) = h.ccs
private definition !e,h. HistoryStream(e,Formats.Application_data,h) = h.appdata

val historyStream: e:epoch -> ct:Formats.ContentType -> h:(;e)history ->
	s:(;e)stream{s=HistoryStream(e,ct,h)}

ask !e,h. EmptyHistory(e,h) => EmptyStream(e,HistoryStream(e,Formats.Handshake,h))
ask !e,h. EmptyHistory(e,h) => EmptyStream(e,HistoryStream(e,Formats.Alert,h))
ask !e,h. EmptyHistory(e,h) => EmptyStream(e,HistoryStream(e,Formats.Change_cipher_spec,h))
ask !e,h. EmptyHistory(e,h) => EmptyStream(e,HistoryStream(e,Formats.Application_data,h))

assume !ki,sh,h. StatefulPlain.EmptyHistory(ki,sh) /\
   EmptyHistory(ki,h) => h = Multiplexed(ki,sh)
assume !ki,sh,sh',h,ct,r,x. 
  (sh' = StatefulPlain.ExtendHistory(ki,sh,ADBytes(ki,ct),r,x) /\
   h = Multiplexed(ki,sh)) => 
  (Multiplexed(ki,sh') = ExtendHistory(ki,ct,h,r,x))

private assume !ki,h. TLSHistory(ki,h)


val contents: ki:epoch -> ct:ContentType -> h:(;ki) history -> rg:range -> 
  f:(;ki,ct,h,rg) fragment -> d:(;ki,rg) Fragment.fragment {Auth(ki) => TLSFragment(ki,ct,h,rg,d)}

val construct: ki:epoch -> ct:ContentType -> h:(;ki) history -> rg:range -> 
  d:(;ki,rg) Fragment.fragment {Auth(ki) => TLSFragment(ki,ct,h,rg,d)} -> 
  f:(;ki,ct,h,rg) fragment
    
  
assume !ki,sh,ct,r,x.  
  StatefulPlain.Fragment(ki,sh,ADBytes(ki,ct),r,x) <=> 
  TLSFragment(ki,ct,Multiplexed(ki,sh),r,x)

val TLSFragmentToFragment: ki:epoch -> ct:ContentType -> h:(;ki) history -> st:(;ki) StatefulPlain.history{h = Multiplexed(ki,st)} -> rg:range -> 
  f:(;ki,ct,h,rg) fragment -> d:(;ki,st,ADBytes(ki,ct),rg) StatefulPlain.fragment


val fragmentToTLSFragment: ki:epoch -> ct:ContentType -> h:(;ki) history -> st:(;ki) StatefulPlain.history{h = Multiplexed(ki,st)} -> rg:range -> 
  d:(;ki,st,ADBytes(ki,ct),rg) StatefulPlain.fragment -> f:(;ki,ct,h,rg) fragment
