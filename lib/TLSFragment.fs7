module TLSFragment

open Bytes
open TLSInfo
open Formats
open CipherSuites

// Plain type for Dispatch
type (;ki:KeyInfo,tlen:int,seqn:int,ct:ContentType) fragment =
    | FHandshake of (;ki,tlen,seqn)Handshake.fragment    {ct=Formats.Handshake}
    | FCCS       of (;ki,tlen,seqn)Handshake.ccsFragment {ct=Change_cipher_spec}
    | FAlert     of (;ki,tlen,seqn)Alert.fragment        {ct=Alert}
    | FAppData   of (;ki,tlen,seqn)AppDataStream.fragment {ct=Application_data}

predicate Fragment of KeyInfo * int * int * ContentType * bytes

assume !ki,tlen,seq,ct,b.
  Fragment(ki,tlen,seq,ct,b) <=> (
   (ct = Application_data /\ AppDataStream.AppDataFragment(ki,tlen,seq,b)) \/
   (ct = Handshake /\ Handshake.HandshakeFragment(ki,tlen,seq,b)) \/
   (ct = Alert /\ Alert.AlertFragment(ki,tlen,seq,b)) \/
   (ct = Change_cipher_spec /\ Handshake.CCSFragment(ki,tlen,seq,b)))

val TLSFragmentRepr: ki:KeyInfo -> tlen:int -> seqn:int -> 
  ct:ContentType -> (;ki,tlen,seqn,ct)fragment -> 
  x:bytes{Fragment(ki,tlen,seqn,ct,x)}

val TLSFragment: ki:KeyInfo -> tlen:int -> seqn:int -> 
  ct:ContentType -> b:bytes{Corrupt(ki) \/ Fragment(ki,tlen,seqn,ct,b)} -> 
  (;ki,tlen,seqn,ct)fragment

function val ADLength: ProtocolVersion -> int
assume !pv. (pv = SSL_3p0 /\ ADLength(pv) = 9) \/ (pv <> SSL_3p0 /\ ADLength(pv) = 11)

// Additional Data
type (;pv:ProtocolVersion) addData = (b:bytes){Length(b) = ADLength(pv)}

function val ADBytes: (ProtocolVersion * int * ContentType) -> bytes
assume !pv,seqn,ct.
	( pv = SSL_3p0 /\
	  ADBytes(pv,seqn,ct) =
		IntBytes(8,seqn) @| CTBytes(ct) ) \/
	( pv <> SSL_3p0 /\
          ADBytes(pv,seqn,ct) =
		IntBytes(8,seqn) @| (CTBytes(ct) @| VersionBytes(pv)))

ask !pv,seqn,ct. Length(ADBytes(pv,seqn,ct)) = ADLength(pv)

function val ADct: pv:ProtocolVersion * (;pv)addData -> ContentType
assume !pv,seqn,ct. ADct(pv,ADBytes(pv,seqn,ct)) = ct

function val ADseqn: pv:ProtocolVersion * (;pv)addData -> int
assume !pv,seqn,ct. ADseqn(pv,ADBytes(pv,seqn,ct)) = seqn

private val makeAD: pv:ProtocolVersion ->
	seqn:int -> ct:ContentType ->
	  ad: (;pv)addData{ad=ADBytes(pv,seqn,ct)}

private val parseAD: pv:ProtocolVersion -> 
          ad: (;pv)addData -> 
          (seqn:int * ct:ContentType){ad=ADBytes(pv,seqn,ct)}


private type (;ki:KeyInfo,tlen:int,ad:(;ki.sinfo.protocol_version)addData) AEADPlain = bytes

predicate AEADMsg of ki:KeyInfo * int * (;ki.sinfo.protocol_version)addData * bytes
assume !ki,tlen,ad,x. AEADMsg(ki,tlen,ad,x) <=> 
  (Corrupt(ki) \/
     Fragment(ki,tlen,
              ADseqn(ki.sinfo.protocol_version,ad),
              ADct(ki.sinfo.protocol_version,ad),
              x))

val AEADPlain: ki:KeyInfo -> tlen:int -> ad:(;ki.sinfo.protocol_version) addData -> bytes -> (;ki,tlen,ad)AEADPlain
val AEADRepr:  ki:KeyInfo -> tlen:int -> ad:(;ki.sinfo.protocol_version) addData -> f:(;ki,tlen,ad)AEADPlain -> b:bytes{b=f}

val AEADPlainToTLSFragment: ki:KeyInfo -> tlen:int -> 
  ad:(;ki.sinfo.protocol_version) addData -> 
                            p:(;ki,tlen,ad)AEADPlain{AEADMsg(ki,tlen,ad,p)} -> 
                            f:(;ki,tlen,
			       ADseqn(ki.sinfo.protocol_version,ad),
			       ADct(ki.sinfo.protocol_version,ad)) fragment


val TLSFragmentToAEADPlain: ki:KeyInfo -> tlen:int -> seqn:int -> ct:ContentType -> 
                            f:(;ki,tlen,seqn,ct)fragment -> 
                            p:(;ki,tlen,ADBytes(ki.sinfo.protocol_version,seqn,ct)) AEADPlain{
				AEADMsg(ki,tlen,ADBytes(ki.sinfo.protocol_version,seqn,ct),p)}
