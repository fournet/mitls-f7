module TLSFragment

(* Multiplexing the 4 content types used by TLS (a bit tedious) *) 

open Bytes
open TLSInfo
open TLSConstants
open Range

//CF are we still planning to define clones of HSFragment or not? 

// no additional data definition for this module
//CF ? 

private type (;e:epoch,ct:ContentType,rg:range) fragment =
    | FHandshake of f:(;e,rg)HSFragment.fragment {ct=Handshake}
    | FCCS       of f:(;e,rg)HSFragment.fragment {ct=Change_cipher_spec}
    | FAlert     of f:(;e,rg)HSFragment.fragment {ct=Alert}
    | FAppData   of f:(;e,rg)AppFragment.fragment{ct=Application_data}

function val Payload: e:epoch * ct:ContentType * r:range * (;e,ct,r)fragment -> 'a // (;r)rbytes
private definition !e,r,f. Payload(e,Handshake,         r,FHandshake(f)) = HSFragment.Payload(e,r,f)
private definition !e,r,f. Payload(e,Change_cipher_spec,r,FCCS(f))       = HSFragment.Payload(e,r,f)
private definition !e,r,f. Payload(e,Alert,             r,FAlert(f))     = HSFragment.Payload(e,r,f)
private definition !e,r,f. Payload(e,Application_data,  r,FAppData(f))   = AppFragment.Payload(e,r,f)

private type (;e:epoch) history = {
  handshake: (;e) HSFragment.stream;
  ccs:       (;e) HSFragment.stream; 
  alert:     (;e) HSFragment.stream; 
  appdata:   (;e) DataStream.stream }

function val HandshakeHistory: e:epoch * (;e) history -> 'a //(;e)HSFragment.stream
function val   AppDataHistory: e:epoch * (;e) history -> 'a //(;e)DataStream.stream
function val     AlertHistory: e:epoch * (;e) history -> 'a //(;e)HSFragment.stream
function val       CCSHistory: e:epoch * (;e) history -> 'a //(;e)HSFragment.stream

private definition !e,h. HandshakeHistory(e,h) = h.handshake
private definition !e,h. AlertHistory(e,h)     = h.alert
private definition !e,h. CCSHistory(e,h)       = h.ccs
private definition !e,h. AppDataHistory(e,h)   = h.appdata

predicate RecordSent of e:epoch * ct:ContentType * h:(;e) history * rg:range * (;e,ct,rg)fragment
private definition !e,ct,h,rg,d.
  RecordSent(e,ct,h,rg,d) <=> ( 
    (?f. ct=Handshake          /\ d = FHandshake(f) /\ HSFragment.Sent(e,HandshakeHistory(e,h),rg,f) ) \/
    (?f. ct=Change_cipher_spec /\ d = FCCS(f)       /\ HSFragment.Sent(e,CCSHistory(e,h),rg,f) ) \/
    (?f. ct=Alert              /\ d = FAlert(f)     /\ HSFragment.Sent(e,AlertHistory(e,h),rg,f) ) \/
    (?f. ct=Application_data   /\ d = FAppData(f)   /\ AppFragment.Sent(e,AppDataHistory(e,h),rg,f)))
(*
private definition !e,h,rg,f.
  (HSFragment,.
  RecordSent(e,ct,h,rg,d) <=> ( 
    (?f. ct=Handshake          /\ d = FHandshake(f) /\ HSFragment.Sent(e,HandshakeHistory(e,h),rg,f) ) \/
    (?f. ct=Change_cipher_spec /\ d = FCCS(f)       /\ HSFragment.Sent(e,CCSHistory(e,h),rg,f) ) \/
    (?f. ct=Alert              /\ d = FAlert(f)     /\ HSFragment.Sent(e,AlertHistory(e,h),rg,f) ) \/
    (?f. ct=Application_data   /\ d = FAppData(f)   /\ AppFragment.Sent(e,AppDataHistory(e,h),rg,f)))
*)
ask !e,h,rg,f. HSFragment.Sent(e,HandshakeHistory(e,h),rg,f) =>
      RecordSent(e,Handshake,h,rg,FHandshake(f))

type (;e:epoch,ct:ContentType,h:(;e)history,rg:range) plain = 
  f:(;e,ct,rg)fragment { Auth(e) => RecordSent(e,ct,h,rg,f) }

function val ExtendHistory: e:epoch * ct:ContentType * ss:(;e)history * r:range * (;e,ct,ss,r)plain -> 'a //(;e)history

val extendHistory: e:epoch -> ct:ContentType -> ss:(;e)history -> r:range ->
  f:(;e,ct,ss,r)plain -> ss':(;e)history{ss' = ExtendHistory(e,ct,ss,r,f)}

val plain: e:epoch{not Auth(e)} -> ct:ContentType -> h: (;e) history -> rg:range ->
  b:(;rg)rbytes -> p:(;e,ct,h,rg)plain {b = Payload(e,ct,rg,p)}

val reprFragment: e:epoch{not Safe(e)} -> ct:ContentType -> rg:range ->
  f:(;e,ct,rg)fragment -> b:(;rg)rbytes{b = Payload(e,ct,rg,f)}

val repr: e:epoch{not Safe(e)} -> ct:ContentType -> h: (;e) history -> rg:range ->
  p:(;e,ct,h,rg)plain -> b:(;rg)rbytes{b = Payload(e,ct,rg,p)}

val widen: e:succEpoch -> ct:ContentType -> r0:range -> f0:(;e,ct,r0)fragment ->
	f1:(;e,ct,RangeClass(e,r0))fragment{Payload(e,ct,r0,f0) = Payload(e,ct,RangeClass(e,r0),f1)}

//CF why not using a logical function instead?
predicate EmptyHistory of e:epoch * (;e)history
private definition !e,h. EmptyHistory(e,h) <=>
	( HSFragment.EmptyStream(e,h.handshake) /\ HSFragment.EmptyStream(e,h.alert) /\
	  HSFragment.EmptyStream(e,h.ccs)       /\ DataStream.EmptyStream(e,h.appdata) )

val emptyHistory: e:epoch -> h:(;e)history{EmptyHistory(e,h)}
    
private assume !e,h,r,f. ExtendHistory(e,TLSConstants.Handshake,h,r,FHandshake(f)) = 
	 { handshake = HSFragment.Extend(e,HandshakeHistory(e,h),r,f);
	   alert = AlertHistory(e,h);
	   ccs = CCSHistory(e,h);
	   appdata = AppDataHistory(e,h)}
private assume !e,h,r,f. ExtendHistory(e,TLSConstants.Alert,h,r,FAlert(f)) = 
	 { handshake = HandshakeHistory(e,h);
	   alert = HSFragment.Extend(e,AlertHistory(e,h),r,f);
	   ccs = CCSHistory(e,h);
	   appdata = AppDataHistory(e,h)}
private assume !e,h,r,f. ExtendHistory(e,TLSConstants.Change_cipher_spec,h,r,FCCS(f)) = 
	 { handshake = HandshakeHistory(e,h);
	   alert = AlertHistory(e,h);
	   ccs = HSFragment.Extend(e,CCSHistory(e,h),r,f);
	   appdata = AppDataHistory(e,h)}
private assume !e,h,r,f. ExtendHistory(e,TLSConstants.Application_data,h,r,FAppData(f)) = 
	 { handshake = HandshakeHistory(e,h);
	   alert = AlertHistory(e,h);
	   ccs = CCSHistory(e,h);
	   appdata = AppFragment.Extend(e,AppDataHistory(e,h),r,f)}

ask !e,h,h',r,f. h' = ExtendHistory(e,TLSConstants.Handshake,h,r,FHandshake(f)) =>
	( HandshakeHistory(e,h') = HSFragment.Extend(e,HandshakeHistory(e,h),r,f) /\
	  AlertHistory(e,h') = AlertHistory(e,h) /\
	  CCSHistory(e,h') = CCSHistory(e,h) /\
	  AppDataHistory(e,h') = AppDataHistory(e,h))
ask !e,h,h',r,f. h' = ExtendHistory(e,TLSConstants.Alert,h,r,FAlert(f)) =>
	( AlertHistory(e,h') = HSFragment.Extend(e,AlertHistory(e,h),r,f) /\
	  HandshakeHistory(e,h') = HandshakeHistory(e,h) /\
	  CCSHistory(e,h') = CCSHistory(e,h) /\
	  AppDataHistory(e,h') = AppDataHistory(e,h))
ask !e,h,h',r,f. h' = ExtendHistory(e,TLSConstants.Change_cipher_spec,h,r,FCCS(f)) =>
	( CCSHistory(e,h') = HSFragment.Extend(e,CCSHistory(e,h),r,f) /\
	  AlertHistory(e,h') = AlertHistory(e,h) /\
	  HandshakeHistory(e,h') = HandshakeHistory(e,h) /\
	  AppDataHistory(e,h') = AppDataHistory(e,h))
ask !e,h,h',r,f. h' = ExtendHistory(e,TLSConstants.Application_data,h,r,FAppData(f)) =>
	( AppDataHistory(e,h') = AppFragment.Extend(e,AppDataHistory(e,h),r,f) /\
	  AlertHistory(e,h') = AlertHistory(e,h) /\
	  CCSHistory(e,h') = CCSHistory(e,h) /\
	  HandshakeHistory(e,h') = HandshakeHistory(e,h))

ask !e,h. EmptyHistory(e,h) => HSFragment.EmptyStream(e,HandshakeHistory(e,h))
ask !e,h. EmptyHistory(e,h) => HSFragment.EmptyStream(e,AlertHistory(e,h))
ask !e,h. EmptyHistory(e,h) => HSFragment.EmptyStream(e,CCSHistory(e,h))
ask !e,h. EmptyHistory(e,h) => DataStream.EmptyStream(e,AppDataHistory(e,h))

val makePlain: e:epoch -> ct:ContentType -> h:(;e)history -> r:range ->
	f:(;e,ct,r)fragment{Auth(e) => RecordSent(e,ct,h,r,f)} -> 
        (;e,ct,h,r)plain

val HSPlainToRecordPlain: e:epoch -> h:(;e)history -> r:range -> 
  d:(;e,HandshakeHistory(e,h),r) HSFragment.plain -> 
  f:(;e,TLSConstants.Handshake,h,r) plain

val RecordPlainToHSPlain: e:epoch -> h:(;e) history -> r:range -> 
  f:(;e,TLSConstants.Handshake,h,r) plain ->
  d:(;e,HandshakeHistory(e,h),r) HSFragment.plain

val CCSPlainToRecordPlain: e:epoch -> h:(;e)history -> r:range -> 
  d:(;e,CCSHistory(e,h),r) HSFragment.plain -> 
  f:(;e,TLSConstants.Change_cipher_spec,h,r) plain

val RecordPlainToCCSPlain: e:epoch -> h:(;e) history -> r:range -> 
  f:(;e,TLSConstants.Change_cipher_spec,h,r) plain -> 
  d:(;e,CCSHistory(e,h),r) HSFragment.plain

val AlertPlainToRecordPlain: e:epoch -> h:(;e)history -> r:range -> 
  d:(;e,AlertHistory(e,h),r) HSFragment.plain -> 
  f:(;e,TLSConstants.Alert,h,r) plain

val RecordPlainToAlertPlain: e:epoch -> h:(;e) history -> r:range -> 
  f:(;e,TLSConstants.Alert,h,r) plain -> 
  d:(;e,AlertHistory(e,h),r) HSFragment.plain

val AppPlainToRecordPlain: e:epoch -> h:(;e)history -> r:range -> 
  d:(;e,AppDataHistory(e,h),r) AppFragment.plain -> 
  f:(;e,TLSConstants.Application_data,h,r) plain

val RecordPlainToAppPlain: e:epoch -> h:(;e) history -> r:range -> 
  f:(;e,TLSConstants.Application_data,h,r) plain -> 
  d:(;e,AppDataHistory(e,h),r) AppFragment.plain
