module TLSFragment

open Bytes
open TLSInfo
open Formats
open CipherSuites
open DataStream

private type (;ki:epoch) prehistory = {
  handshake: (;ki) stream;
  alert: (;ki) stream; 
  ccs: (;ki) stream; 
  appdata: (;ki) stream
}
predicate TLSHistory of ki:epoch * (;ki) prehistory
type (;ki:epoch) history = p:(;ki) prehistory{TLSHistory(ki,p)}

function val Multiplexed: ki:epoch * (;ki) StatefulPlain.history -> 'b

predicate EmptyHistory of ki:epoch * (;ki)history
val emptyHistory: ki:epoch -> h:(;ki)history{EmptyHistory(ki,h)}

function val HistoryStream: e:epoch * Formats.ContentType * (;e)history -> 'a //(;e)stream
private definition !e,h. HistoryStream(e,Formats.Handshake,h) = h.handshake
private definition !e,h. HistoryStream(e,Formats.Alert,h) = h.alert
private definition !e,h. HistoryStream(e,Formats.Change_cipher_spec,h) = h.ccs
private definition !e,h. HistoryStream(e,Formats.Application_data,h) = h.appdata

predicate TLSFragment of ki:epoch * ct:ContentType * h:(;ki) history * rg:range * d:(;ki,rg) Fragment.fragment
assume !ki,ct,h,rg,d.
  TLSFragment(ki,ct,h,rg,d) <=> (
    (ct = Formats.Handshake /\ Fragment.Fragment(ki,HistoryStream(ki,ct,h),rg,d)) \/
    (ct = Formats.Change_cipher_spec /\ Fragment.Fragment(ki,HistoryStream(ki,ct,h),rg,d)) \/
    (ct = Formats.Alert /\ Fragment.Fragment(ki,HistoryStream(ki,ct,h),rg,d)) \/
    (ct = Formats.Application_data /\ Fragment.Fragment(ki,HistoryStream(ki,ct,h),rg,d))
  )


type (;ki:epoch,ct:ContentType,h:(;ki) history,rg:range) fragment =
    | FHandshake of f:(;ki,rg)Fragment.fragment{ct=Formats.Handshake  /\ (Auth(ki) => TLSFragment(ki,ct,h,rg,f))}
    | FCCS       of f:(;ki,rg)Fragment.fragment{ct=Formats.Change_cipher_spec  /\ (Auth(ki) => TLSFragment(ki,ct,h,rg,f))}
    | FAlert     of f:(;ki,rg)Fragment.fragment{ct=Formats.Alert  /\ (Auth(ki) => TLSFragment(ki,ct,h,rg,f))}
    | FAppData   of f:(;ki,rg)Fragment.fragment{ct=Formats.Application_data  /\ (Auth(ki) => TLSFragment(ki,ct,h,rg,f))}

function val TLSContents: 'a -> 'b // TLSFragment -> Fragment
assume !f. TLSContents(FHandshake(f)) = f
assume !f. TLSContents(FCCS(f)) = f
assume !f. TLSContents(FAlert(f)) = f
assume !f. TLSContents(FAppData(f)) = f

function val ExtendHistory: ki:epoch * ct:ContentType * ss:(;ki)history * r:range * (;ki,r)Fragment.fragment -> 'a 

function val ADBytes: (epoch * ContentType) -> bytes //(;ki)StatefulPlain.data
val addToHistory: ki:epoch -> ct:ContentType -> ss:(;ki)history -> r:range ->
	f:(;ki,ct,ss,r)fragment ->  
        ss':(;ki)history{ss' = ExtendHistory(ki,ct,ss,r,TLSContents(f))}


val fragmentRepr: ki:epoch{not Safe(ki)} -> ct:ContentType -> h: (;ki) history -> rg:range ->
  (;ki,ct,h,rg)fragment -> bytes

val fragmentPlain: ki:epoch{not Auth(ki)} -> ct:ContentType -> h: (;ki) history -> rg:range ->
  (;rg)rbytes -> (;ki,ct,h,rg)fragment 


assume !ki,ct.
	( EpochSI(ki).protocol_version = SSL_3p0 /\
	  ADBytes(ki,ct) =
		CTBytes(ct) ) \/
	( EpochSI(ki).protocol_version <> SSL_3p0 /\
          ADBytes(ki,ct) =
		(CTBytes(ct) @| VersionBytes(EpochSI(ki).protocol_version)))

ask !ki,ct. Length(ADBytes(ki,ct)) = (AEPlain.ADLength(ki) - 8)

private val makeAD: ki:epoch -> ct:ContentType ->
	  ad: (;ki)StatefulPlain.data{ad=ADBytes(ki,ct)}

private assume !ki,h. EmptyHistory(ki,h) <=>
	( EmptyStream(ki,h.handshake) /\ EmptyStream(ki,h.alert) /\
	  EmptyStream(ki,h.ccs)       /\ EmptyStream(ki,h.appdata) )
private assume !ki,h,h'. EmptyHistory(ki,h) /\ EmptyHistory(ki,h') => h = h'

private assume !ki,ct,h,r,d,h'. ExtendHistory(ki,ct,h,r,d) = h' <=>
    ((ct = Formats.Handshake /\ h' = 
	 { handshake = Fragment.Extend(ki,h.handshake,r,d);
	   alert = h.alert;
	   ccs = h.ccs;
	   appdata = h.appdata}) \/
     (ct = Formats.Alert /\ h' = 
	 { handshake = h.handshake;
	   alert = Fragment.Extend(ki,h.alert,r,d);
	   ccs = h.ccs;
	   appdata = h.appdata}) \/
     (ct = Formats.Change_cipher_spec /\ h' = 
	 { handshake = h.handshake;
	   alert = h.alert;
	   ccs = Fragment.Extend(ki,h.ccs,r,d);
	   appdata = h.appdata}) \/
     (ct = Formats.Application_data /\ h' = 
	 { handshake = h.handshake;
	   alert = h.alert;
	   ccs = h.ccs;
	   appdata = Fragment.Extend(ki,h.appdata,r,d)}))

private assume !ki,h,r,d. ExtendHistory(ki,Formats.Handshake,h,r,d) = 
	 { handshake = Fragment.Extend(ki,h.handshake,r,d);
	   alert = h.alert;
	   ccs = h.ccs;
	   appdata = h.appdata}
private assume !ki,h,r,d. ExtendHistory(ki,Formats.Alert,h,r,d) = 
	 { handshake = h.handshake;
	   alert = Fragment.Extend(ki,h.alert,r,d);
	   ccs = h.ccs;
	   appdata = h.appdata}
private assume !ki,h,r,d. ExtendHistory(ki,Formats.Change_cipher_spec,h,r,d) = 
	 { handshake = h.handshake;
	   alert = h.alert;
	   ccs = Fragment.Extend(ki,h.ccs,r,d);
	   appdata = h.appdata}
private assume !ki,h,r,d. ExtendHistory(ki,Formats.Application_data,h,r,d) = 
	 { handshake = h.handshake;
	   alert = h.alert;
	   ccs = h.ccs;
	   appdata = Fragment.Extend(ki,h.appdata,r,d)}

ask !ki,h,h',r,d. h' = ExtendHistory(ki,Formats.Handshake,h,r,d) =>
	( HistoryStream(ki,Formats.Handshake,h') = Fragment.Extend(ki,HistoryStream(ki,Formats.Handshake,h),r,d) /\
	  HistoryStream(ki,Formats.Alert,h') = HistoryStream(ki,Formats.Alert,h) /\
	  HistoryStream(ki,Formats.Change_cipher_spec,h') = HistoryStream(ki,Formats.Change_cipher_spec,h) /\
	  HistoryStream(ki,Formats.Application_data,h') = HistoryStream(ki,Formats.Application_data,h))
ask !ki,h,h',r,d. h' = ExtendHistory(ki,Formats.Alert,h,r,d) =>
	( HistoryStream(ki,Formats.Alert,h') = Fragment.Extend(ki,HistoryStream(ki,Formats.Alert,h),r,d) /\
	  HistoryStream(ki,Formats.Handshake,h') = HistoryStream(ki,Formats.Handshake,h) /\
	  HistoryStream(ki,Formats.Change_cipher_spec,h') = HistoryStream(ki,Formats.Change_cipher_spec,h) /\
	  HistoryStream(ki,Formats.Application_data,h') = HistoryStream(ki,Formats.Application_data,h))
ask !ki,h,h',r,d. h' = ExtendHistory(ki,Formats.Change_cipher_spec,h,r,d) =>
	( HistoryStream(ki,Formats.Change_cipher_spec,h') = Fragment.Extend(ki,HistoryStream(ki,Formats.Change_cipher_spec,h),r,d) /\
	  HistoryStream(ki,Formats.Alert,h') = HistoryStream(ki,Formats.Alert,h) /\
	  HistoryStream(ki,Formats.Handshake,h') = HistoryStream(ki,Formats.Handshake,h) /\
	  HistoryStream(ki,Formats.Application_data,h') = HistoryStream(ki,Formats.Application_data,h))
ask !ki,h,h',r,d. h' = ExtendHistory(ki,Formats.Application_data,h,r,d) =>
	( HistoryStream(ki,Formats.Application_data,h') = Fragment.Extend(ki,HistoryStream(ki,Formats.Application_data,h),r,d) /\
	  HistoryStream(ki,Formats.Alert,h') = HistoryStream(ki,Formats.Alert,h) /\
	  HistoryStream(ki,Formats.Change_cipher_spec,h') = HistoryStream(ki,Formats.Change_cipher_spec,h) /\
	  HistoryStream(ki,Formats.Handshake,h') = HistoryStream(ki,Formats.Handshake,h))

val historyStream: e:epoch -> ct:Formats.ContentType -> h:(;e)history ->
	s:(;e)stream{s=HistoryStream(e,ct,h)}

ask !e,h. EmptyHistory(e,h) => EmptyStream(e,HistoryStream(e,Formats.Handshake,h))
ask !e,h. EmptyHistory(e,h) => EmptyStream(e,HistoryStream(e,Formats.Alert,h))
ask !e,h. EmptyHistory(e,h) => EmptyStream(e,HistoryStream(e,Formats.Change_cipher_spec,h))
ask !e,h. EmptyHistory(e,h) => EmptyStream(e,HistoryStream(e,Formats.Application_data,h))

assume !ki,sh,h. StatefulPlain.EmptyHistory(ki,sh) /\
   EmptyHistory(ki,h) => h = Multiplexed(ki,sh)
assume !ki,sh,sh',h,ct,r,x. 
  (sh' = StatefulPlain.ExtendHistory(ki,sh,ADBytes(ki,ct),r,x) /\
   h = Multiplexed(ki,sh)) => 
  (Multiplexed(ki,sh') = ExtendHistory(ki,ct,h,r,x))

private assume !ki,h. TLSHistory(ki,h)

val contents: ki:epoch -> ct:ContentType -> h:(;ki) history -> rg:range -> 
  f:(;ki,ct,h,rg) fragment -> d:(;ki,rg) Fragment.fragment {d = TLSContents(f) /\
	(Auth(ki) => TLSFragment(ki,ct,h,rg,d))}

val construct: ki:epoch -> ct:ContentType -> h:(;ki) history -> rg:range -> 
  d:(;ki,rg) Fragment.fragment {Auth(ki) => TLSFragment(ki,ct,h,rg,d)} -> 
  f:(;ki,ct,h,rg) fragment{d = TLSContents(f)}
    
  
assume !ki,sh,ct,r,x.  
  StatefulPlain.Sent(ki,StatefulPlain.ExtendHistory(ki,sh,ADBytes(ki,ct),r,x)) <=> 
  TLSFragment(ki,ct,Multiplexed(ki,sh),r,x)

val TLSFragmentToFragment: ki:epoch -> ct:ContentType -> h:(;ki) history ->
	st:(;ki) StatefulPlain.history{h = Multiplexed(ki,st)} -> rg:range -> f:(;ki,ct,h,rg) fragment -> 
	sf:(;ki,st,ADBytes(ki,ct),rg) StatefulPlain.statefulPlain
		{TLSContents(f) = StatefulPlain.SAEADContents(sf) /\
		 (Auth(ki) => TLSFragment(ki,ct,h,rg,StatefulPlain.SAEADContents(sf)))}


val fragmentToTLSFragment: ki:epoch -> ct:ContentType -> h:(;ki) history ->
	st:(;ki) StatefulPlain.history{h = Multiplexed(ki,st)} -> rg:range -> 
    d:(;ki,st,ADBytes(ki,ct),rg) StatefulPlain.statefulPlain ->
	f:(;ki,ct,h,rg) fragment{TLSContents(f) = StatefulPlain.SAEADContents(d)}
