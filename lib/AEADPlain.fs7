module AEADPlain
open Bytes
open TLSInfo
open DataStream
open Fragment
// Do not open Encode, or else Encode "module" and Encode "function" will clash. 


//------------------------------------------------------------------------------------------------------
// Interface towards AEAD
//------------------------------------------------------------------------------------------------------

type (;ki:epoch) data = (b:bytes){Length(b) = Encode.ADLength(ki)}
predicate AEADSays of ki:epoch * r:range * (;ki)data * (;ki,r)fragment
private type (;ki:epoch,r:range,ad:(;ki)data) preAEADPlain = x:(;ki,r)fragment{ Auth(ki) => AEADSays(ki,r,ad,x) }
private type (;ki:epoch,r:range,ad:(;ki)data) AEADPlain    = {contents: (;ki,r,ad)preAEADPlain}

// CF 04-09: TODO: add length constraints for those bytes
val AEADPlain: ki:epoch{not Auth(ki)} -> r:range -> ad:(;ki)data -> (;r)rbytes -> (;ki,ad,r) AEADPlain
val AEADRepr:  ki:epoch{not Safe(ki)} -> r:range -> ad:(;ki)data -> (;ki,ad,r) AEADPlain -> (;r)rbytes

// The following conversions embed AEADPlains into AEPlains 
val AEADPlainToAEPlain: ki:epoch -> r:range -> ad:(;ki)data -> (;ki,r,ad) AEADPlain -> (;ki,r,ad) Encode.AEPlain
val AEPlainToAEADPlain: ki:epoch -> r:range -> ad:(;ki)data -> (;ki,r,ad) Encode.AEPlain -> (;ki,r,ad) AEADPlain
assume !ki,r,d,f. Encode.AESays(ki,r,d,f) <=> AEADSays(ki,r,d,f)

//------------------------------------------------------------------------------------------------------
// Interface towards StatefulPlain
//------------------------------------------------------------------------------------------------------

val contents:  ki:epoch -> r:range -> ad:(;ki)data -> (;ki,r,ad)AEADPlain ->
	sb:(;ki,r)fragment{Auth(ki) => AEADSays(ki,r,ad,sb)}
val construct: ki:epoch -> r:range -> ad:(;ki)data ->
	sb:(;ki,r)fragment{Auth(ki) => AEADSays(ki,r,ad,sb)}
	-> (;ki,r,ad)AEADPlain

function val AEADContents: 'a -> 'b
assume !f. AEADContents(f) = f.contents

