module AEADPlain
open Bytes
open TLSConstants
open TLSInfo
open Range

//------------------------------------------------------------------------------------------------------
// `Plain' interface towards AEAD
//------------------------------------------------------------------------------------------------------

// We add an 8-byte sequence number to additional data.
type (;e:epoch) adata = (b:bytes){Length(b) = 8 + StatefulPlain.ADLength(e)}

function val MakeAD:  e:epoch * (;e)StatefulPlain.history * (;e)StatefulPlain.adata -> 'a // (;e)adata
private definition !e,h,ad. MakeAD(e,h,ad) = IntBytes(8,StatefulPlain.SeqN(e,h)) @| ad
function val ParseAD: e:epoch * (;e)adata -> 'a //(;e)StatefulPlain.adata
private definition !e,b,ad. Length(b) = 8 => ParseAD(e,b@|ad) = ad

ask !e,h,ad. ParseAD(e,MakeAD(e,h,ad)) = ad

val makeAD:  e:epoch -> h:(;e)StatefulPlain.history -> ad:(;e)StatefulPlain.adata -> b:(;e)adata{b=MakeAD(e,h,ad)}
val parseAD: e:epoch -> b:(;e)adata -> ad:(;e)StatefulPlain.adata{ad = ParseAD(e,b)}

private type (;e:epoch,ad:(;e)adata,r:range)fragment = {contents: (;e,ParseAD(e,ad),r)StatefulPlain.fragment}

//CF ideal only
predicate Zeros of r:range * (;r)rbytes
private definition !r,b. Zeros(r,b) //AP: not very nice definition
private val zeros: rg:range -> b:(;rg) rbytes{Zeros(rg,b)}

function val Payload: e:epoch * ad:(;e)adata * r:range * (;e,ad,r)fragment -> 'a // (;r)rbytes
//AP definition of Payload could be improved
private definition !e,ad,r,f,b.
	(Safe(e) /\ Zeros(r,b) => Payload(e,ad,r,f) = b)
private definition !e,ad,r,f.
	not Safe(e) => Payload(e,ad,r,f) = StatefulPlain.Payload(e,ParseAD(e,ad),r,f.contents)

predicate AEADSent of e:epoch * ad:(;e)adata * r:range * (;e,ad,r)fragment
type (;e:epoch,ad:(;e)adata,r:range) plain = f:(;e,ad,r)fragment{ Auth(e) => AEADSent(e,ad,r,f) }

val payload: e:succEpoch -> r:range -> ad:(;e)adata -> f:(;e,ad,r)plain ->
	b:(;r) rbytes{ b = AEADPlain.Payload(e,ad,r,f) }

val plain: e:succEpoch{not Auth(e)} -> ad:(;e)adata -> r:range -> b:(;r)rbytes -> p:(;e,ad,r) plain {b = Payload(e,ad,r,p)}
val repr:  e:succEpoch{not Safe(e)} -> ad:(;e)adata -> r:range -> p:(;e,ad,r) plain -> b:(;r)rbytes {b = Payload(e,ad,r,p)}
private val reprFragment:  e:succEpoch{not Safe(e)} -> ad:(;e)adata -> r:range -> f:(;e,ad,r) fragment -> b:(;r)rbytes {b = Payload(e,ad,r,f)}

val widen: e:succEpoch -> ad:(;e)adata -> r:range -> f:(;e,ad,r)fragment -> f':(;e,ad,RangeClass(e,r))fragment{Payload(e,ad,r,f) = Payload(e,ad,RangeClass(e,r),f')}

private definition !e,lad,r,f. 
  AEADSent(e,lad,r,f) <=> 
  (?had,sn,ph. lad = MakeAD(e,(sn,ph),had) /\ StatefulPlain.StAESent(e,had,(sn,ph),r,f.contents))

private ask !e,r,f,lad. (Auth(e) /\ (?had,sn,ph. MakeAD(e,(sn,ph),had) = lad /\ StatefulPlain.StAESent(e,had,(sn,ph),r,f.contents)) ) => 
                        (!had', sn', ph'. MakeAD(e,(sn',ph'),had') = lad /\ StatefulPlain.StAEHistory(e,ph') /\ StatefulPlain.HLength(e,ph') = sn' => StatefulPlain.StAESent(e,had',(sn',ph'),r,f.contents))

ask !e,ad,sn,ph,ad',r,x. (ad = MakeAD(e,(sn,ph),ad') /\ StatefulPlain.StAESent(e,ad',(sn,ph),r,x.contents)) => AEADSent(e,ad,r,x)

ask !e,ad,h,h',ad',ad''. ad = MakeAD(e,h,ad') /\ ad = MakeAD(e,h',ad'') => 
    (StatefulPlain.SeqN(e,h) = StatefulPlain.SeqN(e,h') /\ ad' = ad'')

//ask !e,ad,ad',ad'',sn,h,h',r,f. Auth(e) /\ StatefulPlain.StAESent(e,ad',(sn,h),r,f) /\ StatefulPlain.StAEHistory(e,h') /\  HLength(e,h') = sn => h = h'

//CF 22/4: these coercions are used only in StatefulAEAD.fs; they are not part of the "plain" interface to AEAD.

function val StAEToAEAD: 'a -> 'b // StatefulPlain.plain -> plain
private definition !p. StAEToAEAD(p) = {contents = p}

val StatefulPlainToAEADPlain: e:epoch -> h:(;e)StatefulPlain.history -> ad:(;e)StatefulPlain.adata -> r:range -> 
  f:(;e,ad,h,r)StatefulPlain.plain -> p:(;e,MakeAD(e,h,ad),r)plain{p = StAEToAEAD(f)}

val AEADPlainToStatefulPlain: e:epoch -> h:(;e)StatefulPlain.history -> ad:(;e)StatefulPlain.adata -> r:range ->
  p:(;e,MakeAD(e,h,ad),r)plain -> f:(;e,ad,h,r)StatefulPlain.plain{p = StAEToAEAD(f)}

//------------------------------------------------------------------------------------------------------
// `Internal' interface towards StatefulPlain
//------------------------------------------------------------------------------------------------------

// val contents:  e:epoch -> r:range -> ad:(;e)adata -> (;e,r,ad)AEADPlain ->
// 	sb:(;e,r)fragment{Auth(e) => AEADSent(e,ad,r,sb)}
// val construct: e:epoch -> r:range -> ad:(;e)adata ->
// 	sb:(;e,r)fragment{Auth(e) => AEADSent(e,ad,r,sb)}
// 	-> (;e,r,ad)AEADPlain
// 
// function val AEADContents: 'a -> 'b
// assume !f. AEADContents(f) = f.contents