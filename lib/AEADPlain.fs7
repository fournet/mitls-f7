module AEADPlain
open Bytes
open TLSConstants
open TLSInfo

//------------------------------------------------------------------------------------------------------
// `Plain' interface towards AEAD
//------------------------------------------------------------------------------------------------------

// We add an 8-byte sequence number to additional data.
type (;e:epoch) adata = (b:bytes){Length(b) = 8 + StatefulPlain.ADLength(e)}

function val MakeAD:  e:epoch * (;e)StatefulPlain.history * (;e)StatefulPlain.adata -> 'a // (;e)adata
private definition !e,h,ad. MakeAD(e,h,ad) = IntBytes(8,StatefulPlain.SeqN(e,h)) @| ad
function val ParseAD: e:epoch * (;e)adata -> 'a //(;e)StatefulPlain.adata
private assume !e,b,ad. Length(b) = 8 => ParseAD(e,b@|ad) = ad

ask !e,h,ad. ParseAD(e,MakeAD(e,h,ad)) = ad

val makeAD:  e:epoch -> h:(;e)StatefulPlain.history -> ad:(;e)StatefulPlain.adata -> b:(;e)adata{b=MakeAD(e,h,ad)}
val parseAD: e:epoch -> b:(;e)adata -> ad:(;e)StatefulPlain.adata{ad = ParseAD(e,b)}

private type (;e:epoch,ad:(;e)adata,r:range)fragment = {contents: (;e,ParseAD(e,ad),r)StatefulPlain.fragment}

predicate AEADSent of e:epoch * ad:(;e)adata * r:range * (;e,ad,r)fragment
type (;e:epoch,ad:(;e)adata,r:range) plain = f:(;e,ad,r)fragment{ Auth(e) => AEADSent(e,ad,r,f) }

val plain: e:succEpoch{not Auth(e)} -> ad:(;e)adata -> r:range -> (;r)rbytes -> (;e,ad,r) plain
private val reprFragment:  e:succEpoch{not Safe(e)} -> ad:(;e)adata -> r:range -> (;e,ad,r) fragment -> (;r)rbytes
val repr:  e:succEpoch{not Safe(e)} -> ad:(;e)adata -> r:range -> (;e,ad,r) plain -> (;r)rbytes

//CF 22/4: needs discussion

//private assume !e,ad,r,x. AEADSent(e,ad,r,x) <=> (?h,ad'. 
//  ad = MakeAD(e,h,ad') /\ StatefulPlain.StAESent(e,ad',h,r,x.contents))

//private assume !e,h,ad,r,f. AEADSent(e,MakeAD(e,h,ad),r,f) <=> StatefulPlain.StAESent(e,ad,h,r,f.contents)

private definition !e,lad,r,f. 
  AEADSent(e,lad,r,f) <=> 
  (?had,sn,ph. lad = MakeAD(e,(sn,ph),had) /\ StatefulPlain.StAESent(e,had,(sn,ph),r,f.contents))

private ask !e,r,f,lad. (Auth(e) /\ (?had,sn,ph. MakeAD(e,(sn,ph),had) = lad /\ StatefulPlain.StAESent(e,had,(sn,ph),r,f.contents)) ) => 
                        (!had', sn', ph'. MakeAD(e,(sn',ph'),had') = lad /\ StatefulPlain.StAEHistory(e,ph') /\ StatefulPlain.HLength(e,ph') = sn' => StatefulPlain.StAESent(e,had',(sn',ph'),r,f.contents))


ask !e,ad,sn,ph,ad',r,x. (ad = MakeAD(e,(sn,ph),ad') /\ StatefulPlain.StAESent(e,ad',(sn,ph),r,x.contents)) => AEADSent(e,ad,r,x)

ask !e,ad,h,h',ad',ad''. ad = MakeAD(e,h,ad') /\ ad = MakeAD(e,h',ad'') => 
    (StatefulPlain.SeqN(e,h) = StatefulPlain.SeqN(e,h') /\ ad' = ad'')

//ask !e,ad,ad',ad'',sn,h,h',r,f. Auth(e) /\ StatefulPlain.StAESent(e,ad',(sn,h),r,f) /\ StatefulPlain.StAEHistory(e,h') /\  HLength(e,h') = sn => h = h'

//CF 22/4: these coercions are used only in StatefulAEAD.fs; they are not part of the "plain" interface to AEAD.

function val StAEToAEAD: 'a -> 'b // StatefulPlain.plain -> plain
private definition !p. StAEToAEAD(p) = {contents = p}

val StatefulPlainToAEADPlain: e:epoch -> h:(;e)StatefulPlain.history -> ad:(;e)StatefulPlain.adata -> r:range -> 
  f:(;e,ad,h,r)StatefulPlain.plain -> p:(;e,MakeAD(e,h,ad),r)plain{p = StAEToAEAD(f)}

val AEADPlainToStatefulPlain: e:epoch -> h:(;e)StatefulPlain.history -> ad:(;e)StatefulPlain.adata -> r:range ->
  p:(;e,MakeAD(e,h,ad),r)plain -> f:(;e,ad,h,r)StatefulPlain.plain{p = StAEToAEAD(f)}

//------------------------------------------------------------------------------------------------------
// `Internal' interface towards StatefulPlain
//------------------------------------------------------------------------------------------------------

// val contents:  e:epoch -> r:range -> ad:(;e)adata -> (;e,r,ad)AEADPlain ->
// 	sb:(;e,r)fragment{Auth(e) => AEADSent(e,ad,r,sb)}
// val construct: e:epoch -> r:range -> ad:(;e)adata ->
// 	sb:(;e,r)fragment{Auth(e) => AEADSent(e,ad,r,sb)}
// 	-> (;e,r,ad)AEADPlain
// 
// function val AEADContents: 'a -> 'b
// assume !f. AEADContents(f) = f.contents