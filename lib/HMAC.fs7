module HMAC

open Bytes
open Algorithms

type key = bytes
type data = bytes
type mac = bytes

val sslKeyedHashPads: 
  a:hashAlg{a = MD5 \/ a = SHA} -> bytes * bytes
val sslKeyedHash: 
  a:hashAlg{a = MD5 \/ a = SHA} -> k:key{Length(k)=MacKeySize(a)} -> data -> 
  t:mac {Length(t)=MacKeySize(a)} 
val sslKeyedHashVerify:
  a:hashAlg{a = MD5 \/ a = SHA} -> k:key{Length(k)=MacKeySize(a)} -> data -> 
  t:mac {Length(t)=MacKeySize(a)} -> bool

val HMAC:       
  a:hashAlg{a=MD5 \/ a=SHA} -> k:key{Length(k)=MacKeySize(a)} -> data -> 
  t:mac {Length(t)=MacKeySize(a)} 
val HMACVERIFY: 
  a:hashAlg{a=MD5 \/ a=SHA} -> k:key{Length(k)=MacKeySize(a)} -> data -> 
  t:mac {Length(t)=MacKeySize(a)} -> bool

(* internal; we may as well assume the signatures above. *)
val hmacmd5: 
  k:key{Length(k)=MacKeySize(MD5)} -> data -> t:mac{Length(t)=MacKeySize(MD5)}
val hmacsha1: 
  k:key{Length(k)=MacKeySize(SHA)} -> data -> t:mac{Length(t)=MacKeySize(SHA)}
val hmacsha256: 
  k:key{Length(k)=MacKeySize(SHA256)} -> data -> t:mac{Length(t)=MacKeySize(SHA256)}
val hmacsha384: 
  k:key{Length(k)=MacKeySize(SHA384)} -> data -> t:mac{Length(t)=MacKeySize(SHA384)}
   
