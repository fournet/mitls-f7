module Record

// 18/11/11 status? seems out of date.

open Pi
open Bytes
open Tcp
open Formats
open Error
open TLSInfo
open TLSPlain
open CipherSuites

type CipherState =
  | BlockCipherState of Crypto.key * bytes
  | StreamCipherState

type preDirection =
  | CtoS
  | StoC
type Direction = d:preDirection{d = CtoS \/ d = StoC}

type ConnectionState =
  {rec_info: SessionInfo;
   dir: Direction;
   net_conn: Tcp.NetworkStream;
   compression: Compression;
   protocol_version: Formats.ProtocolVersion;
   cipher_state: CipherState;
   mk: key;
   seqn: int;
   sparams: Formats.SecurityParameters;}
type fragment = bytes
type ccs_data = {
    ccs_info: SessionInfo;
    ccs_pv: ProtocolVersion;
    ccs_comp: Compression;
    ccs_sparams: SecurityParameters;
    ccs_mkey: Crypto.key;
    ccs_ciphstate: CipherState}

(* Predicates *)

predicate type preds = 
  | InitConnState of ConnectionState * Tcp.NetworkStream * SessionInfo * Direction * ProtocolVersion
  | SendConnState of ConnectionState
  | RecvConnState of ConnectionState
  | FragmentSend of SessionInfo * seqn:int * ContentType * fragment
  | RecordSend of SessionInfo * ContentType * fragment * ProtocolVersion * int * key
  | UpperProtoSend of SessionInfo * ContentType * bytes * fragment
  | MACBytes of bytes * bytes * bytes * bytes * bytes
  | KHashBytes of bytes * bytes * bytes * bytes
  | TLSMKey of key * SessionInfo
  | TLSSKey of key * SessionInfo
  | ValidStreamCipherSettings of ccs_data
  | ValidBlockCipherSettings of ccs_data
  | NonNullCipherSettings of ccs_data
  | TLSVersion of Formats.ProtocolVersion

type sendState = cs:ConnectionState{SendConnState(cs)}
type recvState = cs:ConnectionState{RecvConnState(cs)}

function type funs = 
  | OutDir of SessionInfo
  | InDir of SessionInfo
  | CCSData of ConnectionState
  | CCSDataOtherRole of ConnectionState
  | Compressed of Compression * bytes
  | IncSeqNum of ConnectionState
  | UpdateIV of ConnectionState * bytes
  | UpdatePV of ConnectionState * ProtocolVersion
  | UpdateCS of ConnectionState * ccs_data * Direction
  | BlockKey of ConnectionState
  | BlockIV of ConnectionState

val indir: si:SessionInfo -> d:Direction{d = InDir(si)}
val outdir: si:SessionInfo -> d:Direction{d = OutDir(si)}

val incN : cs:ConnectionState -> cs':ConnectionState{cs' = IncSeqNum(cs)}
val initConnState :
  ns:Tcp.NetworkStream -> 
  si:SessionInfo{?r,s. si = InitSessionInfo(r,s)} -> 
  d:Direction -> 
  pv:Formats.ProtocolVersion -> 
  cs:ConnectionState{InitConnState(cs,ns,si,d,pv)}
val create :
  ns:Tcp.NetworkStream -> si:SessionInfo{?r,s. si = InitSessionInfo(r,s)} ->
  minpv:Formats.ProtocolVersion{minpv <> UnknownPV} ->
  scs:sendState * rcs:recvState{InitConnState(scs,ns,si,OutDir(si),minpv) /\ InitConnState(rcs,ns,si,InDir(si),UnknownPV)}
val max_TLSPlaintext_fragment_length : int
val max_TLSCompressed_fragment_length : int
val max_TLSEncrypted_fragment_length : int
val check_length :
  bytes ->
    int -> i:'a -> e:ErrorCause -> r:'a Result{(!x. r = Correct(x) => x = i) /\ (!y,z. r = Error(y,z) => (y=e /\ z = CheckFailed))}
val make_compression :
  cs:sendState -> b:bytes -> c:bytes Result{(!x. c = Correct(x) => x = Compressed(cs.compression,b)) /\ (!y,z. c = Error(y,z) => y = RecordCompression)}
val make_decompression :
  cs:recvState -> c:bytes -> b:bytes Result{(!x. b = Correct(x) => c = Compressed(cs.compression,x)) /\ (!y,z. b = Error(y,z) => y = RecordCompression)}

val compute_mac_ssl_blob: sn:bytes -> ct:bytes -> d:bytes ->
    mb:bytes{KHashBytes(mb,sn,ct,d)}

val compute_mac_ssl3 :
  ma:Formats.MACAlgorithm{ma = MA_md5 \/ ma = MA_sha1} ->
    k:Crypto.key{MKey(k)} ->
      sn:bytes ->
      ct:bytes ->
      d:bytes{!mb. KHashBytes(mb,sn,ct,d) => KHashSays(k,mb)} ->
              res:bytes Result{
                  (*(!x. res = Correct(x)) /\*)
                  (!y,z. res = Error(y,z) => (y = MAC /\ z = Internal) ) }

val compute_mac_tls_blob: 
  sn:bytes -> ct:bytes -> ver:bytes -> d:bytes -> mb:bytes{MACBytes(mb,sn,ct,ver,d)}

val compute_mac_tls:
  Formats.MACAlgorithm ->
  k:Crypto.key{MKey(k)} ->
  sn:bytes ->
  ct:bytes ->
  ver:bytes -> 
  d:bytes{!mb. MACBytes(mb,sn,ct,ver,d) => MACSays(k,mb)} -> 
  r:bytes Result
  { !y,z. r = Error(y,z) => y = MAC /\ (z = Internal \/ z = Unsupported)}

val compute_mac:
  cs:sendState -> 
  ct:Formats.ContentType -> 
  d:bytes{?f. RecordSend(cs.rec_info,ct,f,cs.protocol_version,cs.seqn,cs.mk) /\ d = Compressed(cs.compression,f)} ->
  res:bytes Result
  {   (!x. res = Correct(x) => (cs.sparams.mac_algorithm = MA_null => Pub(x)))
  /\  (!y,z. res = Error(y,z) => ( (y = MAC) /\ (z = Unsupported \/ z = Internal) )) }

// val padLength : Formats.SecurityParameters -> bytes -> int
val prepare_enc : ConnectionState -> d:bytes -> r:bytes{Pub(d) => Pub(r)}
val encrypt_stream :
    cs:sendState{cs.sparams.cipher_type = CT_stream} ->
      d:bytes{cs.sparams.bulk_cipher_algorithm = BCA_null => Pub(d)} -> 
        r:(sendState * bytespub) Result{
	(!cs',x. r = Correct((cs',x)) => (cs' = cs))
	/\
	(!y,z. r = Error(y,z) => (y = Encryption) /\ (z = Internal \/ z = Unsupported))
	}

val get_last_block : int -> bytespub -> bytespub
val compute_next_iv :
  pv:Formats.ProtocolVersion{pv <> UnknownPV /\ pv <> SSL_2p0} ->
    Formats.BulkCipherAlgorithm -> bytespub -> bytespub

val encrypt_fun: Formats.BulkCipherAlgorithm ->  k:key -> iv:bytes ->
  b:bytes{(SKey(k) /\ CanSymEncrypt(k,b)) \/ (Pub_k(k) /\ Pub(b))} -> 
  r:bytespub Result{(!e. r = Correct(e) => IsEncryption(e,k,b)) /\ (!y,z. r =
          Error(y,z) => ((y = Encryption) /\ (z = Internal \/ z = Unsupported)))}

val encrypt_block :
    cs:sendState{cs.sparams.cipher_type = CT_block} ->
      d:bytes{cs.sparams.bulk_cipher_algorithm = BCA_null => Pub(d)} -> 
      r:(sendState * bytespub) Result{
      (!cs',x. r = Correct((cs',x)) => (?iv. cs' = UpdateIV(cs,iv)))
      /\
      (!y,z. r = Error(y,z) => ((y = Encryption) /\ (z = Internal \/ z = Unsupported)))
      }

val encrypt :
  cs:sendState ->
    d:bytes{cs.sparams.bulk_cipher_algorithm = BCA_null => Pub(d)} -> 
      r:(sendState * bytespub) Result{
      (!cs',x. r = Correct((cs',x)) => (?iv. cs' = UpdateIV(cs,iv)))
      /\
      (!y,z. r = Error(y,z) => ((y = Encryption) /\ (z = Internal \/ z = Unsupported)))
      }

val generatePacket :
  Formats.ContentType -> Formats.ProtocolVersion -> bytespub -> bytespub

val send_setVersion :
  cs:ConnectionState -> pv:Formats.ProtocolVersion -> cs':ConnectionState

val send :
  cs:sendState ->
    ct:Formats.ContentType ->  
      f:bytes{FragmentSend(cs.rec_info,cs.seqn,ct,f) /\ (cs.sparams.bulk_cipher_algorithm = BCA_null => Pub(f))} -> 
        r:(sendState Result){           
	(!cs'. r = Correct(cs') => ((?iv. cs' = IncSeqNum(UpdateIV(cs,iv)))))
        /\
	(!y,z. r = Error(y,z) => ((y = Tcp \/ y = MAC \/ y = Encryption \/ y = RecordCompression)))}
        
val send_setCrypto :
  cs:sendState ->
    ccs: ccs_data{NonNullCipherSettings(ccs)} -> 
      cs':sendState{cs' = UpdateCS(cs,ccs,OutDir(ccs.ccs_info))}

val parseHeader :
  bytes -> (Formats.ContentType * Formats.ProtocolVersion * int) Result

val get_iv_ciphertext :
  pv:Formats.ProtocolVersion{pv <> UnknownPV /\ pv <> SSL_2p0} ->
  Formats.BulkCipherAlgorithm ->
  bytes ->
  bytespub -> (bytes * bytespub)

val decrypt_fun: Formats.BulkCipherAlgorithm ->
      k:key{SKey(k) \/ Pub_k(k)} -> iv:bytes -> e:bytes ->
      r:bytes Result{(!b. r = Correct(b) => ((!p. IsEncryption(e,k,p) => b = p) /\ (Pub_k(k) => Pub(b)))) /\
                     (!y,z. r = Error(y,z) => ((y = Encryption) /\ (z = Unsupported \/ z = Internal)))}
  
val block_decrypt :
  cs:recvState{cs.sparams.cipher_type = CT_block} ->
    bytespub ->
	r:((recvState * bytes) Result){
	(!cs',x. r = Correct((cs',x)) => ((?iv. cs' = UpdateIV(cs,iv))))
	/\
	(!y,z. r = Error(y,z) => ((y = Encryption) /\ (z = Internal \/ z = Unsupported \/ z = CheckFailed)))
	}

val decrypt :
  cs:recvState ->
    bytespub -> 
   r:((recvState * bytes) Result){
   (!cs',x. r = Correct((cs',x)) => ((?iv. cs' = UpdateIV(cs,iv))))
   /\
   (!y,z. r = Error(y,z) => ((y = Encryption) /\ (z = Internal \/ z = Unsupported \/ z = CheckFailed)))
   }

val check_padding_cont : b:bytes -> r:bytes Result{r = Correct(b)}
val check_padding :
  pv:Formats.ProtocolVersion{pv <> UnknownPV} -> bytes -> r:bytes Result{
  				!y,z. r = Error(y,z) =>
  				((pv = SSL_2p0 /\ y = RecordPadding /\ z = Unsupported) \/
				(pv = TLS_1p0 /\ y = RecordPadding /\ z = CheckFailed))}
val parse_plaintext :
  cs:ConnectionState{cs.protocol_version <> UnknownPV} -> bytes -> r:((bytes * bytes) Result){
  				!y,z. r = Error(y,z) =>
  				((cs.protocol_version = SSL_2p0 /\ y = RecordPadding /\ z = Unsupported) \/
				(cs.protocol_version = TLS_1p0 /\ y = RecordPadding /\ z = CheckFailed))}

val verify_mac: cs:recvState{cs.protocol_version <> UnknownPV} 
                    -> ct:Formats.ContentType -> d:bytes -> bytes ->
	r:unit Result{(!x. r = Correct (x) =>
	               (cs.sparams.mac_algorithm <> MA_null => 
		      ((?compr,f. d = Compressed(compr,f) /\ RecordSend(OtherRole(cs.rec_info),ct,f,cs.protocol_version,cs.seqn,cs.mk))
                         \/ Pub_k(cs.mk))))
                  /\
                      (!y,z. r = Error(y,z) => (y = MAC /\ (z = Internal \/ z = Unsupported \/ z = CheckFailed)))}

val recv :
  cs:recvState ->
    r:((Formats.ContentType * bytes * recvState) Result){
	(!ct,f,cs'. r = Correct((ct,f,cs')) =>
	       ((?pv,iv. cs' = IncSeqNum(UpdateIV(UpdatePV(cs,pv),iv))) /\
	            (cs.sparams.mac_algorithm <> MA_null =>
                       ((?cs''. SendConnState(cs'') /\ FragmentSend(cs''.rec_info,cs''.seqn,ct,f) /\ 
                                cs''.rec_info = OtherRole(cs.rec_info) /\ 
                                cs''.protocol_version = cs.protocol_version /\
                                cs''.seqn = cs.seqn /\
				cs''.mk = cs.mk)
                        \/ Pub_k(cs.mk)))))
	/\
	(!y,z. r = Error(y,z) => (
		(y = Tcp \/ y = RecordVersion \/ y = Encryption \/ y = MAC \/ y = RecordCompression \/ y = RecordPadding) /\
		((cs.protocol_version = SSL_3p0 \/ cs.protocol_version = TLS_1p1 \/ cs.protocol_version = TLS_1p2) => (y <> RecordPadding))
	))}
    
val dataAvailable: ConnectionState -> bool Result

val recv_setVersion:
  c:ConnectionState -> pv:Formats.ProtocolVersion -> c':ConnectionState

val recv_checkVersion : c:recvState -> pv:Formats.ProtocolVersion ->
	r:(unit Result){
	(!dummy. r = Correct(dummy) => c.protocol_version = pv) /\
	(!y,z. r = Error(y,z) => (c.protocol_version <> pv /\ y = RecordVersion /\ z = CheckFailed))
	}

val recv_setCrypto: c:recvState -> ccs:ccs_data {?cs'. ccs = CCSData(cs') /\ NonNullCipherSettings(CCSDataOtherRole(cs'))} ->
	c':recvState{c' = UpdateCS(c,ccs,InDir(ccs.ccs_info))}

val coherentrw: s:SessionInfo -> recv:recvState -> send:sendState ->
        r:bool{r = true => (s = recv.rec_info /\ s = send.rec_info)}

(* Data Formatting Assumptions *)
assume !a,b. (?d. d = Compressed(a,b))
assume !b. Compressed(Null,b) = b
assume !a,a',b,b'. Compressed(a,b) = Compressed(a',b') => b = b'
//CF these should move next to their function definitions, and could be proved concretely
assume !ct,ct'. ContentTypeBytes(ct) = ContentTypeBytes(ct') => ct = ct'
assume !pv,pv'. ProtocolVersionBytes(pv) = ProtocolVersionBytes(pv') => pv = pv'
assume !sn,sn'. SequenceNumberBytes(sn) = SequenceNumberBytes(sn') => sn = sn'

assume !ct. Pub(ContentTypeBytes(ct))
assume !ver. Pub(ProtocolVersionBytes(ver))
assume !b. Pub(b) => Pub(Num(Length(b)))
assume !a,b. Pub(b) => Pub(Compressed(a,b))

(* Sessions and Directions *)
assume !info. (info.role = ClientRole /\ OutDir(info) = CtoS) \/
	      (info.role = ServerRole /\ OutDir(info) = StoC)

assume !info. (info.role = ClientRole /\ InDir(info) = StoC) \/
	      (info.role = ServerRole /\ InDir(info) = CtoS)


(* Security Assumptions *)

(* Encryption *)
theorem !sk,info. TLSSKey(sk,info) => SKey(sk) 
theorem !sk,info,info'. TLSSKey(sk,info) /\ TLSSKey(sk,info') => info = info'
(* theorem !sk,info. TLSSKey(sk,info) => TLSSKey(sk,OtherRole(info)) *)

(* TLS MAC *)
theorem !mk,info. TLSMKey(mk,info) => MKey(mk) 
theorem !mk,info,info'. TLSMKey(mk,info) /\ TLSMKey(mk,info') => info = info'
(* theorem !mk,info. TLSMKey(mk,info) => TLSMKey(mk,OtherRole(info)) *)

(* Key compromise *)
(*
assume !mk,info. TLSMKey(mk,info) /\ Compromised(info) => Pub_k(mk)
theorem !mk,info. TLSMKey(mk,info) /\ Pub_k(mk) => Compromised(info)
assume !mk,info. TLSSKey(mk,info) /\ Compromised(info) => Pub_k(mk)
theorem !mk,info. TLSSKey(mk,info) /\ Pub_k(mk) => Compromised(info)
*)

(* Format of MACed bytestring *)
definition !mb,sn,ct,ver,d. MACBytes(mb,sn,ct,ver,d) <=> 
   mb = Concat(sn,Concat(ct,Concat(ver,Concat(Num(Length(d)),d))))

ask !mb,sn,ct,ver,d,sn',ct',ver',d'.
    MACBytes(mb,sn,ct,ver,d) /\  MACBytes(mb,sn',ct',ver',d') =>
    (sn = sn' /\ ct = ct' /\ ver = ver' /\ d = d')

(* SSL3 MAC *)
definition !mb,sn,ct,d. KHashBytes(mb,sn,ct,d) <=>
   mb = Concat(sn,Concat(ct,Concat(Num(Length(d)),d)))

ask !mb,sn,ct,d,sn',ct',d'.
    KHashBytes(mb,sn,ct,d) /\  KHashBytes(mb,sn',ct',d') =>
    (sn = sn' /\ ct = ct' /\ d = d')

(* Initial Connection State *)
definition !cs,ns,info,dir,pv. 
            InitConnState(cs,ns,info,dir,pv) <=>
	    (cs = { net_conn = ns;
		    rec_info = info;
		    dir = dir;
		    (* no constraints on net_conn *)
		    compression = Null;
		    (* no constraints on protocol version *)
		    protocol_version = pv;
		    cipher_state = StreamCipherState;
		    (* cs.mk = FIXME: what goes here? *)
		    mk = SymKey(empty_bstr);
		    seqn = 0;
		    sparams = { bulk_cipher_algorithm = BCA_null;
		                cipher_type = CT_stream;
			        mac_algorithm = MA_null}} /\
	    (dir = CtoS \/ dir = StoC) /\
	    (?role,sid. info = InitSessionInfo(role,sid) /\
            (role = ClientRole \/ role = ServerRole)
	    ))



definition !cs,k,iv. cs.cipher_state = BlockCipherState(k,iv) => BlockIV(cs) = iv
definition !cs,k,iv. cs.cipher_state = BlockCipherState(k,iv) => BlockKey(cs) = k

definition !ccs. ValidStreamCipherSettings(ccs) <=>
		    (ccs.ccs_sparams.cipher_type = CT_stream /\ ccs.ccs_ciphstate = StreamCipherState /\
		    (ccs.ccs_pv = UnknownPV => (ccs.ccs_sparams.bulk_cipher_algorithm = BCA_null /\ 
		                        ccs.ccs_sparams.mac_algorithm = MA_null)) /\
		    (ccs.ccs_sparams.bulk_cipher_algorithm = BCA_null <=> ccs.ccs_sparams.mac_algorithm = MA_null) /\
		    (ccs.ccs_sparams.mac_algorithm <> MA_null => TLSMKey(ccs.ccs_mkey,ccs.ccs_info)) /\
		    (ccs.ccs_pv = SSL_3p0 => (ccs.ccs_sparams.mac_algorithm = MA_md5 \/ ccs.ccs_sparams.mac_algorithm = MA_sha1 \/ 
		                      ccs.ccs_sparams.mac_algorithm = MA_null)))
		(* MA_null can
                    happen in any protocol version, but only at the beginning. We
                    might want to better model this *)
                
definition !ccs. ValidBlockCipherSettings(ccs) <=>
		    (ccs.ccs_sparams.cipher_type = CT_block /\ (?k,iv. ccs.ccs_ciphstate = BlockCipherState(k,iv)) /\
		    ccs.ccs_pv <> UnknownPV /\
		    ccs.ccs_sparams.bulk_cipher_algorithm <> BCA_null /\ ccs.ccs_sparams.mac_algorithm <> MA_null /\ 
		    TLSMKey(ccs.ccs_mkey,ccs.ccs_info) /\
		    (!k,iv. ccs.ccs_ciphstate = BlockCipherState(k,iv) => 
                                (TLSSKey(k,ccs.ccs_info) /\
                                ((ccs.ccs_pv = TLS_1p1 \/ ccs.ccs_pv = TLS_1p2) => Pub(iv)))) /\
		    (ccs.ccs_pv = SSL_3p0 => (ccs.ccs_sparams.mac_algorithm = MA_md5 \/ ccs.ccs_sparams.mac_algorithm = MA_sha1)))

definition !ccs. NonNullCipherSettings(ccs) <=> 
		    (ccs.ccs_pv <> UnknownPV /\ 
                    ccs.ccs_sparams.mac_algorithm <> MA_null /\ 
		    ccs.ccs_sparams.bulk_cipher_algorithm <> BCA_null /\
                    (ccs.ccs_info.role = ClientRole \/ ccs.ccs_info.role = ServerRole) /\
		    (ValidStreamCipherSettings(ccs) \/ ValidBlockCipherSettings(ccs)))

ask !ccs. NonNullCipherSettings(ccs) => (ValidStreamCipherSettings(ccs) \/ ValidBlockCipherSettings(ccs))
ask !ccs. NonNullCipherSettings(ccs) => (ccs.ccs_pv <> UnknownPV)

		    
ask !ccs. ValidBlockCipherSettings(ccs) => not (ValidStreamCipherSettings(ccs))

(* Connection State to CCSData *)

assume !cs. CCSData(cs) = {
	ccs_info = cs.rec_info;
	ccs_pv = cs.protocol_version;
	ccs_comp = cs.compression;
	ccs_sparams = cs.sparams;
	ccs_mkey = cs.mk;
	ccs_ciphstate = cs.cipher_state}

assume !cs. CCSDataOtherRole(cs) = {
	ccs_info = OtherRole(cs.rec_info);
	ccs_pv = cs.protocol_version;
	ccs_comp = cs.compression;
	ccs_sparams = cs.sparams;
	ccs_mkey = cs.mk;
	ccs_ciphstate = cs.cipher_state}

(* Sending Connection State *)
definition !cs. SendConnState(cs) <=>
        (cs.protocol_version <> UnknownPV /\
	 cs.dir = OutDir(cs.rec_info) /\
         (cs.rec_info.role = ClientRole \/ cs.rec_info.role = ServerRole) /\
         (ValidStreamCipherSettings(CCSData(cs)) \/ ValidBlockCipherSettings(CCSData(cs))))


(* Receiving Connection State *)
definition !cs. RecvConnState(cs) <=>
	( cs.dir = InDir(cs.rec_info) /\
         (cs.rec_info.role = ClientRole \/ cs.rec_info.role = ServerRole) /\
         (ValidStreamCipherSettings(CCSDataOtherRole(cs)) \/ ValidBlockCipherSettings(CCSDataOtherRole(cs))))

(* Small asymmetry: a SendConnState never has an unknown protocol version, while this can be the case for RecvConnState *)


(* Sending messages *)

assume !info,ct,f,pv,sn,mk. RecordSend(info,ct,f,pv,sn,mk) <=>
		    (?cs. SendConnState(cs) /\ 
                    FragmentSend(info,sn,ct,f) /\
                    cs.rec_info = info /\
		    cs.protocol_version = pv /\
		    cs.seqn = sn /\
		    cs.mk = mk ) 


(* Pre-conditions of encryption *)
assume !cs,k,iv. SendConnState(cs) /\ 
                 cs.cipher_state = BlockCipherState(k,iv) => 
                    (!eb. CanSymEncrypt(k,eb))


(* Pre-conditions of MAC *)
assume !pv. TLSVersion(pv) <=> (pv = TLS_1p0 \/ pv = TLS_1p1 \/ pv = TLS_1p2) 
assume !info,ct,f,pv,sn,mk,compr,mb.
		    TLSMKey(mk,info) /\
		    RecordSend(info,ct,f,pv,sn,mk) /\
		    TLSVersion(pv) /\
                    MACBytes(mb,SequenceNumberBytes(sn),ContentTypeBytes(ct),
		                ProtocolVersionBytes(pv),Compressed(compr,f)) =>
                    MACSays(mk,mb)


theorem !mk,mb,info'.          
		    TLSMKey(mk,info') /\
                    MACSays(mk,mb) =>
                   (?info,ct,f,pv,sn,compr.
		    TLSMKey(mk,info) /\ 
                    TLSVersion(pv) /\
                    MACBytes(mb,SequenceNumberBytes(sn),ContentTypeBytes(ct), (* One-One MACBytes *)
		                ProtocolVersionBytes(pv),Compressed(compr,f)) /\
		    RecordSend(info,ct,f,pv,sn,mk))


ask !info,ct,f,pv,sn,mk,compr,mb.
		   (TLSVersion(pv) /\
                    MACSays(mk,mb) /\
		    TLSMKey(mk,info) /\ (* One-One TLSMKey *)
                    MACBytes(mb,SequenceNumberBytes(sn),ContentTypeBytes(ct), (* One-One MACBytes *)
		                ProtocolVersionBytes(pv),Compressed(compr,f)) ) =>
		    RecordSend(info,ct,f,pv,sn,mk)

ask !cs. RecvConnState(cs) /\ cs.sparams.mac_algorithm <> MA_null => TLSMKey(cs.mk,OtherRole(cs.rec_info))

ask !cs,mb,ct,f.    TLSVersion(cs.protocol_version) /\
                    MACSays(cs.mk,mb) /\
                    RecvConnState(cs) /\ cs.sparams.mac_algorithm <> MA_null /\ 
                    MACBytes(mb,SequenceNumberBytes(cs.seqn),ContentTypeBytes(ct),
                             ProtocolVersionBytes(cs.protocol_version),Compressed(cs.compression,f)) => 
                    (?cs'. SendConnState(cs') /\ 
                            FragmentSend(cs'.rec_info,cs'.seqn,ct,f) /\
                            cs'.rec_info = OtherRole(cs.rec_info) /\
		            cs'.protocol_version = cs.protocol_version /\
		            cs'.seqn = cs.seqn /\
		            cs'.mk = cs.mk )

(* Old definition of MACSays *)
(*
assume !cs,ct,f,mb. SendConnState(cs) /\
                    (cs.protocol_version = TLS_1p0 \/ cs.protocol_version = TLS_1p1 \/
                     cs.protocol_version = TLS_1p2) /\
                    FragmentSend(cs,ct,f) /\ 
                    MACBytes(mb,SequenceNumberBytes(cs.seqn),ContentTypeBytes(ct),
                             ProtocolVersionBytes(cs.protocol_version),Compressed(cs.compression,f)) =>
                    MACSays(cs.mk,mb)
*)

(* definition !cs. RecvConnState(cs) => ( TLSMKey(cs.mk,cs.dir) <=> (MKey(cs.mk) /\ (?cs'. SendConnState(cs') /\ cs'.dir = cs.dir /\ cs'.mk = cs.mk)) ) *)

(* SSL 3 *)
assume !info,ct,f,pv,sn,mk,compr,mb.
		    RecordSend(info,ct,f,pv,sn,mk) /\
		    TLSMKey(mk,info) /\ 
		    pv = SSL_3p0 /\
                    KHashBytes(mb,SequenceNumberBytes(sn),ContentTypeBytes(ct),
                               Compressed(compr,f)) =>
                    KHashSays(mk,mb)

theorem !mk,mb,info'. TLSMKey(mk,info') /\          
                    KHashSays(mk,mb) =>
                   (?info,ct,f,pv,sn,compr.
		    TLSMKey(mk,info) /\ 
                    pv = SSL_3p0 /\
                    KHashBytes(mb,SequenceNumberBytes(sn),ContentTypeBytes(ct),
                               Compressed(compr,f)) /\
		    RecordSend(info,ct,f,pv,sn,mk))


ask !info,ct,f,pv,sn,mk,compr,mb.
		   (pv = SSL_3p0 /\
                    KHashSays(mk,mb) /\
		    TLSMKey(mk,info) /\ (* One-One TLSMKey *)
                    KHashBytes(mb,SequenceNumberBytes(sn),ContentTypeBytes(ct), (* One-One MACBytes *)
                               Compressed(compr,f)) ) =>
		    RecordSend(info,ct,f,pv,sn,mk)

ask !cs,mb,ct,f. RecvConnState(cs) /\ cs.sparams.mac_algorithm <> MA_null /\ 
                 KHashSays(cs.mk,mb) /\ 
                 cs.protocol_version = SSL_3p0 /\
                 KHashBytes(mb,SequenceNumberBytes(cs.seqn),ContentTypeBytes(ct),Compressed(cs.compression,f)) => 
            (?cs'. SendConnState(cs') /\
                    FragmentSend(cs'.rec_info,cs'.seqn,ct,f) /\
		    cs'.rec_info = OtherRole(cs.rec_info) /\
                    cs'.protocol_version = cs.protocol_version /\
                    cs'.seqn = cs.seqn /\
                    cs'.mk = cs.mk)

(* Old definition of KHashSays *)
(*
assume !cs,ct,f,mb. SendConnState(cs) /\
                    cs.protocol_version = SSL_3p0 /\
                    FragmentSend(cs,ct,f) /\ 
                    KHashBytes(mb,SequenceNumberBytes(cs.seqn),ContentTypeBytes(ct),
                               Compressed(cs.compression,f)) =>
                    KHashSays(cs.mk,mb) 
*)

(* Receiving messages *)
(*
theorem !cs',mb. RecvConnState(cs') /\ MACSays(cs'.mk,mb) /\
                 (cs'.protocol_version = TLS_1p0 \/ cs'.protocol_version = TLS_1p1 \/
                  cs'.protocol_version = TLS_1p2) =>
                 (?cs,ct,f. SendConnState(cs) /\ cs.dir = cs'.dir /\
		  FragmentSend(cs,ct,f) /\
                  MACBytes(mb,SequenceNumberBytes(cs.seqn),ContentTypeBytes(ct),
                           ProtocolVersionBytes(cs.protocol_version),Compressed(cs.compression,f)))

ask !cs,mb,ct,d. RecvConnState(cs) /\ MACSays(cs.mk,mb) /\
                (cs.protocol_version = TLS_1p0 \/ cs.protocol_version = TLS_1p1 \/
                 cs.protocol_version = TLS_1p2)  /\
                MACBytes(mb,SequenceNumberBytes(cs.seqn),ContentTypeBytes(ct),
                         ProtocolVersionBytes(cs.protocol_version),d) => 
            (?cs',f. SendConnState(cs') /\ cs'.dir = cs.dir /\
	           FragmentSend(cs',ct,f) /\ d = Compressed(cs'.compression,f) /\
                   cs'.protocol_version = cs.protocol_version /\
                   cs'.seqn = cs.seqn)


theorem !cs',mb. RecvConnState(cs') /\ cs'.protocol_version = SSL_3p0 /\ KHashSays(cs'.mk,mb) =>
              (?cs,ct,f. SendConnState(cs) /\ cs.dir = cs'.dir /\
	                 FragmentSend(cs,ct,f) /\
                         cs.protocol_version = SSL_3p0 /\
                         KHashBytes(mb,SequenceNumberBytes(cs.seqn),ContentTypeBytes(ct),
                                    Compressed(cs.compression,f)))

ask !cs,mb,ct,d. RecvConnState(cs) /\ cs.protocol_version = SSL_3p0  /\ KHashSays(cs.mk,mb) /\
                 KHashBytes(mb,SequenceNumberBytes(cs.seqn),ContentTypeBytes(ct),d) =>
            (?cs',f. SendConnState(cs') /\ cs'.dir = cs.dir /\
	           FragmentSend(cs',ct,f) /\ d = Compressed(cs'.compression,f) /\
                   cs'.protocol_version = SSL_3p0 /\
                   cs'.seqn = cs.seqn)

*)


(* Updates *)

definition !cs. IncSeqNum(cs) = {rec_info = cs.rec_info;
			  dir = cs.dir;
			  net_conn = cs.net_conn;
			  compression = cs.compression;
			  protocol_version = cs.protocol_version;
			  cipher_state = cs.cipher_state;
			  mk = cs.mk;
			  seqn = cs.seqn + 1;
			  sparams = cs.sparams}

ask !cs. SendConnState(cs) => SendConnState(IncSeqNum(cs))
ask !cs. RecvConnState(cs) => RecvConnState(IncSeqNum(cs))

definition !cs,iv'. (?k,iv. cs.cipher_state = BlockCipherState(k,iv) /\
	            UpdateIV(cs,iv') = { rec_info = cs.rec_info;
		     		    dir = cs.dir;
				    net_conn = cs.net_conn;
		                    compression = cs.compression;
		                    protocol_version = cs.protocol_version;
			            cipher_state = BlockCipherState(k,iv');
			            mk = cs.mk;
			            seqn = cs.seqn;
			            sparams = cs.sparams}) \/
                ((!k,iv. cs.cipher_state <> BlockCipherState(k,iv)) /\
                    UpdateIV(cs,iv') = cs)


ask !cs,iv. cs.cipher_state = StreamCipherState => UpdateIV(cs,iv) = cs

(* We seem to need the folliwing for Z3 (existential incompleteness) *)
theorem !cs. cs.cipher_state = StreamCipherState => (?iv. UpdateIV(cs,iv) = cs)

ask !cs,k,iv,iv'. cs.cipher_state = BlockCipherState(k,iv) =>
                    UpdateIV(cs,iv') = {rec_info = cs.rec_info;
		                    dir = cs.dir;
		    		    net_conn = cs.net_conn;
		                    compression = cs.compression;
		                    protocol_version = cs.protocol_version;
			            cipher_state = BlockCipherState(k,iv');
			            mk = cs.mk;
			            seqn = cs.seqn;
			            sparams = cs.sparams}


ask !cs,iv. cs.cipher_state = StreamCipherState /\
               SendConnState(cs) => SendConnState(UpdateIV(cs,iv))

ask !cs,k,iv,iv'. cs.cipher_state = BlockCipherState(k,iv) /\
                  SendConnState(cs) /\
                  ((cs.protocol_version = TLS_1p1 \/ 
                    cs.protocol_version = TLS_1p2) => Pub(iv')) =>
                    SendConnState(UpdateIV(cs,iv'))

ask !cs,iv. cs.cipher_state = StreamCipherState /\
               RecvConnState(cs) => RecvConnState(UpdateIV(cs,iv))

ask !cs,k,iv,iv'. cs.cipher_state = BlockCipherState(k,iv) /\
                  RecvConnState(cs) /\
                  ((cs.protocol_version = TLS_1p1 \/ 
                    cs.protocol_version = TLS_1p2) => Pub(iv')) =>
                    RecvConnState(UpdateIV(cs,iv'))

definition !cs,pv. UpdatePV(cs,pv) = {
   			rec_info = cs.rec_info;
			dir = cs.dir;
			net_conn = cs.net_conn;
			compression = cs.compression;
			protocol_version = pv;
			cipher_state = cs.cipher_state;
			mk = cs.mk;
			seqn = cs.seqn;
			sparams = cs.sparams}

(*
ask !cs. cs.protocol_version <> Unknown => cs = UpdatePV(cs,cs.protocol_version)
*)

(* We seem to need the folliwing for Z3 (existential incompleteness) *)
theorem !cs. cs.protocol_version <> UnknownPV => (?pv. cs = UpdatePV(cs,pv))

ask !cs,pv. ((cs.protocol_version = UnknownPV /\ pv <> UnknownPV ) \/
             (cs.protocol_version <> UnknownPV  /\ cs.protocol_version = pv)) /\
              SendConnState(cs) => SendConnState(UpdatePV(cs,pv))

ask !cs,pv. cs.protocol_version = UnknownPV /\ pv <> UnknownPV /\
              RecvConnState(cs) => RecvConnState(UpdatePV(cs,pv))

ask !cs,pv. cs.protocol_version <> UnknownPV  /\ cs.protocol_version = pv /\
              RecvConnState(cs) => RecvConnState(UpdatePV(cs,pv))

definition !cs,ccs,dir.
	 UpdateCS(cs,ccs,dir) = 
		    {rec_info = ccs.ccs_info;
		    dir = dir;
		    net_conn = cs.net_conn;
		    compression = ccs.ccs_comp;
		    protocol_version = ccs.ccs_pv;
		    cipher_state = ccs.ccs_ciphstate;
		    mk = ccs.ccs_mkey;
		    seqn = 0;
		    sparams = ccs.ccs_sparams
		    }

ask !cs. NonNullCipherSettings(CCSData(cs)) /\ cs.dir = OutDir(cs.rec_info) => 
         SendConnState(cs)

ask !cs,ccs,dir,cs'.
            NonNullCipherSettings(ccs) /\ 
            dir = OutDir(ccs.ccs_info) /\
            cs' = UpdateCS(cs,ccs,dir) => 
            	SendConnState(cs')

ask !cs,cs',dir.
            NonNullCipherSettings(CCSDataOtherRole(cs')) /\ 
            dir = InDir(cs'.rec_info) =>
                RecvConnState(UpdateCS(cs,CCSData(cs'),dir))

(* From InitConnState to {Send,Recv}ConnState *)

ask !cs,ns,info,pv. InitConnState(cs,ns,info,InDir(info),pv) /\ pv = UnknownPV => RecvConnState(cs)
ask !cs,ns,info,pv. InitConnState(cs,ns,info,OutDir(info),pv) /\ pv <> UnknownPV => SendConnState(cs)


(* ask !cs,d. SendConnState(cs) /\ (cs.sparams.bulk_cipher_algorithm = BCA_null => Pub(d)) => false *)

ask !cs,pv,cs'. not ((cs.protocol_version <> UnknownPV /\ pv <> cs.protocol_version) \/ pv = UnknownPV) /\
            cs' = UpdatePV(cs,pv) =>
                (cs'.rec_info = cs.rec_info /\ cs'.dir = cs.dir /\ cs'.mk = cs.mk  /\ cs'.protocol_version = pv /\ cs'.seqn = cs.seqn /\ cs'.sparams = cs.sparams)
ask !cs. RecvConnState(cs) => (cs.cipher_state = StreamCipherState \/ (?k,iv. cs.cipher_state = BlockCipherState(k,iv)))

ask !cs,iv,cs'. RecvConnState(cs)  /\ cs' = UpdateIV(cs,iv) => 
                (cs'.rec_info = cs.rec_info /\ cs'.dir = cs.dir /\ cs'.mk = cs.mk  /\ cs'.protocol_version = cs.protocol_version /\ cs'.seqn = cs.seqn /\ cs'.sparams = cs.sparams)
