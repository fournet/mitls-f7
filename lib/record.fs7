module Record

open Bytes
open Error
open TLSInfo
open TLSKey
open TLSFragment
open Formats
open CipherSuites
open AEAD

type (;ki:KeyInfo) ConnectionState = {
  key: (;ki) recordKey;
  iv3: (;ki) ENCKey.iv3;
  seqn: int; 
}

type (;ki:KeyInfo) sendState = (;ki) ConnectionState 
type (;ki:KeyInfo) recvState = (;ki) ConnectionState

private val incN: ki:KeyInfo -> s:(;ki)ConnectionState ->
	s':(;ki)ConnectionState{s'.seqn = s.seqn+1}

val initConnState: ki:KeyInfo -> (;ki) ccs_data -> 
                   cs:(;ki) ConnectionState{cs.seqn = 0}

private assume !ki,tlen,ct,ad.
	ADofID(ki,tlen,ct,ad) <=>
		(?seqn. (ki.sinfo.protocol_version = SSL_3p0 /\
		  ad = IntBytes(8,seqn) @| CTBytes(ct)) \/
		  ad = IntBytes(8,seqn) @| CTBytes(ct) @| VersionBytes(ki.sinfo.protocol_version))

private val makeAD: ki:KeyInfo -> tlen:int ->
	(;ki)ConnectionState -> ct:ContentType ->
	ad:addData{ADofID(ki,tlen,ct,ad)}

private val makePacket: ContentType -> ProtocolVersion -> bytes -> bytes

val headerLength: b:bytes{Length(b) = 5} -> int

private val parseHeader: b:bytes{Length(b) = 5} -> (ContentType * ProtocolVersion * int) Result

// FIXME: Remove next assume!
// private assume !ki,tlen,t. MAC.Msg(ki,tlen,t)

val recordPacketOut: ki:KeyInfo -> 
                     ss:(;ki) sendState -> 
                     tlen:int -> ct:ContentType -> 
                     (;ki,tlen,ct) TLSFragment.fragment -> 
                     (ss':(;ki) sendState *
		      wire:bytes){ss'.seqn = ss.seqn+1}
 
val recordPacketIn : ki:KeyInfo -> 
                     rs:(;ki) recvState -> 
                     wire:bytes{Length(wire) >= 5} -> 
                     ((rs':(;ki)recvState * 
                         ct:ContentType * pv:ProtocolVersion *
                         tlen:int * 
                         (;ki,tlen,ct) TLSFragment.fragment){rs'.seqn=rs.seqn+1} ) Result

