module Record

open Bytes
open Error
open TLSInfo
open DataStream
open TLSFragment
open Formats
open CipherSuites
open StatefulAEAD

private type (;ki:epoch) ConnectionState =
	| NullState
	| SomeState of h:(;ki)TLSFragment.history * st:(;ki)StatefulAEAD.state{h = Multiplexed(ki,st.history)}
                                                                             

function val History: ki:epoch * (;ki) ConnectionState -> 'a
private assume !ki,h,s. History(ki,SomeState(h,s)) = h
private assume !ki,h,s. History(ki,NullState) = h <=> EmptyHistory(ki,h)
private assume !ki. EmptyHistory(ki,History(ki,NullState))
private assume !ki,ki',h,h'. EmptyHistory(ki,h) /\ EmptyHistory(ki',h') => h = h'

type (;ki:epoch) sendState = (;ki) ConnectionState 
type (;ki:epoch) recvState = (;ki) ConnectionState

val initConnState: ki:epoch -> state:(;ki) StatefulAEAD.state{StatefulPlain.EmptyHistory(ki,state.history)} -> cs:(;ki) ConnectionState{EmptyHistory(ki,History(ki,cs))}
val nullConnState: ki:epoch -> cs:(;ki) ConnectionState{EmptyHistory(ki,History(ki,cs))}

private val makePacket: ContentType -> ProtocolVersion -> bytes -> bytes

val headerLength: b:bytes{Length(b) = 5} -> (n:nat{n>0 /\ n <= DataStream.max_TLSCipher_fragment_length}) Result

private val parseHeader: b:bytes{Length(b) = 5} ->
	((ContentType * ProtocolVersion * n:nat){n>0 /\ n <= DataStream.max_TLSCipher_fragment_length}) Result

val recordPacketOut: ki:epoch -> 
                     ss:(;ki) sendState -> pv:ProtocolVersion ->
                     rg:DataStream.range -> ct:ContentType -> 
                     f:(;ki,ct,History(ki,ss),rg) TLSFragment.fragment ->
                     (ss':(;ki) sendState * wire:bytes){
						Auth(ki) => (History(ki,ss') = TLSFragment.ExtendHistory(ki,ct,History(ki,ss),rg,TLSFragment.TLSContents(f)))}
 
val recordPacketIn : ki:epoch ->
                     rs:(;ki) recvState -> 
                     wire:bytes{Length(wire) >= 5} -> 
                     res:(rs':(;ki)recvState *
                        ct:ContentType * pv:ProtocolVersion *
                        rg:range * 
                        f:(;ki,ct,History(ki,rs),rg) TLSFragment.fragment) Result{
                       !rs',ct,rg,f. (res = Correct ((rs',ct,rg,f)) /\ Auth(ki)) => 
                         (History(ki,rs') = TLSFragment.ExtendHistory(ki,ct,History(ki,rs),rg,TLSFragment.TLSContents(f)))}



val history: ki:epoch -> s:(;ki) ConnectionState ->
	h:(;ki)TLSFragment.history{h=History(ki,s)}

val historyStream: e:epoch -> st:(;e) ConnectionState -> 
  ct:Formats.ContentType -> s:(;e)stream{s=HistoryStream(e,ct,History(e,st))}
	
