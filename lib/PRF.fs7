module PRF

(* PRFs keyed by master secrets, both for key derivation and verifyData *)

open Bytes
open TLSInfo
open StatefulLHAE

type repr = (;48)lbytes
private type (;si:SessionInfo) masterSecret = {bytes: repr}

function val Epochs: 'a -> 'b
private definition !ci,r,e_in,e_out.
	(ci = {role=Client;id_rand=r;id_in=e_in;id_out=e_out} /\
	 Epochs(ci) = (ci.id_in,ci.id_out) ) \/
	(ci = {role=Server;id_rand=r;id_in=e_in;id_out=e_out} /\
	 Epochs(ci) = (ci.id_out,ci.id_in) )

// AuthSI is defined in TLSInfo
val sample: si:SessionInfo                            -> (;si)masterSecret
val coerce: si:SessionInfo{not SafeHS_SI(si)} -> repr -> (;si)masterSecret

// Master secrets are used to derive key materials. 
// Compared with standard key derivation,
// - the label is hardcoded & implicit; 
// - the seed (crandom @| srandom) is retrieved from the epoch

val keyGen: ci:ConnectionInfo -> (;EpochSI(ci.id_out))masterSecret -> 
  ( w:(;ci.id_out)StatefulLHAE.writer * 
    r:(;ci.id_in) StatefulLHAE.reader ) 
  { StatefulPlain.EmptyHistory(ci.id_out,w.history) /\
    StatefulPlain.EmptyHistory(ci.id_in,r.history)}

private function val Fst: 'a -> 'b
private function val Snd: 'a -> 'b
private assume !e1,e2. Fst((e1,e2)) = e1
private assume !e1,e2. Snd((e1,e2)) = e1

private val log:  (ems:(e12:(epoch * epoch)  * (;Fst(e12))masterSecret) * 
                   ((;Fst(Fst(ems)),ReaderState)state * 
                    (;Snd(Fst(ems)),WriterState)state)) list ref 
private val finish_log: (SessionInfo * bytes * bytes) list ref 

(* VerifyData should be about epochs not sessions *)
// Master secrets are also used to generate and check verifyData tags,
// providing conditional authentication of the (abstract) VerifyData predicate.

predicate VerifyData of epoch * Role * bytes

val makeVerifyData: e:succEpoch -> r:Role -> (;EpochSI(e)) masterSecret ->
                   log:bytes{VerifyData(e,r,log)} -> 
                   bytes (* length depends on cs, 12 by default *)

val checkVerifyData: e:succEpoch -> r:Role -> (;EpochSI(e)) masterSecret ->
				   log:bytes (* the log *) ->
				   tag:bytes (* the expected value *) ->
				   b:bool{(b = true /\ SafeHS(e)) => VerifyData(e,r,log)}
				   // SafeHS(e) => PRF(pv,MacAlg(e))

val ssl_certificate_verify: si:SessionInfo -> (;si)masterSecret -> TLSConstants.sigAlg -> bytes -> bytes

