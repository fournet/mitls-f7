module PRF

// This module implements the PRFs keyed by master secrets, 
// for two purposes: MACing the verifyData and deriving the connection keys. 
// (CRE independently implements extraction.
// TLS uses the same hash function based techniques for this, 
// i.e. PRFs keyed by pre master secrets.)

// CF We currently perform several successive steps with a single #ideal
// CF - a crypto-agile PRF assumption on kdf + verifyData 
// CF - a lossless "reverse inlining" of StAE.GEN (at consistent CSRs)
// CF - a reduction from PRF to INT-CMA, with a loss due to tag collisions only. 
// CF We may consider splitting this file accordingly. 
 
open Bytes
open TLSConstants
open TLSInfo
open StatefulLHAE

// Master secrets are used to derive key materials. 
// Compared with standard (non-tls) key derivation,
// - the label is hardcoded & implicit; 
// - the seed (crandom @| srandom) is retrieved from the epoch
// MK: we use the concept of seed in very confusing ways. It appears in the RFC, 
// MK: and I propose to continue using it in TLSPRF in the same way. 
// MK: here (crandom @| srandom) is more like a context which guarantees that
// MK: we do not generate the same keys for different sessions.
// MK: in CRE we may indeed use seeds as used in the theory of extractors

type repr = (;48)lbytes
//#begin-abstraction

(* TODO 
We currently use a loose prfAlg. 
we may migrate prfAlg to a tigher enumeration, as outlined below
// We need descriptors for the algorithm keyed by PMS and MS (named "PRF" in TLS)
// Given pv and cs, and except for SSL3, 
// the same algorithm is used for extraction, key derivation, and verifyData
// TODO migrate to TLSPRF? adapt the code there
// TODO write 3x spec & function from pv,cs to prfAlg
type prfAlg = // can't be folded back to the sums in TLSConstants; we need to use it in TLSPRF too. 
  | PRF_TLS_1p2 of macAlg  // typically SHA256 but may depend on CS
  | PRF_TLS_1p01           // MD5 xor SHA1
  | PRF_SSL3_nested        // MD5(SHA1(...)) for extraction and keygen
  | PRF_SSL3_concat        // MD5 @| SHA1    for VerifyData tags
*)

//CF relocate, e.g. to TLSInfo?
function val PrfAlg: SessionInfo -> prfAlg
definition !si,pv,cs. (pv,cs)=PrfAlg(si) <=> pv = si.protocol_version /\ cs=si.cipher_suite
val prfAlg: si:SessionInfo -> pa:prfAlg {pa=PrfAlg(si)}


// Precise index for master secrets is a function of session info (involving pmsdata decryption)
// CF We cannot use just csr, because of MiTM forwarding honest nonces
type msIndex =        // We record the parameters used to derive this MS: 
  pms   : pmsId *     // the pms and its indexes  
  csr   : csrands *   // the nonces  
  creAlg: prfAlg      // the PMS-PRF algorithm
   
function val MsI: SessionInfo -> msIndex
private definition !si. MsI(si) = (si.pmsId, CSRands(si), PrfAlg(si)) 
val msi: si:SessionInfo -> i:msIndex { i = MsI(si) }

// CF safety of the MS (not necessarily its usage). Not refined yet
// MK rename to safeVD
val safeMS_msIndex: msIndex -> bool

private type (;i:msIndex) ms = {bytes: repr}

// This index additionally records the *local* session info.
type (;si:SessionInfo) masterSecret = (;MsI(si)) ms

//#end-abstraction

// We have two notions of conditional safety (logically defined in TLSInfo.fs7)
// SafeMS_SI for Finished messages, when the pms is ideal and hashAlg is strong
// SafeHS_SI for Key derivation,    additionally requiring agreement on committed parameters.

// Ideally, we maintain two logs
// - all authentic Finished messages so far, to filter out forgeries in their "MAC verify". 
// - all safe connection keys generated so far, to share them with the second, matching ideal key derivation.


(** Master secrets are either ideally sampled or concretely derived & coerced *) 

private val leak: si:SessionInfo -> (;si) masterSecret -> repr
val sample: si:SessionInfo -> pms:PMS.pms -> (;si)masterSecret
//#begin-coerce
//the precondition of coerce excludes both idealizations.
val coerce: si:SessionInfo {not SafeMS_SI(si)} -> PMS.pms -> repr -> (;si)masterSecret 
//#end-coerce


(** Key derivation **) 

//private val clientWriter: r:Role -> rw:rw {(r = Client /\ rw = Writer) \/ (r = Server /\ rw = Reader)}  
//private val clientReader: r:Role -> rw:rw {(r = Client /\ rw = Reader) \/ (r = Server /\ rw = Writer)}  

//CF not sure the refinement is right, and why it was not on real_keyGen. Commenting out for now
//MK It's probably right. I removed it from real_keyGen to get more meaningful typechecking errors during de bugging.
//MK Was just copied over from keyGen. Should add it back.
type (;ci:ConnectionInfo) derived =  
  ( r:(;ci.id_in) StatefulLHAE.reader * w:(;ci.id_out)StatefulLHAE.writer ) 
//  { StatefulLHAE.History(ci.id_out,Reader,r) = StatefulPlain.EmptyHistory(ci.id_in) /\
//	StatefulLHAE.History(ci.id_out,Writer,w) = StatefulPlain.EmptyHistory(ci.id_out) }

private val real_keyGen: 
  ci:ConnectionInfo{
      EpochSI(ci.id_in)=EpochSI(ci.id_out) (* needed as we compute on id_in only *) /\ 
      IsSuccEpoch(ci.id_in) /\ IsSuccEpoch(ci.id_out) /\ 
	  not Auth(ci.id_in) /\ not Auth(ci.id_out) (* needed to coerce to StatefulLHAE *)
	  } ->  
  (;EpochSI(ci.id_in))masterSecret -> (;ci) derived 

// TODO we need to reindex StatefulLHAE.
val ci_aeAlg: ConnectionInfo -> aeAlg

// USAGE RESTRICTION:
// For each CSR, 
// - the server linearly calls "keyCommit csr a" then "keyGenServer csr a" ...
// - the client linearly calls "keyGenClient csr a" 
// - an ideal state machine (below) keeps track of both, to condition KDF idealization.
// 
// The state machine has an implicit Init state as the csr has not been used yet by any
// honest client or server, and otherwise records its state in a table indexed by csr. 
// Generating a fresh CR or a SR guarantees that we are initially in that state
//
// Note that we use CR @| SR, rather than SR @| CR as in the raw KDF call. 

// Calls to keyCommit and keyGenClient are treated as internal events of PRF. 
// SafeKDF specifically enables us to assume consistent algorithms for StAE.
// (otherwise we would need some custom joint/cross ciphersuite/agile assumptions for StAE)
// 
// predicate val SafeKDF: csr -> bool
// definition SafeKDF(csr) <=> ?pv,cs. KeyCommit(csr,pv,cs) /\ KeyGenClient(csr,pv,cs)  
// MK the above is deprecated? SafeKDF should be defined on msIndex

type event = Waste of ConnectionInfo // with a csr in the Wasted state
private theorem !ci. Waste(ci) => ((not Auth(ci.id_in)) /\ (not Auth(ci.id_out))) 

type (;csr: csrands) state =
  | Init
  | Committed of aeAlg
  // The server has committed to using at most this algorithmn with this csr.
  // --------> 
  | Derived of aeAlg * msIndex * ci:ConnectionInfo * (;ci) derived
  // the client has ideally derived keys for both roles,
  // with the same algorithm, recording the keys for the server. 
  // --only-->
  | Done 
  // the server has also derived keys (retrieving those recorded, or generating others).
  // or he may have failed because of an aeAlg mismatch.
  // MK what do you mean with "failed because of aeAlg msmatch?"
  // No action allowed from this point. 

  // In all other cases, we reach a stable state such that we never idealize. 
  // We won't have SafeHS for this csr. 
  | Wasted


type kdentry = csr:csrands * (;csr) state 
val kdlog : kdentry list ref  
val read: csr:csrands -> kdentry list -> (;csr) state 
val update: csr:csrands -> (;csr) state -> kdentry  list -> kdentry list  

// Ideally, the server commits to using at most 
// (an extension of) this si for keyGen with matching (si.cr,si.sr)
// MK i.) should talk abut aeAlg, ii.) do we really mean si.init_crand and si.init_srand here
// MK and not epochCSRands? 
// We could enforce commitments by adding a post-condition to keyCommit  
// and a matching pre-condition to the server-side keyGen.

val keyCommit: csrands -> aeAlg -> unit 

val keyGenClient: 
  ci:ConnectionInfo{
      EpochSI(ci.id_in)=EpochSI(ci.id_out) /\ 
      IsSuccEpoch(ci.id_in) /\ IsSuccEpoch(ci.id_out)} -> 
  (;EpochSI(ci.id_out))masterSecret -> (;ci) derived   
val keyGenServer: 
  ci:ConnectionInfo{
      EpochSI(ci.id_in)=EpochSI(ci.id_out) /\ 
      IsSuccEpoch(ci.id_in) /\ IsSuccEpoch(ci.id_out)} -> 
  (;EpochSI(ci.id_out))masterSecret -> (;ci) derived



(* CF
// --- summary of our discussion on Apr 29, towards typechecking the HS.

// re: session
definition HonestMS( (pms, csr, creAlg) as msi ) <=>
  HonestPMS(pms) /\ StrongCRE(creAlg) // joint assumption  

// re: connection
// this predicate controls StAE idealization
// (relative to StAE's algorithmic strength)
// it is ideally used much before it can be proved as the HS completes.

definition SafeHS(e) <=> 
     SafeKDF(e.csr "the connection's csr") /\ //MK I woud prefer a different name for this predicate
     StrongKDF(e.kdfAlg) /\ 
     HonestMS(MsI(e))

// In HS, we have 
// - KeyGenClient  (e.csr, e.pv, e.cs) is a precondition to the event ClientSentCCS(e)
// - KeyCommit(e.csr, e.pv, e.cs) is a precondition to the event ServerSentCCS(e)
// - HonestMS /\ StrongVD are sufficient to guarantee 
//   matching ClientSentCCS(e) and ServerSentCCS(e), hence getting 
//   (1) SafeKDF, and 
//   (2) e is the only wide index associated with StAEIndex(e)       
//
// This enables us to prove Complete, roughly as currently defined:
//   Complete <=> (HonestPMS /\ StrongHS => SafeHS)
*)



(** VerifyData authenticator in Finished messages **)

// Master secrets are also used to generate and check verifyData tags,
// providing conditional authentication of the (abstract) VerifyData predicate.

// We specify it as we do for MACs,
// whereas we have a stronger PRF assumption.
// TODO reduction from joint MAC & KDF to PRF. 

// Some verbatim handshake message log as text...
// MACed into tags (with a fixed, irrelevant length) 

type text = bytes
type tag = bytes

// Abstract predicate authenticated by the Finished messages.
// (privately defined in Handshake.fs7)
//CF we used to index it by epoch, then by SessionInfo, now by MsI(si) 
predicate VerifyData of msIndex * Role * text

// role & text are jointly authenticated
type entry = i:msIndex * r:Role * t:text {VerifyData(i,r,t)}
private val log: entry list ref
private val mem: i:msIndex -> r:Role -> t:text -> entry list -> b:bool{ b=true => VerifyData(i,r,t) }
//private val cons: si:SessionInfo -> tag -> r:Role -> t:text {VerifyData(si,r,t)} -> entry list -> entry list

private val verifyData: si:SessionInfo -> (;si) masterSecret -> r:Role -> t:text -> tag 

// MACing 
val makeVerifyData: 
  si:SessionInfo -> (;si) masterSecret -> 
  r:Role -> t:text{VerifyData(MsI(si),r,t)} -> 
  tag (* length depends on cs, 12 by default *)

// MAC verifying 
val checkVerifyData: 
  si:SessionInfo -> (;si) masterSecret ->
  r:Role -> t:text -> tag:tag (* the expected value *) ->
  b:bool{(b = true /\ SafeMS_SI(si)) => VerifyData(MsI(si),r,t)} 
  

(** ad hoc SSL3-only function; untrusted. **) 

//CF we need to exclude calls to this function when SafeHS_SI(si)!
val ssl_certificate_verify: 
  si:SessionInfo -> (;si)masterSecret ->
  TLSConstants.sigAlg -> bytes -> bytes


//CF =============================== only comments below

//private val epochs:ConnectionInfo -> epoch * epoch

(* MK !! causes logical inconsistency
function val Epochs: 'a -> 'b
private definition !ci,r,e_in,e_out.
	(ci = {role=Client;id_rand=r;id_in=e_in;id_out=e_out} /\
	 Epochs(ci) = (ci.id_in,ci.id_out) ) \/
	(ci = {role=Server;id_rand=r;id_in=e_in;id_out=e_out} /\
	 Epochs(ci) = (ci.id_out,ci.id_in) )
*)
//MK ask !si, si'. SafeHS_SI(si) /\ SafeHS_SI(si') /\ si.csrands=si.csrands => CS(si)=CS(si')


(* CF
// ask from LHAE.fs7 repeated here to help Z3 type real_key_Gen; apparently not needed anymore
private ask !ki,si,enc,mac. 
     TLSConstants.CipherSuiteAuthEncAlg(EpochSI(ki).cipher_suite,EpochSI(ki).protocol_version) = TLSConstants.MACOnly(mac) 
  => LHAE.KeySize(ki) = TLSConstants.MacKeySize(mac)

private ask !cs,pv,mac. 
     CipherSuiteAuthEncAlg(cs,pv) = MACOnly(mac) 
  => KeyExtensionLength(pv,cs) = MacKeySize(mac)+MacKeySize(mac)
private ask !cs,pv,mac. 
     CipherSuiteAuthEncAlg(cs,pv) = MACOnly(mac) 
  => LHAE.KeySize_AEAlg(MACOnly(mac)) = TLSConstants.MacKeySize(mac)
private ask !ki,mac. 
     CipherSuiteAuthEncAlg(EpochSI(ki).cipher_suite,EpochSI(ki).protocol_version) = MACOnly(mac) 
  => LHAE.KeySize(ki) = TLSConstants.MacKeySize(mac)
*)
