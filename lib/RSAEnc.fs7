module RSAEnc

// RSA asymmetric encryption & decryption, used for PMS
// we currently exclude RSA keys used both for signing and decryption

open Bytes
open Error
open RSA // Key definitions
open RSAPlain

// For concrete security, see also 
// On the Security of RSA Encryption in TLS
// Jakob Jonsson and Burton S. Kaliski Jr.
// http://www.iacr.org/archive/crypto2002/24420127/24420127.pdf   

val encrypt: pk -> si:SessionInfo -> (;si) pms -> bytes 
// val decrypt: dk -> si:SessionInfo -> bytes -> (;si) pms
// TLS specific, timing-attack-resistant variant
val decrypt_PMS: dk ->
			si:SessionInfo -> 
            cv:CipherSuites.ProtocolVersion (* highest client version, as above *) ->
            bool -> (* flag whether we should check protocol version in old TLS versions *)
            bytes -> (;si)pms (* No Result type: in case of error, we return a fresh random PMS *)



/// Some draft assumption discussed with Markulf on 13/9/12

// AP: Commenting out so we can still typecheck the rest of the code...

//    let sk, pk = keyGen() (* sk is private *) 
//    
//    let compliantClient v Cr Sr = 
//      (* check that Cr is used at most once *)
//      let pms  = random 46
//      let pms0 = random 46
//      log := (pms0,pms)::!log
//      encrypt pk (v @| if b then pms else pms0),
//      prf (v, pms, Cr, Sr)
//    
//    let decryptRO v Cr Sr =
//      (* check that Sr is used at most once *)
//      let _, pms0 = decrypt sk
//      let pms = try assoc !log pms0 with not_found -> pms0
//      prf (v, pms, Cr, Sr)
//    
//    // The adversary get pk, compliantClient, decryptRO, and prf. Its goal is to guess b. 
//    
//    // when b = 0, we have a simplification of concrete TLS
//    // when b = 1, the protocol is parametric in "compliant" PMSs, so we get good session keys 
//    
//    /// Hopefully we can reduce it to RSA with an extra oracle:
//    
//    let ptxt plain cipher = (decrypt sk cipher = plain) (* possibly after erasing some bytes *)
//    
//    // I am puzzled that we do not use the cipher-integrity guarantee provided by the ClientFinished check
//    // informally, the adversary would need to extract the pms to forge a Finished for any related ciphertext  

