module PRFs

open Bytes
open Formats
open TLSInfo
open RSA
open Error

(****** MS ******) 

(** From PMS to MS *) 

type msRepr = b:bytes{ Length(b) = 48 }
private type (;si:SessionInfo) masterSecret = msRepr  

(* computes the MS from the PMS, some constant label, and the (crandom @| srandom) from si *)

val PRFsmoothRSA:
    si:SessionInfo -> 
    pms: (;si) RSAPlain.pms ->
    (;si) masterSecret 

val PRFsmoothDH:
    si:SessionInfo ->
	p: DH.p -> g: (;p) DH.elt -> gx: (;p) DH.elt -> gy: (;p) DH.elt -> 
	pms: (p,g,gx,gy) DH.pms ->
	(;si) masterSecret 

(** VerifyData MAC keyed with the master secret, relying on CMA ***)          

(* Generates verifyData for the Finished message *)

val makeVerifyData: si:SessionInfo -> r:Role -> (;si) masterSecret ->
                   bytes (* msgLog *) -> 
                   bytes (* length depends on cs, 12 by default *)

val checkVerifyData: si:SessionInfo -> r:Role -> (;si) masterSecret ->
				   bytes (* the log *) ->
				   bytes (* the expected value *) ->
				   bool


(** KDF for the connection key materials, keyed with the master secret *)

val keyGen: ci:ConnectionInfo -> (;EpochSI(ci.id_out))masterSecret -> 
  ((;ci.id_out)StatefulAEAD.writer * (;ci.id_in)StatefulAEAD.reader)
         (* No label, it's hardcoded. Of course we can make it explicit -> *)
         (* No seed (crandom @| srandom), it can be retrieved from epoch (and not SessionInfo!) -> *)

val makeTimestamp: unit -> int

// Maybe this is the wrong place? Better in Sig? Now placed here since it accesses MS bytes.
val ssl_certificate_verify: si:SessionInfo -> (;si)masterSecret -> a:Sig.alg -> (;a)Sig.skey -> Sig.text -> (;a)Sig.sigv
val ssl_certificate_verify_check: si:SessionInfo -> (;si)masterSecret -> a:Sig.alg -> (;a)Sig.vkey -> Sig.text -> (;a)Sig.sigv -> bool