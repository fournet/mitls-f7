module PRFs

open Bytes
open TLSConstants
open TLSInfo
open RSA
open Error

(****** MS ******) 

(** From PMS to MS *) 

type msRepr = b:bytes{ Length(b) = 48 }
private type (;si:SessionInfo) masterSecret = msRepr  

(* computes the MS from the PMS, some constant label, and the (crandom @| srandom) from si *)

val PRFsmoothRSA:
    si:SessionInfo -> 
    pms: (;si) RSAPlain.pms ->
    (;si) masterSecret

val PRFsmoothDHE:
    si:SessionInfo -> 
    pms: (;si) DHE.pms ->
    (;si) masterSecret 

// val PRFsmoothDH:
//     si:SessionInfo ->
// 	p: DH.p -> g: (;p) DH.elt -> gx: (;p) DH.elt -> gy: (;p) DH.elt -> 
// 	pms: (p,g,gx,gy) DH.pms ->
// 	(;si) masterSecret 

(** VerifyData MAC keyed with the master secret, relying on CMA ***)          

(* Generates verifyData for the Finished message *)

val makeVerifyData: si:SessionInfo -> r:Role -> (;si) masterSecret ->
                   bytes (* msgLog *) -> 
                   bytes (* length depends on cs, 12 by default *)

val checkVerifyData: si:SessionInfo -> r:Role -> (;si) masterSecret ->
				   bytes (* the log *) ->
				   bytes (* the expected value *) ->
				   bool


(** KDF for the connection key materials, keyed with the master secret *)

val keyGen: ci:ConnectionInfo -> (;EpochSI(ci.id_out))masterSecret -> 
  ((;ci.id_out)StatefulAEAD.writer * (;ci.id_in)StatefulAEAD.reader)
         (* No label, it's hardcoded. Of course we can make it explicit -> *)
         (* No seed (crandom @| srandom), it can be retrieved from epoch (and not SessionInfo!) -> *)

val makeTimestamp: unit -> int

// SSL 3 specific encoding function for certificate verify
val ssl_certificate_verify: si:SessionInfo -> (;si)masterSecret -> TLSConstants.sigAlg -> bytes -> bytes