module CryptoTLS

open Data
open Error_handling
open Crypto

predicate type keyedHashPreds =
  | KHashSays of key * bytes

val symkey: b:bytes -> k:key{k=SymKey(b)}
val symkeytobytes: k:key -> b:bytes{k=SymKey(b)}

val hmacsha1: k:key ->
	b:bytes{ (MKey(k) /\ MACSays(k,b)) \/ (Pub_k(k) /\ Pub(b)) } ->
	r:bytes Result{(!x. r = Correct(x) => (IsMAC(x,k,b) /\ (Pub(b) =>
        Pub(x))) ) /\
        (!y,z. r = Error(y,z) => ((y = MAC) /\ (z = Internal)))}

val hmacmd5: k:key ->
	b:bytes{ (MKey(k) /\ MACSays(k,b)) \/ (Pub_k(k) /\ Pub(b)) } ->
	r:bytes Result{(!x. r = Correct(x) => (IsMAC(x,k,b) /\ (Pub(b) =>
        Pub(x))) ) /\ (!y,z. r = Error(y,z) => ((y = MAC) /\ (z = Internal)))}

val hmacsha1Verify: k:key{MKey(k) \/ Pub_k(k)} -> b:bytes -> h:bytes ->
    r:unit Result{(!x. r = Correct (x) => (MACSays(k,b) \/ Pub_k(k))) /\
       (!y,z. r = Error(y,z) => ((y = MAC) /\ (z = Internal \/ z = CheckFailed)))}
val hmacmd5Verify: k:key{MKey(k) \/ Pub_k(k)} -> b:bytes -> h:bytes ->
    r:unit Result{(!x. r = Correct (x) => (MACSays(k,b) \/ Pub_k(k))) /\
                  (!y,z. r = Error(y,z) => ((y =  MAC) /\ (z = Internal \/ z = CheckFailed)))}

val keyedHash:
  (bytes -> res:bytes Result{(* (!x. res = Correct(x)) /\ *) (!y,z. res =
        Error(y,z) => (y = Hash /\ z = Internal))}) ->
  pad1:bytes ->
  pad2:bytes ->
  k:key ->
  b:bytes ->
          res:bytes Result{(* (!h. res = Correct(h)) /\ *) (!y,z. res = Error(y,z) =>
          (y = MAC /\ z = Internal))}
val keyedHashVerify:
  (bytes -> res:bytes Result{(* (!x. res = Correct(x)) /\ *) (!y,z. res =
        Error(y,z) => (y = Hash /\ z = Internal))}) ->
  pad1:bytes ->
  pad2:bytes ->
  k:key ->
  b:bytes ->
  h:bytes ->
  r:unit Result{(!x. r = Correct(x) => (KHashSays(k,b) \/ Pub_k(k))) /\ (!y,z. r
  = Error(y,z) => ((y = MAC) /\ (z = Internal \/ z = CheckFailed)))}

val md5: b:bytes -> r:bytes Result{(!x. r = Correct(x) => IsHash(x,b)) /\ (!y,z.
r = Error(y,z) => ((y = Hash) /\ (z = Internal)))}
val sha1: b:bytes -> r:bytes Result{(!x. r = Correct(x) => IsHash(x,b)) /\ (!y,z.
r = Error(y,z) => ((y = Hash) /\ (z = Internal)))}

val des_encrypt_wiv: k:key -> iv:bytes ->
  b:bytes{(SKey(k) /\ CanSymEncrypt(k,b)) \/ (Pub_k(k) /\ Pub(b))} -> 
  r:bytespub Result{(!e. r = Correct(e) => IsEncryption(e,k,b)) /\ (!y,z. r =
          Error(y,z) => ((y = Encryption) /\ (z = Internal)))}
val aes_encrypt_wiv: k:key -> iv:bytes ->
  b:bytes{(SKey(k) /\ CanSymEncrypt(k,b)) \/ (Pub_k(k) /\ Pub(b))} -> 
  r:bytespub Result{(!e. r = Correct(e) => IsEncryption(e,k,b)) /\ (!y,z. r =
          Error(y,z) => ((y = Encryption) /\ (z = Internal)))}

val des_decrypt_wiv: k:key{SKey(k) \/ Pub_k(k)} -> iv:bytes -> e:bytes -> 
  r:bytes Result{(!b. r = Correct(b) => ((!p. IsEncryption(e,k,p) => b = p) /\
  (Pub_k(k) => Pub(b)))) /\ (!y,z. r = Error(y,z) => ((y = Encryption) /\ (z =
          Internal)))}
val aes_decrypt_wiv: k:key{SKey(k) \/ Pub_k(k)} -> iv:bytes -> e:bytes -> 
  r:bytes Result{(!b. r = Correct(b) => ((!p. IsEncryption(e,k,p) => b = p) /\
  (Pub_k(k) => Pub(b)))) /\ (!y,z. r = Error(y,z) => ((y = Encryption) /\ (z =
          Internal)))}
