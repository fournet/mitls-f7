module AppDataStream

open TLSInfo
open Bytes
open Error
open FragCommon
open DataStream

type (;ki:KeyInfo) buffer = {
  seqn: int;
  stream: (;ki) stream;
  data: h:(;ki) stream * (r:range * (;ki,h,r) delta) option;
}

type (;ki:KeyInfo) input_buffer = (;ki) buffer
type (;ki:KeyInfo) output_buffer = (;ki) buffer

type (;ci:ConnectionInfo) app_state = {
    app_incoming: (;ci.id_in) input_buffer;
    app_outgoing: (;ci.id_out) output_buffer;
}

function val OutStream: c:ConnectionInfo * (;c) app_state -> bytes
function val InStream: c:ConnectionInfo * (;c) app_state -> bytes

function val InSequenceNo: c:ConnectionInfo * (;c) app_state -> int
function val OutSequenceNo: c:ConnectionInfo * (;c) app_state -> int

private type (;ki:KeyInfo,s:stream,r:range) fragment = (;ki,s,r) delta
type (;ki:KeyInfo) stream = (;ki) DataStream.stream

predicate EmptyStream of KeyInfo * stream
predicate ConcatStream of KeyInfo * stream * fragment * stream
val emptyStream: ki:KeyInfo -> s:(;ki)stream{EmptyStream(ki,s)}
val addFragment: ki:KeyInfo -> s:(;ki)stream -> 
                 r:DataStream.range -> f:(;ki,s,r) fragment -> 
                 s':(;ki)stream{ConcatStream(ki,s,f,s')}

(* We justify the following 'linearity' theorems by appealing to the types of the functions:
   mkFragment, readAppDataFragment, and readNonAppDataFragment which are the only locations where
   AppFragment, AppDataSequenceNo, and NonAppDataSequenceNo are assumed 

theorem !ki,tlen,seqn,b. AppDataFragment(ki,tlen,seqn,b) =>
  (seqn >= 0 /\ CompatibleLengths(ki.sinfo,Length(b),[tlen]) /\ AppDataSequenceNo(ki,seqn) /\
     (?d. ValidAppDataStream(ki,d @| b) /\
	  AppDataFragmentSequence(ki,seqn - 1,d)))
theorem !ki,seqn. AppDataSequenceNo(ki,seqn) => (not NonAppDataSequenceNo(ki,seqn))
theorem !ki,tlen,seqn,b,tlen',b'. AppDataFragment(ki,tlen,seqn,b) /\ AppDataFragment(ki,tlen',seqn,b') => (b = b' /\ tlen = tlen')
*)
// A biggish theorem, to prove by induction
//theorem !ki,seqn,d,d'. AppDataFragmentSequence(ki,seqn,d) /\ AppDataFragmentSequence(ki,seqn,d') => d = d'

(*
val fragment: ki:KeyInfo -> tlen:int -> seqn:int -> 
  b:bytes{AppDataFragment(ki,tlen,seqn,b) \/ Corrupt(ki)} -> (;ki,tlen,seqn) fragment

private val mkFragment: ki:KeyInfo -> tlen:int -> seqn:int ->
  b:bytes{Corrupt(ki) \/ (seqn >= 0 /\ AppDataSequenceNo(ki,seqn) /\ 
	    (?d. ValidAppDataStream(ki,d @| b) /\ AppDataFragmentSequence(ki,seqn-1,d)))} ->
          (;ki,tlen,seqn) fragment{AppDataFragment(ki,tlen,seqn,b)}

val repr: ki:KeyInfo -> tlen:int -> seqn:int -> (;ki,tlen,seqn) fragment -> 
          b:bytes{Corrupt(ki) \/ AppDataFragment(ki,tlen,seqn,b)}

val writeAppDataBytes: c:ConnectionInfo -> 
                       aps:(;c) app_state -> 
                       b:bytes -> ls:lengths -> 
                       aps':(;c) app_state{(InSequenceNo(c,aps),OutSequenceNo(c,aps)) = (InSequenceNo(c,aps'),OutSequenceNo(c,aps'))}

val readAppDataBytes:  c:ConnectionInfo -> 
                       aps:(;c) app_state -> 
                       (b:bytes * aps':(;c) app_state){(InSequenceNo(c,aps),OutSequenceNo(c,aps)) = (InSequenceNo(c,aps'),OutSequenceNo(c,aps'))}

val readAppDataFragment: c:ConnectionInfo -> 
                       aps:(;c) app_state -> 
                       ((tlen:int * (;c.id_out,tlen,OutSequenceNo(c,aps)) fragment * 
			   aps':(;c) app_state){(InSequenceNo(c,aps'),OutSequenceNo(c,aps')) = (InSequenceNo(c,aps),OutSequenceNo(c,aps)+1)}) option

val readNonAppDataFragment: c:ConnectionInfo -> 
                       aps:(;c) app_state -> 
                       aps':(;c) app_state{(InSequenceNo(c,aps'),OutSequenceNo(c,aps')) = (InSequenceNo(c,aps),OutSequenceNo(c,aps)+1)}

val writeAppDataFragment: c:ConnectionInfo -> 
                       aps:(;c) app_state -> 
                       tlen:int -> (;c.id_in,tlen,InSequenceNo(c,aps)) fragment ->
                       aps':(;c) app_state{(InSequenceNo(c,aps'),OutSequenceNo(c,aps')) = (InSequenceNo(c,aps)+1,OutSequenceNo(c,aps))}

val writeNonAppDataFragment: c:ConnectionInfo -> 
                       aps:(;c) app_state -> 
                       aps':(;c) app_state{(InSequenceNo(c,aps'),OutSequenceNo(c,aps')) = (InSequenceNo(c,aps)+1,OutSequenceNo(c,aps))}
   
val reIndex: oldC:ConnectionInfo -> 
             newC:ConnectionInfo{CompatibleConnections(oldC,newC)} -> 
             aps: (;oldC) app_state ->
             aps':(;newC) app_state{
	       (InSequenceNo(newC,aps'),OutSequenceNo(newC,aps')) = 
	       (InSequenceNo(oldC,aps),OutSequenceNo(oldC,aps))}


val is_incoming_empty: ci:ConnectionInfo -> aps:(;ci) app_state -> b:bool {b = true => (?s,ls,ads. aps.app_incoming = (s,ls,ads) /\ ads.data = [| |])}

val is_outgoing_empty: ci:ConnectionInfo -> aps:(;ci) app_state -> b:bool {b = true => (?s,ls,ads. aps.app_outgoing = (s,ls,ads) /\ ads.data = [| |])}


val init: c:ConnectionInfo -> aps:(;c) app_state{InSequenceNo(c,aps) = 0 /\ OutSequenceNo(c,aps) = 0}

val reset_incoming: c:ConnectionInfo -> 
  aps:(;c) app_state ->
  aps':(;c) app_state{
    (InSequenceNo(c,aps'),OutSequenceNo(c,aps')) =
    (0,OutSequenceNo(c,aps))
  }

val reset_outgoing: c:ConnectionInfo -> 
  aps:(;c) app_state ->
  aps':(;c) app_state{
    (InSequenceNo(c,aps'),OutSequenceNo(c,aps')) =
    (InSequenceNo(c,aps),0)
  }
*)
