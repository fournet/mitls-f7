module AppDataStream

open TLSInfo
open Bytes
open Error
open DataStream

type (;ki:epoch) buffer = h:(;ki) stream * (r:range * (;ki,h,r) delta) option

type (;ki:epoch) input_buffer = (;ki) buffer
type (;ki:epoch) output_buffer = (;ki) buffer

type (;ci:ConnectionInfo) app_state = {
    app_incoming: (;ci.id_in) input_buffer;
    app_outgoing: (;ci.id_out) output_buffer;
}

function val AppInStream:  ci:ConnectionInfo * (;ci)app_state -> 'a //(;ci.id_in) stream
function val AppOutStream: ci:ConnectionInfo * (;ci)app_state -> 'a //(;ci.id_out)stream
definition !ci,s,st,d. s.app_incoming = (st,d) => AppInStream(ci,s)  = st
definition !ci,s,st,d. s.app_outgoing = (st,d) => AppOutStream(ci,s) = st

function val AppInBuf:  ci:ConnectionInfo * (;ci)app_state -> 'a //(range * delta) option
function val AppOutBuf: ci:ConnectionInfo * (;ci)app_state -> 'a //(range * delta) option
definition !ci,s,st,d. s.app_incoming = (st,d) => AppInBuf(ci,s)  = d
definition !ci,s,st,d. s.app_outgoing = (st,d) => AppOutBuf(ci,s) = d

val inStream:  ci:ConnectionInfo -> s:(;ci)app_state -> st:(;ci.id_in) stream{st = AppInStream(ci,s) }
val outStream: ci:ConnectionInfo -> s:(;ci)app_state -> st:(;ci.id_out)stream{st = AppOutStream(ci,s)}

val init: ci:ConnectionInfo ->
	s:(;ci)app_state{AppInBuf(ci,s) = None /\ AppOutBuf(ci,s) = None /\
		EmptyStream(ci.id_in,AppInStream(ci,s)) /\ EmptyStream(ci.id_out,AppOutStream(ci,s))}

val writeAppData: ci:ConnectionInfo -> s:(;ci)app_state{AppOutBuf(ci,s) = None} ->
	r:range -> d:(;ci.id_out,AppOutStream(ci,s),r)delta ->
	s':(;ci)app_state{AppOutBuf(ci,s') = Some((r,d))}

val emptyOutgoingAppData: ci:ConnectionInfo -> s:(;ci)app_state ->
	((r:range * d:(;ci.id_out, AppOutStream(ci,s), r)delta) option) *
		s':(;ci)app_state{AppOutBuf(ci,s') = None}

val next_fragment: ci:ConnectionInfo -> s:(;ci)app_state ->
	((r:range * f:(;ci.id_out,r)Fragment.fragment * (;ci)app_state)
	{Auth(ci.id_out) => Fragment.Fragment(ci.id_out,AppOutStream(ci,s),r,f)}) option

val recv_fragment: ci:ConnectionInfo -> s:(;ci)app_state -> r:range ->
	f:(;ci.id_in,r)Fragment.fragment{Auth(ci.id_in) =>
		Fragment.Fragment(ci.id_in,AppInStream(ci,s),r,f)} ->
	(;ci)app_state

val readAppData: ci:ConnectionInfo -> s:(;ci)app_state ->
	((r:range * (;ci.id_in,AppInStream(ci,s),r)delta) option * s':(;ci)app_state){AppInBuf(ci,s') = None}

val reset_outgoing: ci:ConnectionInfo -> (;ci)app_state ->
	ci':ConnectionInfo{ci'.role = ci.role /\ ci'.id_in = ci.id_in} -> s':(;ci')app_state{AppOutBuf(ci',s') = None}
val reset_incoming: ci:ConnectionInfo -> (;ci)app_state ->
	ci':ConnectionInfo{ci'.role = ci.role /\ ci'.id_out = ci.id_out} -> s':(;ci')app_state{AppInBuf(ci',s') = None}