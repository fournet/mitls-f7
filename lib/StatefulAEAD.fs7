module StatefulAEAD

open TLSInfo
open Error
open StatefulPlain
open DataStream 
open Bytes

// TODO 12-02: 
// - Do we need to control the cipherlength?

private type (;ki:epoch) prestate = {
  key: (;ki) AEAD.AEADKey;
  history: (;ki)history
}

predicate State of ki:epoch * (;ki)prestate

private type (;ki:epoch) state = s:(;ki)prestate {State(ki,s)}


private definition !ki,s. State(ki,s) // KB: 21/4 Why do we need this?

type (;ki:epoch) reader = r:(;ki) state
type (;ki:epoch) writer = w:(;ki) state

val GEN: ki:epoch{Safe(ki)} -> (;ki) reader * (;ki)writer
val COERCE: ki:epoch{not Auth(ki)} -> b:bytes{Length(b)=AEAD.AEADSize(ki)} -> (;ki)state
val LEAK: ki:epoch{not Auth(ki)} -> (;ki)state -> b:bytes

val history: ki:epoch -> s:(;ki) state -> h:(;ki)history{h=s.history}

type cipher = ENC.cipher
predicate STXT of ki:epoch * (;ki)state * ad:(;ki)data * r:range * (;ki,r)Fragment.fragment * cipher
assume !ki,s,ad,r,f,c. STXT(ki,s,ad,r,f,c)
//	<=> AEAD.CTXT(ki,MakeAD(ki,s.history,ad),r,f,c)

// AP 18/4: Cannot prove STXT until we don't get precise with {S}AEADContents, which breaks abstraction

val encrypt: ki:epoch -> 
  w:(;ki) writer -> 
  ad:(;ki)data ->
  r:range ->
  f: (;ki,w.history,ad,r) fragment ->
  (w':(;ki) writer * c:cipher){STXT(ki,w,ad,r,SAEADContents(f),c)}

val decrypt: ki:epoch -> 
  rd:(;ki) reader -> 
  ad:(;ki)data ->
  c:ENC.cipher ->
  res:((;ki) reader * rg:range * (;ki,rd.history,ad,rg) fragment) Result{
	 !nrd,rg,f. res = Correct((nrd,rg,f)) => 
                (Length(c)=AEPlain.RangeCipher(ki,rg) /\
		(Safe(ki) => STXT(ki,rd,ad,rg,SAEADContents(f),c)) /\
                (Auth(ki) => STXT(ki,rd,ad,rg,SAEADContents(f),c))) }
