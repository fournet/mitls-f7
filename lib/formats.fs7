module Formats
open Bytes
open Error

type preContentType =
  | Change_cipher_spec
  | Alert
  | Handshake
  | Application_data
  | UnknownCT //CF: why do we need it?? 

(* FIXME: new version of F7 should infer this refinement automatically.
   In other places I'm assuming F7 is already updated, but here I don't delete this
   refinement until I get acknowledge that F7 is in fact updated. *)

type ContentType = ct:preContentType
  {ct = Change_cipher_spec \/ ct = Alert \/
   ct = Handshake \/ ct = Application_data \/ ct = UnknownCT}

// unnecessary? function val SeqNumB: int -> bytes
val bytes_of_seq: sn:int -> b:bytes{Length(b) = 8 /\ b = Int2Bytes(8,sn)}

//CF: let's pick better names, and maybe use length-1 arrays instead of single byte constants, e.g. 
// CTBytes: ContentType -> bytes for the logical function 
// ctBytes: ct:ContentType -> b:bytes{b=CTBytes(ct)} for the implementation

function val CTB: ContentType -> bytes
type KnownCT = ct:preContentType
	{ct = Change_cipher_spec \/ ct = Alert \/
     ct = Handshake \/ ct = Application_data}
val bytes_of_contentType: ct:KnownCT -> b:bytes{b=CTB(ct)}
// FIXME: maybe too weak, we want an exclusive or.
val contentType_of_bytes: b:bytes -> ct:ContentType{ct=UnknownCT \/ b=CTB(ct)}
val CTtoString: ContentType -> string

//CF: TODO maybe rename to vlbytes and split_vlbytes
val vlenBytes_of_bytes: vl:int -> b1:bytes ->
	b:bytes{b = Int2Bytes(vl,Length(b1)) @| b1}
val bytes_of_vlenBytes: vl:int -> b:bytes{Length(b) >= vl} ->
    ((b1:bytes * b2:bytes){b = Int2Bytes(vl,Length(b1)) @| b1 @| b2}) Result

//internal, boring:
definition CTB(Change_cipher_spec) = [|20uy|]
definition CTB(Alert) = [|21uy|]
definition CTB(Handshake) = [|22uy|]
definition CTB(Application_data) = [|23uy|]