module Formats
open Bytes

type preContentType =
  | Change_cipher_spec
  | Alert
  | Handshake
  | Application_data
  | UnknownCT

(* FIXME: new version of F7 should infer this refinement automatically.
   In other places I'm assuming F7 is already updated, but here I don't delete this
   refinement until I get acknowledge that F7 is in fact updated. *)
type ContentType = ct:preContentType{ct = Change_cipher_spec \/ ct = Alert \/
                ct = Handshake \/ ct = Application_data \/ ct = UnknownCT}

function val SeqNumB: int -> bytes
val bytes_of_seq: sn:int -> b:bytes{Length(b) = 8 /\ b = SeqNumB(sn)}

function val CTB: ContentType -> byte
val byte_of_contentType: ct:ContentType -> b:byte{b=CTB(ct)}
val contentType_of_byte: b:byte -> ct:ContentType{b=CTB(ct)}
val CTtoString: ContentType -> string

val vlenBytes_of_bytes: vl:int -> b1:bytes ->
	b:bytes{b = Int2Bytes(vl,Length(b1)) @| b1}
(* FIXME: We cannot enforce good termination of this function statically in the pre-conditions.
   This function should return a Result, because parsing might fail *)
val bytesAndRemainder_of_vlenBytesAndReminder: vl:int -> b:bytes -> (b1:bytes * b2:bytes) Result

--------- OLD ---------
val Change_cipher_spec_val : int
val Alert_val : int
val Handshake_val : int
val Application_data_val : int

type Compression =
  | Null
  | UnknownComp of int
val bytes_of_compression : Compression -> bytes
val compression_of_bytes : bytes -> Compression
type ProtocolVersionType =
  | SSL_2p0
  | SSL_3p0
  | TLS_1p0
  | TLS_1p1
  | TLS_1p2
  | UnknownPV

function type funs =
  | ContentTypeBytes of ContentType
  | ProtocolVersionBytes of ProtocolVersionType
  | SequenceNumberBytes of int

predicate type preds =
  | PrintThis
  | FailHere

assume !sn. SequenceNumberBytes(sn) = Num(sn)

//Cedric: not sure about these refinements; do we have Length(Num(i)) = 1??
//Cedric: I'd separate general libraries from TLS-specific code
val bytes_of_intpair: p:(int*int) -> b:bytes{!i,j. p = (i,j) => b = Concat(Num(i),Num(j))}
val intpair_of_bytes:  b:bytes -> (i:int*j:int){b = Concat(Num(i),Num(j))}
val bytes_of_seq: sn:int -> b:bytes{b = SequenceNumberBytes(sn)}

val SSLv2 : bytes
val SSLv3 : bytes
val TLS1p0 : bytes
val TLS1p1 : bytes
val TLS1p2 : bytes

val bytes_of_contentType : c:ContentType -> b:bytes{b = ContentTypeBytes(c)}
val contentType_of_bytes : b:bytes -> c:ContentType{b = ContentTypeBytes(c)}

val bytes_of_protocolVersionType : p:ProtocolVersionType -> b:bytes{b = ProtocolVersionBytes(p)}
val protocolVersionType_of_bytes : b:bytes -> p:ProtocolVersionType{b = ProtocolVersionBytes(p)}

//Cedric: same as role? 
type ConnectionEnd =
  | Client
  | Server
type BulkCipherAlgorithm =
  | BCA_rc4
  | BCA_des
  | BCA_aes
  | BCA_rc2
  | BCA_3des
  | BCA_des40
  | BCA_idea
  | BCA_null
type CipherType =
  | CT_stream
  | CT_block
type IsExportable = bool
type MACAlgorithm =
  | MA_md5
  | MA_sha1
  | MA_null
val get_block_cipher_size : BulkCipherAlgorithm -> int
val get_hash_size : MACAlgorithm -> int
type SecurityParameters =
  {cipher_type: CipherType;
   bulk_cipher_algorithm: BulkCipherAlgorithm;
   mac_algorithm: MACAlgorithm;}
val ssl_pad1_md5 : bytes
val ssl_pad2_md5 : bytes
val ssl_pad1_sha1 : bytes
val ssl_pad2_sha1 : bytes
val vlenBytes_of_bytes : int -> bytes -> bytes
val bytesAndRemainder_of_vlenBytesAndReminder :
  int -> bytes -> bytes * bytes

(*
assume !x:bytes. IsAppendedList(x,x::[])
assume !h:bytes, t:bytes list, tc:bytes. IsAppendedList(tc,t) => IsAppendedList(Concat(h,tc),h::t)
theorem !c,xl. IsAppendedList(c,xl) => ((?x. xl = x::[] /\ c = x) \/ (?h,t,tc. xl = h::t /\ IsAppendedList(tc,t) /\ c = Concat(h,tc)))

val appendList: xl:bytes list -> b:bytes {IsAppendedList(b,xl)} 
val splitList: b:bytes -> il:int list -> xl:bytes list {IsAppendedList(b,xl)}
*)

(*
//Cedric: let's use infix concatenation instead... 
val appendList: dl:dbytes list -> b:bytes{(?b1,b2,b3. dl = b1::b2::b3::[] /\ b = Concat(b1,Concat(b2,b3))) \/ 
					  (?b1,b2,b3,b4. dl = b1::b2::b3::b4::[] /\ b = Concat(b1,Concat(b2,Concat(b3,b4)))) \/ 
					  (?b1,b2,b3,b4,b5. dl = b1::b2::b3::b4::b5::[] /\ b = Concat(b1,Concat(b2,Concat(b3,Concat(b4,b5))))) \/ 
					  (?b1,b2,b3,b4,b5,b6. dl = b1::b2::b3::b4::b5::b6::[] /\ b = Concat(b1,Concat(b2,Concat(b3,Concat(b4,Concat(b5,b6))))))}

//Cedric: avoid? 				    
val splitList: bytes -> int list -> bytes list
*)
