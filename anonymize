#! /usr/bin/env python

import sys, os, re, codecs, StringIO as sio

# --------------------------------------------------------------------
def _noexn(f):
    try: f()
    except: pass

# --------------------------------------------------------------------
class Object(object):
    def __init__(self, **kw):
        self.__dict__.update(kw)

# --------------------------------------------------------------------
MODE_FULL    = 0x00
MODE_RELEASE = 0x01

# --------------------------------------------------------------------
def parser(mode):
    import pyparsing as p

    def internal_comment(comment):
        if mode.mode == MODE_FULL:
            return comment.strip()[0:1] != '@'
        if mode.mode == MODE_RELEASE:
            m = re.search(r'^\s*(\w+?):*\b', comment)
            return \
                m is not None and \
                    (m.group(1) == 'FIXME' or m.group(1) in mode.data)
        return False

    ml_comments = p.Regex(r'\(\*(?:[^*]*\*+)+?\)')
    ss_comments = p.Regex(r'//.*')
    ml_strings  = p.Regex(r'"(?:[^"\n\r\\]|(?:"")|(?:\\x[0-9a-fA-F]+)|(?:\\.))*"')

    def ml_comments_action(_s, _loc, tk):
        return [] if internal_comment(tk[0][2:-2]) else tk
    ml_comments.setParseAction(ml_comments_action)

    def ss_comments_action(_s, _loc, tk):
        return [] if internal_comment(tk[0][2:]) else tk
    ss_comments.setParseAction(ss_comments_action)

    return ml_comments | ss_comments | ml_strings

# --------------------------------------------------------------------
def filter_hashes(input):
    hif    = re.compile(r'^\s*#\s*if\s+(\w+)\s*$')
    helse  = re.compile(r'^\s*#\s*else\b')
    hend   = re.compile(r'^\s*#\s*endif\b')
    hashes = []
    output = []

    for line in input:
        m = None
        for i, r in enumerate([hif, helse, hend]):
            m = re.search(r, line)
            if m is not None: break

        if m is not None:
            if i == 0:
                hashes.append((m.group(1), True))
            elif i == 1:
                if hashes and hashes[-1][1]:
                    hashes[-1] = (hashes[-1][0], False)
            elif i == 2:
                if hashes:
                    hashes.pop()
        else:
            if all([not x[1] for x in hashes]):
                output.append(line)

    return output

# --------------------------------------------------------------------
def _options(args):
    from optparse import OptionParser

    modes  = 'full|release[:kw1,...,kwn]'
    parser = OptionParser(usage = '%prog <options> [filenames...]')
    
    parser.add_option("-B", None,
                      action  = "store_false",
                      dest    = "backup",
                      help    = "do NOT create a backup file",
                      default = True)
    parser.add_option("-c", None,
                      dest    = "header",
                      help    = "add header from HEADER",
                      metavar = "HEADER")
    parser.add_option("-m", None,
                      dest    = "mode",
                      help    = "set anonymisation mode [%s]" % (modes,),
                      default = 'full',
                      metavar = "MODE")

    (options, args) = parser.parse_args()

    if options.mode == 'full':
        options.mode = Object(mode = MODE_FULL, data = None)
    elif options.mode.startswith('release'):
        kws = ''.join(options.mode.split(':', 1)[1:]).split(',')
        kws = [x.strip() for x in kws]
        kws = [x for x in kws if x]
        options.mode = Object(mode = MODE_RELEASE, data = set(kws))
    else:
        parser.error('invalid mode: %s' % (options.mode,))

    return (options, args)

# --------------------------------------------------------------------
def _read_file(filename):
    contents = open(filename, 'rb').read()

    if contents.startswith(codecs.BOM_UTF8):
        return unicode(contents[len(codecs.BOM_UTF8):], 'utf-8')
    return unicode(contents, 'utf-8')

# --------------------------------------------------------------------
CRLN = '\r\n'

def _process_file(filename, options):
    output = parser(options.mode).transformString(_read_file(filename))
    output = output.splitlines()
    output = filter_hashes(output)
    output = CRLN.join(output) + CRLN
    output = re.sub('(?:\r\n){3,}', 2 * CRLN, output)
    output = re.sub('(?:\r\n)+$', CRLN, output)
    output = re.sub('^(?:\r\n)*', CRLN, output)

    if options.header:
        output = CRLN.join(options.header.splitlines()) + CRLN + output

    if options.backup:
        if os.path.exists(filename + '~'):
            os.unlink(filename + '~')
        os.rename(filename, filename + '~')
    else:
        os.unlink(filename)

    try:
        with codecs.open(filename, 'w', 'utf-8') as ostream:
            ostream.write(output)
    except:
        _noexn(lambda : os.unlink(filename))
        raise

# --------------------------------------------------------------------
def _main():
    options, filenames = _options(sys.argv[:1])

    if options.header:
        options.header = open(options.header, 'r').read().splitlines()
        options.header = [' * ' + x for x in options.header]
        options.header = ['(*'] + options.header + [' *)']
        options.header = CRLN.join(options.header)

    for filename in filenames:
        _process_file(filename, options)

# --------------------------------------------------------------------
if __name__ == '__main__':
    _main()
