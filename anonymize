#! /usr/bin/env python

import sys, os, re, codecs, StringIO as sio

# --------------------------------------------------------------------
def _noexn(f):
    try: f()
    except: pass

# --------------------------------------------------------------------
def parser():
    import pyparsing as p

    def internal_comment(comment):
        comment = comment.strip()
        if re.match(r'FIXME\b', comment):
            return True
        if re.match(r'\w+\s+:', comment):
            return True
        return False

    ml_comments = p.Regex(r'\(\*(?:[^*]*\*+)+?\)')
    ss_comments = p.Regex(r'//.*')
    ml_strings  = p.Regex(r'"(?:[^"\n\r\\]|(?:"")|(?:\\x[0-9a-fA-F]+)|(?:\\.))*"')

    def ml_comments_action(_s, _loc, tk):
        return [] if internal_comment(tk[0][2:-2]) else tk

    def ss_comments_action(_s, _loc, tk):
        return [] if internal_comment(tk[0][2:]) else tk

    ml_comments.setParseAction(ml_comments_action)
    ss_comments.setParseAction(ss_comments_action)

    return ml_comments | ss_comments | ml_strings

# --------------------------------------------------------------------
def _options(args):
    from optparse import OptionParser

    parser = OptionParser(usage = '%prog <options> [filenames...]')
    parser.add_option("-B", None,
                      action  = "store_false",
                      dest    = "backup",
                      help    = "do NOT create a backup file",
                      default = True,
                      metavar = "BACKUP")
    parser.add_option("-c", "--header",
                      dest    = "header",
                      help    = "add header from HEADER",
                      metavar = "HEADER")

    (options, args) = parser.parse_args()

    return (options, args)

# --------------------------------------------------------------------
def _read_file(filename):
    contents = open(filename, 'rb').read()

    if contents.startswith(codecs.BOM_UTF8):
        return unicode(contents[len(codecs.BOM_UTF8):], 'utf-8')
    return unicode(contents, 'utf-8')

# --------------------------------------------------------------------
CRLN = '\r\n'

def _process_file(filename, options):
    output = parser().transformString(_read_file(filename))
    output = CRLN.join(output.splitlines()) + CRLN
    output = re.sub('(?:\r\n){3,}', 2 * CRLN, output)
    output = re.sub('(?:\r\n)+$', CRLN, output)
    output = re.sub('^(?:\r\n)*', CRLN, output)

    if options.header:
        output = CRLN.join(options.header.splitlines()) + CRLN + output

    if options.backup:
        if os.path.exists(filename + '~'):
            os.unlink(filename + '~')
        os.rename(filename, filename + '~')
    else:
        os.unlink(filename)

    try:
        with codecs.open(filename, 'w', 'utf-8') as ostream:
            ostream.write(output)
    except:
        _noexn(lambda : os.unlink(filename))
        raise

# --------------------------------------------------------------------
def _main():
    options, filenames = _options(sys.argv[:1])

    if options.header:
        options.header = open(options.header, 'r').read().splitlines()
        options.header = [' * ' + x for x in options.header]
        options.header = ['(*'] + options.header + [' *)']
        options.header = CRLN.join(options.header)

    for filename in filenames:
        _process_file(filename, options)

# --------------------------------------------------------------------
if __name__ == '__main__':
    _main()
