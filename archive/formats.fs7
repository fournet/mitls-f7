module Formats
open Bytes
open Error
open TLSError

type preContentType =
  | Change_cipher_spec
  | Alert
  | Handshake
  | Application_data

(* FIXME: new version of F7 should infer this refinement automatically.
   In other places I'm assuming F7 is already updated, but here I don't delete this
   refinement until I get acknowledge that F7 is in fact updated. *)

type ContentType = ct:preContentType
  {ct = Change_cipher_spec \/ ct = Alert \/
   ct = Handshake \/ ct = Application_data}

// unnecessary? function val SeqNumB: int -> bytes
val bytes_of_seq: sn:int -> b:bytes{Length(b) = 8 /\ b = IntBytes(8,sn)}
val seq_of_bytes: b:bytes{Length(b)=8} -> sn:int{b = IntBytes(8,sn)}

//CF: let's pick better names, and maybe use length-1 arrays instead of single byte constants, e.g. 
// CTBytes: ContentType -> bytes for the logical function 
// ctBytes: ct:ContentType -> b:bytes{b=CTBytes(ct)} for the implementation

function val CTBytes: ContentType -> bytes

assume !c. Length(CTBytes(c)) = 1

private definition CTBytes(Change_cipher_spec) = [|20uy|]
private definition CTBytes(Alert)              = [|21uy|]
private definition CTBytes(Handshake)          = [|22uy|]
private definition CTBytes(Application_data)   = [|23uy|]

val ctBytes: ct:ContentType -> b:bytes{b=CTBytes(ct)}
val parseCT: b:bytes {Length(b)=1} -> (ct:ContentType{b=CTBytes(ct)}) Result
val CTtoString: ContentType -> string

// binary format for length-prefixed bytes;
// the integer is the length of the prefix (1,2, 3 or 4 for TLS)

function val VLBytes: (int * bytes) -> bytes 
private definition !i,b. VLBytes(i,b) = IntBytes(i,Length(b)) @| b
val vlbytes: l:nat -> b:bytes -> r:bytes {r=VLBytes(l,b)} 
val vlsplit: 
  l:nat{l<=8} -> b:bytes{Length(b)>=l} ->
  ( b1:bytes * b2:bytes {b = VLBytes(l,b1) @| b2}) Result

val vlparse: 
  l:nat{l<=8} -> b:bytes{Length(b)>=l} -> 
  ( r:bytes { b = VLBytes(l,r) }) Result

// nice to have, not used so far.
ask !i,b. Length(VLBytes(i,b)) = i + Length(b)

// relies on associativity
ask !i,b1,b2,c1,c2. 
  (VLBytes(i,b1) @| b2 = VLBytes(i,c1) @| c2) => (b1 = c1 /\ b2 = c2)

// cert-type parsing / formatting
type certType =
    | RSA_sign
    | DSA_sign
    | RSA_fixed_dh
    | DSA_fixed_dh

function val CertTypeBytes: certType -> bytes
private definition CertTypeBytes(RSA_sign)     = [|1uy|]
private definition CertTypeBytes(DSA_sign)     = [|2uy|]
private definition CertTypeBytes(RSA_fixed_dh) = [|3uy|]
private definition CertTypeBytes(DSA_fixed_dh) = [|4uy|]

val certTypeBytes: ct:certType -> b:bytes{b=CertTypeBytes(ct)}
val parseCertType: b:bytes -> (ct:certType {b=CertTypeBytes(ct)}) Result
