Only in /opt/mitls: .git
Only in /opt/mitls: .gitignore
Only in /opt/mitls: ALaundryList.txt
Only in /opt/mitls: AutoBench
Only in /opt/mitls: BenchClient
Only in /opt/mitls: BenchServer
Only in /opt/mitls: DEVELOPER


diff -Ewbur /opt/mitls/Platform/Bytes.fs7 /opt/miTLS-0.8.1/Platform/Bytes.fs7
--- /opt/mitls/Platform/Bytes.fs7       2014-12-04 15:58:39.000000000 +0100
+++ /opt/miTLS-0.8.1/Platform/Bytes.fs7 2014-12-04 17:11:29.000000000 +0100
@@ -72,11 +68,7 @@
 (* integer multi-byte representations *)

 function val IntBytes: int * int -> bytes
-//CF:
-//CF: we need stronger preconditions, e.g.
-//CF:    (l=1 /\ 0 <= l /\ l < 256)
-//CF: \/ (l=2 /\ 0 <= l /\ l < 65536)
-//CF: /\ (l=4 /\ 0 <= l)
+
 val bytes_of_int: l:int -> i:int -> b:bytes{b = IntBytes(l,i)}
 val int_of_bytes: b:bytes {Length(b)<=8} -> i:nat
   {b = IntBytes(Length(b),i) /\ (Length(b) = 1 => (0 <= i /\ i < 256)) }

---------------------------------------------------------------------------------
diff -Ewbur /opt/mitls/TLSharp/TLStream.fs /opt/miTLS-0.8.1/TLSharp/TLStream.fs
--- /opt/mitls/TLSharp/TLStream.fs      2014-12-04 15:58:39.000000000 +0100
+++ /opt/miTLS-0.8.1/TLSharp/TLStream.fs        2014-12-04 17:11:30.000000000 +0100
@@ -80,7 +80,7 @@
             match adOpt with
             | None -> raise (IOException(sprintf "TLS-HS: Internal error: %A" err))
             | Some ad -> raise (IOException(sprintf "TLS-HS: Sent fatal alert: %A %A" ad err))
-        | TLS.Close ns -> closed <- true; (conn,empty_bytes) // AP: This is a closed connection, should not be used!
+        | TLS.Close ns -> closed <- true; (conn,empty_bytes)
         | TLS.Fatal ad -> closed <- true; raise (IOException(sprintf "TLS-HS: Received fatal alert: %A" ad))
         | TLS.Warning (conn,ad) -> closed <- true; raise (IOException(sprintf "TLS-HS: Received warning alert: %A" ad))
         | TLS.CertQuery (conn,q,advice) ->
@@ -91,7 +91,7 @@
                     match adOpt with
                     | None -> raise (IOException(sprintf "TLS-HS: Internal error: %A" err))
                     | Some ad -> raise (IOException(sprintf "TLS-HS: Sent fatal alert: %A %A" ad err))
-                | TLS.Close ns -> closed <- true; (conn,empty_bytes) // AP: This is a closed connection, should not be used!
+                | TLS.Close ns -> closed <- true; (conn,empty_bytes)
                 | TLS.Fatal ad -> closed <- true; raise (IOException(sprintf "TLS-HS: Received fatal alert: %A" ad))
                 | TLS.Warning (conn,ad) -> closed <- true; raise (IOException(sprintf "TLS-HS: Received warning alert: %A" ad))
                 | TLS.CertQuery (conn,q,advice) -> closed <- true; raise (IOException(sprintf "TLS-HS: Asked to authorize a certificate twice"))
@@ -211,7 +211,7 @@
                     if equalBytes inbuf empty_bytes then
                         (* Read from the socket, and possibly buffer some data *)
                         let (c,data) = wrapRead conn
-                        // FIXME: if data is empty_bytes we should set conn to "null" (which we cannot)
+
                         conn <- c
                         data
                     else (* Use the buffer *)
Only in /opt/mitls: attic
Only in /opt/mitls: doc
diff -Ewbur /opt/mitls/echo/EchoTest.fs /opt/miTLS-0.8.1/echo/EchoTest.fs
--- /opt/mitls/echo/EchoTest.fs 2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/echo/EchoTest.fs   2014-12-04 17:11:23.000000000 +0100
@@ -173,4 +173,3 @@
     match isclient with
     | true  -> EchoImpl.client options
     | false -> EchoImpl.server options
-
diff -Ewbur /opt/mitls/lib/AEAD_GCM.fs /opt/miTLS-0.8.1/lib/AEAD_GCM.fs
--- /opt/mitls/lib/AEAD_GCM.fs  2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/AEAD_GCM.fs    2014-12-04 17:11:23.000000000 +0100
@@ -43,13 +43,13 @@
     let cb = TLSConstants.bytes_of_seq state.counter in
     let iv = ivb @| cb in
     //let p = LHAEPlain.makeExtPad id adata rg p in
-    // AP: If not ideal, the following lines
+
     //let text = LHAEPlain.repr id adata rg p in
     let tLen = length text in
     let tLenB = bytes_of_int 2 tLen in
     let ad = adata @| tLenB in
     let cipher = CoreCiphers.aes_gcm_encrypt k.kb iv ad text in
-    // AP: Else log encryption somewhere
+
     let cipher = cb @| cipher in
     let newCounter = state.counter + 1 in
     let state = {state with counter = newCounter} in
@@ -93,21 +93,13 @@
         let k = state.key in
         match CoreCiphers.aes_gcm_decrypt k.kb iv ad cipher with
         | None ->
-#if DEBUG
-           let reason = perror __SOURCE_FILE__ __LINE__ "" in
-#else
            let reason = "" in
-#endif
            Error(AD_bad_record_mac, reason)
         | Some(plain) ->
             let plain = LHAEPlain.plain id adata rg plain in
             match LHAEPlain.parseExtPad id adata rg plain with
             | Error(x) ->
-#if DEBUG
-                let reason = perror __SOURCE_FILE__ __LINE__ "" in
-#else
                 let reason = "" in
-#endif
                 Error(AD_bad_record_mac, reason)
             | Correct(plain) -> correct (state,plain))
     | _ -> unexpected "[DEC] invoked on wrong algorithm"
@@ -123,4 +115,3 @@
     else
   #endif
       DEC_int id state adata rg cipher
-
diff -Ewbur /opt/mitls/lib/AEAD_GCM.fs7 /opt/miTLS-0.8.1/lib/AEAD_GCM.fs7
--- /opt/mitls/lib/AEAD_GCM.fs7 2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/AEAD_GCM.fs7   2014-12-04 17:11:23.000000000 +0100
@@ -4,8 +4,6 @@
    we could similarly specify AES-CCM.
    used by LHAE, parameterized by LHAEPlain. *)

-// CF 14-07-17 currently *not* typeckecked.
-
 open Bytes
 open Range
 open TLSInfo
diff -Ewbur /opt/mitls/lib/Alert.fs /opt/miTLS-0.8.1/lib/Alert.fs
--- /opt/mitls/lib/Alert.fs     2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/Alert.fs       2014-12-04 17:11:23.000000000 +0100
@@ -9,7 +9,6 @@
 open TLSInfo
 open Range

-// FIXME: Port to deltas and streams!
 type pre_al_state = {
   al_incoming: bytes; (* incomplete incoming message *)
   al_outgoing: bytes (* emptybstr if nothing to be sent *)
@@ -130,8 +129,7 @@
     | _ -> false

 let send_alert (ci:ConnectionInfo) state alertDesc =
-    (* FIXME: We should only send fatal alerts. Right now we'll interpret any sent alert
-       as fatal, and so will close the connection afterwards. *)
+
     (* Note: we only support sending one (fatal) alert in the whole protocol execution
        (because we'll tell dispatch an alert has been sent when the buffer gets empty)
        So we only add an alert on an empty buffer (we don't enqueue more alerts) *)
@@ -162,7 +160,7 @@
         let state = {state with al_outgoing = rem} in
         match rem with
         | x when length x = 0 ->
-            // FIXME: This hack is not even working, because if we do one-bye fragmentation parseAlert fails!
+
             (match parseAlert d with
             | Error z -> unexpected ("[next_fragment] This invocation of parseAlertDescription should never fail")
             | Correct(ad) ->
@@ -184,7 +182,7 @@
             ALWarning (alDesc,state)

 let recv_fragment (ci:ConnectionInfo) state (r:range) (f:HSFragment.fragment) =
-    // FIXME: we should accept further data after a warning alert! (Parsing sequences of messages in Handshake style)
+
     let ki = id ci.id_in in
     let fragment = HSFragment.fragmentRepr ki r f in
     match state.al_incoming with
diff -Ewbur /opt/mitls/lib/Alert.fs7 /opt/miTLS-0.8.1/lib/Alert.fs7
--- /opt/mitls/lib/Alert.fs7    2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/Alert.fs7      2014-12-04 17:11:23.000000000 +0100
@@ -6,18 +6,12 @@
 open TLSInfo
 open Range

-
 private type (;ci:ConnectionInfo)pre_al_state = {
   al_incoming: bytes; (* incomplete incoming message *)
   al_outgoing: bytes (* emptybstr if nothing to be sent *)
 }
 type (;ci:ConnectionInfo)state = (;ci)pre_al_state

-(* AP
-function val AlInStream:  ci:ConnectionInfo * (;ci)state -> 'a //(;ci.id_in) stream
-function val AlOutStream: ci:ConnectionInfo * (;ci)state -> 'a //(;ci.id_out)stream
-*)
-
 type (;ki:epoch)ALFragReply =
     | EmptyALFrag
     | ALFrag of          (rg:range * (;Id(ki),HSFragment.EmptyStream(Id(ki)),rg)HSFragment.plain)
@@ -96,55 +90,15 @@
 val isFatal: ad:alertDescription -> b:bool{b = true => IsFatal(ad)}

 val init: ci:ConnectionInfo ->
-       s:(;ci)state // AP{HSFragment.EmptyStream(ci.id_in,AlInStream(ci,s)) /\ HSFragment.EmptyStream(ci.id_out,AlOutStream(ci,s))}
+       s:(;ci)state

 val send_alert: ci:ConnectionInfo -> s:(;ci)state -> alertDescription ->
        s':(;ci)state
-                   (*AP  {AlOutStream(ci,s) = AlOutStream(ci,s') /\
-                                 AlInStream(ci,s)  = AlInStream(ci,s')} *)

 val makeFragment: e:epoch -> b:bytes -> (rg:range * (;Id(e),HSFragment.EmptyStream(Id(e)),rg)HSFragment.plain) * bytes

 val next_fragment: ci:ConnectionInfo -> s:(;ci)state ->
        (res:(;ci.id_out)ALFragReply * s':(;ci)state)
-       (* AP
-         { (!r,f. res = ALFrag(r,f) => (
-               (Auth(ci.id_out) => HSFragment.Sent(ci.id_out,AlOutStream(ci,s),r,f)) /\
-               AlOutStream(ci,s') = HSFragment.Extend(ci.id_out,AlOutStream(ci,s),r,f) /\
-               AlInStream(ci,s') = AlInStream(ci,s))) /\
-              (!r,f,ad. res = LastALFrag(r,f,ad) => (
-               (Auth(ci.id_out) => HSFragment.Sent(ci.id_out,AlOutStream(ci,s),r,f)) /\
-               AlOutStream(ci,s') = HSFragment.Extend(ci.id_out,AlOutStream(ci,s),r,f) /\
-               AlInStream(ci,s') = AlInStream(ci,s))) /\
-
-                (!r,f. res = LastALCloseFrag(r,f) => (
-               (Auth(ci.id_out) => HSFragment.Sent(ci.id_out,AlOutStream(ci,s),r,f)) /\
-               AlOutStream(ci,s') = HSFragment.Extend(ci.id_out,AlOutStream(ci,s),r,f) /\
-               AlInStream(ci,s') = AlInStream(ci,s)))}
-       *)
-
-(*TODO
-val verifyALCloseFrag: ci:ConnectionInfo -> s:(;ci)state -> r:range -> f:(;ci,r) HSFragment.fragment -> s':(;ci)state -> unit{
-               (Auth(ci.id_out) => HSFragment.Sent(ci.id_out,AlOutStream(ci,s),r,f)) /\
-               AlOutStream(ci,s') = HSFragment.Extend(ci.id_out,AlOutStream(ci,s),r,f) /\
-               AlInStream(ci,s') = AlInStream(ci,s)}
-*)
-
-(*TODO   { (?r,f. res = ALFrag(r,f) /\
-               (Auth(ci.id_out) => HSFragment.Sent(ci.id_out,AlOutStream(ci,s),r,f)) /\
-               AlOutStream(ci,s') = HSFragment.Extend(ci.id_out,AlOutStream(ci,s),r,f) /\
-               AlInStream(ci,s') = AlInStream(ci,s)) \/
-              (?r,f,ad. res = LastALFrag(r,f,ad) /\
-               (Auth(ci.id_out) => HSFragment.Sent(ci.id_out,AlOutStream(ci,s),r,f)) /\
-               AlOutStream(ci,s') = HSFragment.Extend(ci.id_out,AlOutStream(ci,s),r,f) /\
-               AlInStream(ci,s') = AlInStream(ci,s)) \/
-
-                (?r,f. res = LastALCloseFrag(r,f) /\
-               (Auth(ci.id_out) => HSFragment.Sent(ci.id_out,AlOutStream(ci,s),r,f)) /\
-               AlOutStream(ci,s') = HSFragment.Extend(ci.id_out,AlOutStream(ci,s),r,f) /\
-               AlInStream(ci,s') = AlInStream(ci,s)) \/
-             res = EmptyALFrag}
-*)

 val handle_alert: ci:ConnectionInfo -> (;ci)state -> alertDescription -> (;ci)alert_reply

@@ -153,10 +107,7 @@
     // {Auth(ci.id_in) => HSFragment.Sent(ci.id_in,AlInStream(ci,s),rg,f)}
        ->
        (s':(;ci)alert_reply
-           (* AP
-               {AlOutStream(ci,s') = AlOutStream(ci,s) /\
-                AlInStream(ci,s')  = AlInStream(ci,s)
-               }*)
+
        ) Result

 val is_incoming_empty: ci:ConnectionInfo -> s:(;ci)state -> bool
@@ -164,15 +115,7 @@
 val reset_incoming: ci:ConnectionInfo -> s:(;ci)state ->
        ci':ConnectionInfo{ci'.role = ci.role /\ ci'.id_out = ci.id_out} ->
        s':(;ci')state
-               (* AP
-               {HSFragment.EmptyStream(ci'.id_in,AlInStream(ci',s')) /\
-                AlOutStream(ci',s') = AlOutStream(ci,s)}
-               *)

 val reset_outgoing: ci:ConnectionInfo -> s:(;ci)state ->
        ci':ConnectionInfo{ci'.role = ci.role /\ ci'.id_in = ci.id_in} ->
                s':(;ci')state
-               (* AP
-               {HSFragment.EmptyStream(ci'.id_out,AlOutStream(ci',s')) /\
-                AlInStream(ci',s') = AlInStream(ci,s)}
-               *)
diff -Ewbur /opt/mitls/lib/Alert.fsi /opt/miTLS-0.8.1/lib/Alert.fsi
--- /opt/mitls/lib/Alert.fsi    2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/Alert.fsi      2014-12-04 17:11:23.000000000 +0100
@@ -38,4 +38,3 @@
 val is_incoming_empty: ConnectionInfo -> state -> bool
 val reset_incoming: ConnectionInfo -> state -> ConnectionInfo -> state
 val reset_outgoing: ConnectionInfo -> state -> ConnectionInfo -> state
-
Only in /opt/mitls/lib: AlertPlain.fs
Only in /opt/mitls/lib: AlertPlain.fs7
Only in /opt/mitls/lib: AlertPlain.fsi
diff -Ewbur /opt/mitls/lib/AppData.fs7 /opt/miTLS-0.8.1/lib/AppData.fs7
--- /opt/mitls/lib/AppData.fs7  2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/AppData.fs7    2014-12-04 17:11:23.000000000 +0100
@@ -95,4 +95,3 @@
             AppInStream(ci',s') = EmptyStream(ci'.id_in) /\
             AppOutStream(ci',s') = AppOutStream(ci,s) /\
                        AppOutBuf(ci',s') = AppOutBuf(ci,s)}
-
diff -Ewbur /opt/mitls/lib/AppFragment.fs /opt/miTLS-0.8.1/lib/AppFragment.fs
--- /opt/mitls/lib/AppFragment.fs       2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/AppFragment.fs 2014-12-04 17:11:23.000000000 +0100
@@ -38,9 +38,7 @@
       (d,s'')
     else
       // we coerce d to the local epoch
-      //CF 14-07-15 ??
-      //CF below, we can't prove not(Safe(e')).
-      //CF from Id(e') = Id(e), we should get not(AuthId(Id(e')) => not(Auth(e')) => not(Safe(e'))
+
       let raw = deltaRepr e' s' r d in
       let d' = deltaPlain e s r raw in
       let s'' = append e s r d' in
@@ -52,7 +50,7 @@
     #endif

 let plain i r b =
-  let e = TLSInfo.unAuthIdInv i in // CF review
+  let e = TLSInfo.unAuthIdInv i in
   let s = DataStream.init e in
   let d = DataStream.deltaPlain e s r b in
   {frag = (e,s,d)}
@@ -65,14 +63,12 @@
 #if TLSExt_extendedPadding
     if TLSExtensions.hasExtendedPadding i then
         let (e',s,d) = f.frag in
-        //AP: This e' has no relation to i.
-        //AP: In particular, e' misses crucial information such as negotiated ciphersute and extensions
-        //AP: So, we're forced to do the padding here, rather than in DataStream
+
         let b = DataStream.deltaBytes e' s r d in
         let len = length b in
         let pad = extendedPad i r len in
         let padded = pad@|b in
-        let d = DataStream.createDelta e' s r padded in //CF breaking abstraction
+        let d = DataStream.createDelta e' s r padded in
         {frag = (e',s,d)}
     else
 #endif
@@ -87,7 +83,7 @@
         | Error(x) -> Error(x)
         | Correct(res) ->
             let (_,b) = res in
-            let d = DataStream.createDelta e' s r b in //CF breaking abstraction
+            let d = DataStream.createDelta e' s r b in
             correct ({frag = (e',s,d)})
     else
 #endif
@@ -101,21 +97,3 @@
     let (f1,_) = fragment e s r1 d1 in
     f1
 #endif
-
-
-
-
-(*KB unused
-val delta': ki:epoch -> s:(;Id(ki)) stream -> r:range ->
-  f:(;Id(ki),r) fragment{not AuthId(ki)} ->
-  d:(;Id(ki),s,r) delta * s':(;Id(ki)) stream{s' = ExtendStreamDelta(Id(ki),s,r,d)}
-
-let delta' e s r f =
-    let i = id e in
-    let (s',d) = f.frag in
-    let b = DataStream.deltaRepr i s' r d in
-    let d = DataStream.deltaPlain i s r b in
-    let s'' = append i s r d in
-    (d,s'')
-*)
-
diff -Ewbur /opt/mitls/lib/AppFragment.fs7 /opt/miTLS-0.8.1/lib/AppFragment.fs7
--- /opt/mitls/lib/AppFragment.fs7      2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/AppFragment.fs7        2014-12-04 17:11:23.000000000 +0100
@@ -19,8 +19,6 @@
               (Auth(e) => DeltaFragment(e,s,r,d))}) }

 predicate IsFragment of i:id * r:range * (;i,r)preFragment
-//CF private definition !e,r,f. IsFragment(Id(e),r,f) <=> (?s,d. f.frag = (e,s,d))
-//CF This implies that Id(_) is injective!

 private definition !i,r,f. IsFragment(i,r,f) <=> (?e,s,d. f.frag = (e,s,d) /\ i = Id(e))

@@ -36,29 +34,20 @@

 ask !e,s,r,f. Sent(e,s,r,f) => (?d. f.frag = (e,s,d))

-
 type (;e:epoch,s:(;e)stream,r:range) plain = f:(;Id(e),r) fragment{Auth(e) => Sent(e,s,r,f)}

 function val Payload: i:id * r:range * (;i,r)fragment -> cbytes
 private definition !e,r,s,d. Payload(Id(e),r,{frag = (e,s,d)}) = DataStream.Payload(e,s,r,d)

-(* KB: The definition below is intentional.
-       The ghost epoch and stream inside the frag
-       are irrelevant, since we will prove they are
-       the same as the ones outside using Sent. *)
-
 function val Extend: epoch * 'b * range * 'd -> 'e
 private definition !e,s,r,f,e',s',d.
   f.frag = (e',s',d) =>
   Extend(e,s,r,f) = DataStream.ExtendStreamDelta(e,s,r,d)

-//CF i.e. Extend(e,s,r,{frag = (e',s',d)}) = DataStream.ExtendStreamDelta(e,s,r,d)
-
 ask !e,r,f,s,d.
      IsFragment(Id(e),r,f) /\ Payload(Id(e),r,f) = DataStream.Payload(e,s,r,d)
   => Extend(e,s,r,f) = DataStream.ExtendStreamDelta(e,s,r,d)

-
 val fragment: e:epoch -> s:(;e) stream -> r:range ->
   d:(;e,s,r) delta ->
   f:(;Id(e),r) fragment * s':(;e) stream
@@ -79,7 +68,6 @@
 val repr:  i:id{not SafeId(i)} -> r:range ->
   f:(;i,r) fragment -> b:(;r) rbytes{B(b) = Payload(i,r,f)}

-// CF what are these?
 val makeExtPad:  i:id -> r:range -> f:(;i,r)fragment -> f':(;i,r)fragment{f'=f}
 val parseExtPad: i:id -> r:range -> f:(;i,r)fragment -> res:((f':(;i,r)fragment{f'=f}) Result){?f. res = Correct(f)}

@@ -91,25 +79,3 @@
     f1:(;i,RangeClass(i,r0))fragment{
     Payload(i,r0,f0) = Payload(i,RangeClass(i,r0),f1) /\
     !e,s. Sent(e,s,r0,f0) => Sent(e,s,RangeClass(i,r0),f1)}
-
-
-(* CF unused...
-// injectivity of data-fragment (follows from linearity of streams)
-private theorem !e,s,r1,r2,f1,f2.
-  Auth(e) /\
-  DeltaFragment(e,s,r1,f1) /\
-  DeltaFragment(e,s,r2,f2) => (f1 = f2)
-*)
-
-(* AP: No longer used:
-// conversion with application-level deltas
-predicate FragOfDelta of e:epoch * r:range * (;Id(e),r)fragment * s:(;e)stream * (;e,s,r)delta
-private definition !e,r,f,s,d.
-       FragOfDelta(e,r,f,s,d) <=> f = {frag = (e,s,d)}
-
-ask !e,r,f,s,d. FragOfDelta(e,r,f,s,d) => Payload(Id(e),r,f) = DataStream.Payload(e,s,r,d)
-ask !e,r,f,s,d. FragOfDelta(e,r,f,s,d) => Extend(e,s,r,f) = ExtendStreamDelta(e,s,r,d)
-*)
-
-
-
diff -Ewbur /opt/mitls/lib/Cert.fs /opt/miTLS-0.8.1/lib/Cert.fs
--- /opt/mitls/lib/Cert.fs      2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/Cert.fs        2014-12-04 17:11:24.000000000 +0100
@@ -27,7 +27,6 @@
 let forall (test: (X509Certificate2 -> bool)) (chain : list<X509Certificate2>) : bool = Seq.forall test chain
 #endif

-
 let for_signing (sigkeyalgs : list<Sig.alg>) (h : hint) (algs : list<Sig.alg>) =
     match (find_sigcert_and_alg sigkeyalgs h algs) with
     | Some(cert_and_alg) ->
@@ -56,8 +55,6 @@

 (* ------------------------------------------------------------------------ *)

-
-
 let for_key_encryption (sigkeyalgs : list<Sig.alg>) (h : hint) =
             match (find_enccert sigkeyalgs h) with
             | Some(x509) ->
@@ -69,7 +66,7 @@

                     if forall (x509_check_key_sig_alg_one sigkeyalgs) chain then
                         let pk = RSAKey.create_rsapkey (pmpe) in
-                        #if ideal //MK this should be the same for both ideal and concrete
+                        #if ideal
                         if RSAKey.honest pk then
                             None //loading of honest keys not implemented yet.
                         else
@@ -135,12 +132,8 @@
     let pk,sk = Sig.gen a in
     pk

-//TODO MK the secret keys also need to be stored and used.
-
 (* ------------------------------------------------------------------------ *)

-
-
 let validate_cert_chain (sigkeyalgs : list<Sig.alg>) (chain : chain) =
     validate_x509_chain sigkeyalgs chain

@@ -154,7 +147,7 @@
     | Some x509list ->
         (match x509list with
         | []     -> None
-        | c :: _ -> Some (get_name_info c)) (* FIXME *) //MK What needs fixing?
+        | c :: _ -> Some (get_name_info c))
     | None -> None
 #endif

@@ -165,7 +158,6 @@
 let is_chain_for_key_encryption (chain : chain) =
     match chain with [] -> false| c :: _ -> is_for_key_encryption c

-
 (* ---- TLS-specific encoding ---- *)
 let consCertificateBytes c a =
     let cert = vlbytes 3 c in
diff -Ewbur /opt/mitls/lib/Cert.fs7 /opt/miTLS-0.8.1/lib/Cert.fs7
--- /opt/mitls/lib/Cert.fs7     2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/Cert.fs7       2014-12-04 17:11:24.000000000 +0100
@@ -44,9 +44,8 @@
 val get_public_signing_key    : cert -> a:Sig.alg -> (;a)Sig.pkey Result
 val get_public_encryption_key : cert -> RSAKey.pk Result

-val get_chain_public_signing_key : c:chain -> a:Sig.alg -> (pk:(;a)Sig.pkey{pk=SigPKCert(c,a)}) Result //MK define using events or in UntrustedCert??
+val get_chain_public_signing_key : c:chain -> a:Sig.alg -> (pk:(;a)Sig.pkey{pk=SigPKCert(c,a)}) Result

-//MK honest key generation of signature keys
 val signing_gen:     a:Sig.alg -> pk:(;a) Sig.pkey {Sig.Honest(a,pk)}

 val get_chain_public_encryption_key : c:chain -> (pk:RSAKey.pk{pk=RSAPKCert(c)}) Result
@@ -59,81 +58,16 @@

 val validate_cert_chain : Sig.alg list -> chain -> bool

-
 (* ---- TLS-specific encoding ---- *)

 private val consCertificateBytes: c:bytes -> a:bytes ->
        b:bytes{B(b)=VLBytes(3,B(c)) @| B(a)}

 function val CertificateListBytes: cert list -> cbytes
-//AP private definition !bl. CertificateMsg(bl) = MessageBytes(HT_certificate,VLBytes(3,UnfoldBack(bl,empty_bytes)))

 val certificateListBytes: cl:cert list ->
        b:bytes{B(b)=VLBytes(3,CertificateListBytes(cl))}

 val parseCertificateList: b:bytes -> (cl:cert list{B(b) = CertificateListBytes(cl)}) Result

-//AP next function still to be verified
 val parseCertificateListInt: b:bytes -> acc:chain -> (cl:chain) Result
-
-
-//AP: Commenting out to let typeckeching go through
-
-(*FIXME
-
-// long-term key repository (part of the handshake implementation):
-//
-// an abstract interface for creating and storing long-term keypairs:
-// the handshake may lookup the private key associated with any stored keypair
-// when running a session parameterized by the corresponding public key
-
-val pk = bytes       // any bytes defines some principal identity
-val template = bytes // some unspecified parameters for keys
-
-// our interface hides the co-existence of keypairs for different algorithms
-// as controlled by the first part of the ciphersuite; for instance template
-// may specify which algorithm & keylength to use; internal lookups may
-// fail when the stored algorithm does not match the one requested by the
-// ciphersuite; and secret keys may be implemented as
-//
-// type sk = DHSecret of DH.s | RSAPrivateKey of RSA.s | ...
-
-predicate val Honest: pk -> bool
-// event tracking correct key generations
-// (defined as the indexes of the created key log)
-
-val create: template -> (pk:pk {Honest(pk)}) option
-// correctly produces and stores a fresh keypair
-
-val coerce: template -> bytes -> pk option
-// stores a chosen keypair, thereby modelling static compromise
-// no need to guarantee {not(Honest(pk))} ?
-
-// ideally, both calls above return None in case the public key
-// is already stored, so that created and coerced keys never clash.
-
-// certificate chains (user-defined)
-//
-// HS carries certificate chains indicating which key to use
-// it is up to the user to produce certificates from public keys,
-// and conversely to validate certificate chains upon request
-
-type certs = bytes
-
-// parsing function extracting the endorsed public key
-// from any certificate chain (user-defined, no validity checks)
-function val CertKey: certs -> pk option
-val certkey: c:certs -> o:pk option {o = CertKey(c)}
-
-//CF: note on the current implementation:
-//CF: - [RSA] implements long-term keys
-//CF: - we probably do not support DH yet
-//CF: - [Certificate] implements X509 certificate processing
-//CF: - [Handshake] implements parsing of certificate chains into Certificate.cert list
-//CF: - we do not provide concrete long-term key & cert generation
-
-//MK: should we define pk as a sumtype of (;a)Sig.pkey and RSAKey.pk, rather than as bytes?
-//MK: can we then define Honest in terms of Sig.Honest and RSAKey.Honest?
-//MK: should we plan ahead for static DH??
-
-*)
Only in /opt/mitls/lib: CodeReview.txt
diff -Ewbur /opt/mitls/lib/DH.fs7 /opt/miTLS-0.8.1/lib/DH.fs7
--- /opt/mitls/lib/DH.fs7       2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/DH.fs7 2014-12-04 17:11:24.000000000 +0100
@@ -24,7 +24,7 @@
 private val honest: dhp:dhparams -> e:(;dhp.dhp,dhp.dhg) elt -> b:bool{b = true <=> HonestExponential(dhp.dhp,dhp.dhg,e)}

 definition !p,g,gx,gy. PMS.SafeDH(p,g,gx,gy) <=> HonestExponential(p,g,gx) /\ HonestExponential(p,g,gy) /\ PP(p,g)
-//SZ Check if we can remove these queries; unless we want to keep them as documentation or sanity checks
+
 ask !p,g,gx,gy. not HonestExponential(p,g,gx) => not PMS.SafeDH(p,g,gx,gy)
 ask !p,g,gx,gy. not HonestExponential(p,g,gy) => not PMS.SafeDH(p,g,gx,gy)
 ask !p,g,gx,gy. not PP(p,g) => not PMS.SafeDH(p,g,gx,gy)
@@ -40,7 +40,6 @@

 val genKey: dhp:dhparams -> gx:(;dhp.dhp,dhp.dhg)elt * (;dhp.dhp,dhp.dhg,gx) secret{HonestExponential(dhp.dhp,dhp.dhg,gx)}

-
 val serverGen: string -> DHDB.dhdb -> nat * nat ->
        (DHDB.dhdb * dhp:dhparams * gs:(;dhp.dhp,dhp.dhg) elt * (;dhp.dhp,dhp.dhg,gs) secret
                {PP(dhp.dhp,dhp.dhg) /\ HonestExponential(dhp.dhp,dhp.dhg,gs)})
diff -Ewbur /opt/mitls/lib/DHGroup.fs /opt/miTLS-0.8.1/lib/DHGroup.fs
--- /opt/mitls/lib/DHGroup.fs   2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/DHGroup.fs     2014-12-04 17:11:24.000000000 +0100
@@ -28,8 +28,6 @@
     dhp
 #endif

-
-
 let genElement dhp: elt =
     let (_, e) = CoreDH.gen_key dhp in
 #if verify
diff -Ewbur /opt/mitls/lib/DataStream.fs /opt/miTLS-0.8.1/lib/DataStream.fs
--- /opt/mitls/lib/DataStream.fs        2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/DataStream.fs  2014-12-04 17:11:24.000000000 +0100
@@ -77,7 +77,6 @@

 let init (ki:epoch) = {sb = []}

-//CF 14-07-15 why this hack, just for performance?
 let append (ki:epoch) (s:stream) (r:range) (d:delta) =
 #if ideal
     let dc = d.contents in
diff -Ewbur /opt/mitls/lib/DataStream.fs7 /opt/miTLS-0.8.1/lib/DataStream.fs7
--- /opt/mitls/lib/DataStream.fs7       2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/DataStream.fs7 2014-12-04 17:11:24.000000000 +0100
@@ -36,9 +36,6 @@
 function val Payload: e:epoch * s:(;e)stream * r:range * (;e,s,r)delta -> cbytes
 private definition !e,s,r,d. Payload(e,s,r,d) = B(d.contents)

-// CF enabling re-indexing too easily?
-// CF ask !e,e',s,s',r,r',d. Payload(e,s,r,d) = Payload(e',s',r',d)
-
 function val EmptyStream: e:epoch -> (;e)stream
 private definition !e. EmptyStream(e) = {sb = []}

@@ -71,9 +68,6 @@
   e:epoch -> s:(;e) stream -> r:range ->
   c: (;e,s,r) delta -> b:(;r) rbytes

-//CF we need a better verification pattern for multi-user interfaces.
-//CF a cheap one is to use different names plus ifdefs in the .fsi
-
 // These functions are used by TLS:
 val init: e:epoch -> s:(;e)stream{s=EmptyStream(e)}
 val append:
@@ -98,60 +92,3 @@
 val widen: e:epoch -> s:(;e) stream ->
   r0:range -> r1:range{SubRange(r0,r1)} -> d0:(;e,s,r0) delta ->
   d1:(;e,s,r1) delta{Payload(e,s,r0,d0) = Payload(e,s,r1,d1)}
-
-//CF: We need linearity on the stream!
-
-
-(* CF notes on the "plaintext cascade"
-
-- we need something stronger than Auth, e.g. Auth /\ Complete.
-- document ghost status of some indexes (so that we can "fake" them)
-
-// DataStream   (provided by the application)
-
-  private type (;e:epoch, h:(;e)stream, r:range) delta = {contents: (;r) rbytes}
-
-// AppFragment  (s,d) re-indexing from epochs to indexes. FIX COMMENTS.
-// we generate a dummy epoch, Ok.
-
-- Extend is wrong: not a function.
-- Sent is too strong. As we decrypt, we only know ?e'. I(e) = I(e') /\ ...
-
-  private type (;i:id,r:range) fragment =
-    {frag: (e':epoch * s:(;e)stream * d:(;e',s,r) delta
-              { i = Id(e') /\ (Auth(e') => DeltaFragment(e',s,r,d))}) }
-
-  type (;e:epoch,s:(;e)stream,r:range) plain = f:(;Id(e),r) fragment {Auth(e) => Sent(e,s,r,f)}
-
-// HSFragment, for the other payloads. BROKEN?
-
-  type (;i:id,s:(;i)stream,r:range)plain = f:(;i,r)fragment{AuthId(i) => Sent(i,s,r,f)}
-
-// TLSFragment, multiplexing 4 protocols.
-// Record also does some packaging
-
-  private type (;i:id,ct:ContentType,rg:range) fragment =
-    | FHandshake of f:(;i,rg)HSFragment.fragment {ct=Handshake}
-    | FCCS       of f:(;i,rg)HSFragment.fragment {ct=Change_cipher_spec}
-    | FAlert     of f:(;i,rg)HSFragment.fragment {ct=Alert}
-    | FAppData   of f:(;i,rg)AppFragment.fragment{ct=Application_data}
-
-// StatefulPlain, for StatefulAEAD
-
-  private type (;i:id,ad:cbytes,r:range) fragment =
-    {contents: (;i,ParseAD(e,ad),r)TLSFragment.fragment}
-
-// LHAEPlain, for LHAE
-
-  private type (;i:id,ad:cbytes,r:range) fragment =
-    {contents: (;i,ParseAD(i,ad),r)StatefulPlain.fragment}
-
-// Encode, for ENC
-
-  private type (;i:id,ad:(;i)LHAEPlain.adata,rg:range) plain =
-       { plain: (;i,ad,rg)LHAEPlain.plain;
-         tag  : (;i)MAC.tag;
-         ok   : b:bool { EncAlg(i) = Stream_RC4_128 => b = true }
-
-*)
-
Only in /opt/mitls/lib: DataStream2.fs7
diff -Ewbur /opt/mitls/lib/Dispatch.fs /opt/miTLS-0.8.1/lib/Dispatch.fs
--- /opt/mitls/lib/Dispatch.fs  2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/Dispatch.fs    2014-12-04 17:11:24.000000000 +0100
@@ -52,7 +52,7 @@
 type nextCn = Connection
 type nullCn = Connection
 type query = Cert.chain
-// FIXME: Put the following definitions close to range and delta, and use them
+
 type msg_i = (range * DataStream.delta)
 type msg_o = (range * DataStream.delta)

@@ -82,7 +82,6 @@
     | RFatal of alertDescription (* The alert we received *)
     | RWarning of alertDescription (* The alert we received *)

-
 let init ns role poptions =
     let hsInitRes = Handshake.init role poptions in
     let (ci,hs) = hsInitRes in
@@ -531,8 +530,6 @@
                         let f = TLSFragment.RecordPlainToHSPlain id.id_in history rg frag in
                         let hsRes = Handshake.recv_fragment id c_hs rg f in

-                    // AP: BEGIN: Inlined from handleHandshakeOutcome
-
                         match hsRes with
                         | Handshake.InAck(hs) ->
                             (let c = { c with handshake = hs} in
@@ -600,8 +597,6 @@
                             let wo,conn = writeAllClosing closing in
                             WriteOutcome(wo),conn))

-                        // AP: END: Inlined from handleHandshakeOutcome
-
                   | (Change_cipher_spec, FirstHandshake(_)) | (Change_cipher_spec, Open) ->
                         (match getFragment (Conn(id,c0)) ct len with
                         | Error z ->
@@ -856,7 +851,7 @@
   let (outcome,Conn(id,s)) = writeAllTop (Conn(id,s)) ghost in
   let new_appdata = AppData.clearOutBuf id s.appdata in
   let s = {s with appdata = new_appdata} in
-  match outcome with //AP: prune some options
+  match outcome with
   | WError (_) | SentFatal(_,_) -> Conn(id,s),outcome
   | WriteFinished -> Conn(id,s),outcome
   | WAppDataDone -> Conn(id,s),outcome
@@ -868,8 +863,6 @@
     let hsRes = Handshake.authorize id c.handshake q in
     let c_read = c.read in

-    // AP: BEGIN: Inlined from handleHandshakeOutcome
-
     match hsRes with
     | Handshake.InAck(hs) ->
         (let c1 = { c with handshake = hs} in
@@ -911,8 +904,6 @@
         let wo,conn = writeAllClosing closing in
         conn,WriteOutcome(wo))

-    // AP: END: Inlined from handleHandshakeOutcome
-
 let refuse conn (q:query) =
     let reason = perror __SOURCE_FILE__ __LINE__ "Remote certificate could not be verified locally" in
     let conn = abortWithAlert conn AD_unknown_ca reason in
diff -Ewbur /opt/mitls/lib/Dispatch.fs7 /opt/miTLS-0.8.1/lib/Dispatch.fs7
--- /opt/mitls/lib/Dispatch.fs7 2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/Dispatch.fs7   2014-12-04 17:11:24.000000000 +0100
@@ -57,26 +57,21 @@
 private definition !ci,gs. GState(ci,gs)  <=>
   ( (Auth(ci.id_out) =>
                (
-               AppData.AppOutStream(ci,gs.appdata) = TLSFragment.AppDataHistory(ci.id_out,Record.History(ci.id_out,Writer,gs.write.conn)) //AP /\
-               //AP Handshake.HSOutStream(ci,gs.handshake) = TLSFragment.HandshakeHistory(ci.id_out,Record.History(ci.id_out,Writer,gs.write.conn)) /\
-               //AP Handshake.CCSOutStream(ci,gs.handshake) = TLSFragment.CCSHistory(ci.id_out,Record.History(ci.id_out,Writer,gs.write.conn)) /\
-               //AP Alert.AlOutStream(ci,gs.alert) = TLSFragment.AlertHistory(ci.id_out,Record.History(ci.id_out,Writer,gs.write.conn))
+               AppData.AppOutStream(ci,gs.appdata) = TLSFragment.AppDataHistory(ci.id_out,Record.History(ci.id_out,Writer,gs.write.conn))
+
                )
        ) /\
     (Auth(ci.id_in)  =>
                (
-               AppData.AppInStream(ci,gs.appdata) = TLSFragment.AppDataHistory(ci.id_in,Record.History(ci.id_in,Reader,gs.read.conn)) //AP /\
-               //AP Handshake.HSInStream(ci,gs.handshake) = TLSFragment.HandshakeHistory(ci.id_in,Record.History(ci.id_in,Reader,gs.read.conn)) /\
-               //AP Handshake.CCSInStream(ci,gs.handshake) = TLSFragment.CCSHistory(ci.id_in,Record.History(ci.id_in,Reader,gs.read.conn)) /\
-               //AP Alert.AlInStream(ci,gs.alert) = TLSFragment.AlertHistory(ci.id_in,Record.History(ci.id_in,Reader,gs.read.conn))
+               AppData.AppInStream(ci,gs.appdata) = TLSFragment.AppDataHistory(ci.id_in,Record.History(ci.id_in,Reader,gs.read.conn))
+
                )
        )
   )

 predicate UnchangedState of ci:ConnectionInfo * (;ci)globalState * (;ci)globalState
 private definition !ci,gs,gs'. UnchangedState(ci,gs,gs') <=>
-       // AP (gs.handshake = gs'.handshake) /\
-       // AP (gs.alert = gs'.alert) /\
+
        (gs.appdata = gs'.appdata) /\
        (gs.write = gs'.write) /\
        (gs.read.disp = gs'.read.disp) /\
@@ -160,8 +155,7 @@
 predicate EvWarning    of epoch * alertDescription * cbytes
 predicate EvClose      of epoch * cbytes
 predicate EvFatal      of epoch * alertDescription * cbytes
-// AP FIXME: Dummy definition of the above events, to let the state machine verification go through
-//CF 14-07-16 Indeed, this needs fixing
+
 private assume !e,b. EvClose(e,b)
 private assume !e,ad,b. EvWarning(e,ad,b)
 private assume !e,ad,b. EvFatal(e,ad,b)
@@ -234,7 +228,6 @@
        /\ CnBuf_o(conn) = None
 }

-
 predicate NextCn of Connection * Connection
 definition !c,c'. NextCn(c,c') <=> ( Config(c') = Config(c) /\ CnInfo(c') = CnInfo(c) )
 type (;c:Connection) nextCn = c':Connection {NextCn(c,c')}
@@ -358,7 +351,6 @@
        (?err. ro = RError(err))
    )

-
 private val sameID: c0:Connection -> c1:Connection ->
        o0:(;c0)readOutcome{IOResult_i(c0,c1,o0)} ->
        c2:(;c0)nextCn{CnStream_i(c0) = CnStream_i(c2) /\
diff -Ewbur /opt/mitls/lib/ENC.fs /opt/miTLS-0.8.1/lib/ENC.fs
--- /opt/mitls/lib/ENC.fs       2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/ENC.fs 2014-12-04 17:11:24.000000000 +0100
@@ -38,28 +38,6 @@
 type encryptor = state
 type decryptor = state

-(* CF 14-07-17: reuse?
-let GENOne ki : state =
-    #if verify
-    failwith "trusted for correctness"
-    #else
-    let alg = encAlg_of_id ki in
-    match alg with
-    | Stream_RC4_128 ->
-        let k = Nonce.random (encKeySize alg) in
-        let key = {k = k} in
-        StreamCipher({skey = key; sstate = CoreCiphers.rc4create (k)})
-    | CBC_Stale(cbc) ->
-        let key = {k = Nonce.random (encKeySize alg)}
-        let iv = SomeIV(Nonce.random (blockSize cbc))
-        BlockCipher ({key = key; iv = iv})
-    | CBC_Fresh(_) ->
-        let key = {k = Nonce.random (encKeySize alg)}
-        let iv = NoIV
-        BlockCipher ({key = key; iv = iv})
-    #endif
-*)
-
 let streamCipher (ki:id) (r:rw) (s:streamState)  = StreamCipher(s)
 let blockCipher (ki:id) (r:rw) (s:blockState) = BlockCipher(s)

@@ -177,15 +155,14 @@
     e::!l
 #endif

-
 let ENC (ki:id) s ad rg data =
     let tlen = targetLength ki rg in
   #if ideal
     let d =
-      if safeId(ki) then //MK Should we use Encode.payload here? CF 14-07-17 ??
+      if safeId(ki) then
         createBytes tlen 0
       else
-        Encode.repr ki ad rg data  //MK we may have only plaintext integrity in this case
+        Encode.repr ki ad rg data
     in
     if authId (ki) then
       let (s,c) = ENC_int ki s tlen d in
@@ -248,7 +225,7 @@
   #if ideal
     if authId (ki) then
       let (s,p) = DEC_int ki s cipher in
-      //MK implement different find for plaintext integrity
+
       let (rg,p') = cfind ki ad cipher !log in
       let p' = Encode.widen ki ad rg p' in
       (s,p')
@@ -258,46 +235,3 @@
       let tlen = length cipher in
       let p' = Encode.plain ki ad tlen p in
       (s,p')
-
-
-(* TODO: the SPRP game in F#, without indexing so far.
-   the adversary gets
-   enc: block -> block
-   dec: block -> block
-
-// two copies of assoc
-let rec findp pcs c =
-  match pcs with
-  | (p,c')::pcs -> if c = c' then Some(p) else findp pcs c
-  | [] -> None
-let rec findc pcs p =
-  match pcs with
-  | (p',c)::pcs -> if p = p' then Some(c) else findc pcs p
-  | [] -> None
-
-let k = mkRandom blocksize
-let qe = ref 0
-let qd = ref 0
-#if ideal
-let log = ref ([] : list<(block * block)>)
-let F p =
-  match findc !pcs p with
-  | Some(c) -> c // non-parametric;
-                 // after CBC-collision avoidance,
-                 // we will always use the "None" case
-  | None    -> let c = mkfreshc !log blocksize
-               log := (p,c)::!log
-               c
-let G c =
-  match findp !log c with
-  | Some(p) -> p
-  | None    -> let p = mkfreshp !log blocksize
-               log := (p,c)::!log
-               p
-#else
-let F = AES k
-let G = AESminus k
-#endif
-let enc p = incr qe; F p
-let dec c = incr qd; G c
-*)
diff -Ewbur /opt/mitls/lib/ENC.fs7 /opt/miTLS-0.8.1/lib/ENC.fs7
--- /opt/mitls/lib/ENC.fs7      2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/ENC.fs7        2014-12-04 17:11:24.000000000 +0100
@@ -2,7 +2,6 @@

 (* Bulk encryption for TLS record, agile & assumed conditionally CPA with "Encode" for plaintexts *)
 (* This module is idealized *)
-(* TODO write a well-typed ideal functionality; reduce it to its non-agile underlying algorithms, e.g. AES-CBC and GCM *)

 open Bytes
 open Encode
@@ -12,19 +11,12 @@
 open TLSError
 open Range

-
 // ciphers consist of one or more blocks of bytes.
 type cipher = b:bytes{Length(b) <= max_TLSCipher_fragment_length}

 private type (;ki:id) key = {k:bytes}

-//CF should actually be
-//CF private type (;ki:id) key' =
-//CF   | GoodKey_A of ideal_A.key
-//CF   | GoodKey_B of ideal_B.key
-//CF   | BadKey_A
-
-type iv = bytes //CF could specify its size
+type iv = bytes
 private type (;ki:id) iv3 =
        | SomeIV of iv // SSL_3p0 and TLS_1p0
        | NoIV         // TLS_1p0 and TLS_1p2
@@ -56,7 +48,7 @@
 val blockCipher: ki:id -> r:rw -> s:(;ki)blockState -> (;ki,r) state

 //val GEN:    ki:id -> (e:(;ki)encryptor{StateID(ki,Writer,e)=0}) * (d:(;ki)decryptor{StateID(ki,Reader,d)=0})
-val GEN:    ki:id -> (e:(;ki)encryptor) * (d:(;ki)decryptor) //MK less refinements for testing
+val GEN:    ki:id -> (e:(;ki)encryptor) * (d:(;ki)decryptor)
 val LEAK:   ki:id{not SafeId(ki)} -> rw:rw -> (;ki,rw)state -> key:bytes * iv:bytes
 val COERCE: ki:id{not SafeId(ki)} -> rw:rw -> key:bytes -> iv:bytes -> (;ki,rw)state

@@ -66,24 +58,21 @@
 //predicate val ENCrypted:
 //  (e:id * ad:(;e)LHAEPlain.adata * c:cipher * 'a) -> bool // p:(;e,ad,CipherRangeClass(e,Length(c))) plain

-// TODO: We need to refine cipher before applying CPA
-//CF we miss a refinement synchronizing ad and s
 val ENC: ki:id -> s:(;ki) encryptor -> ad:(;ki)LHAEPlain.adata -> r:range ->
   p:(;ki,ad,r)plain ->
-  ( (s': (;ki) encryptor (*MK unspecified for now: {StateID(ki,Writer,s') = StateID(ki,Writer,s)+1} *)
+  ( (s': (;ki) encryptor
     ) *
     (c : cipher {(SafeId(ki) => ENCrypted(ki,ad,c,p)) /\ Length(c)=TargetLength(ki,r)}
     )
   )

-//MK I don't see how we can prove this by typing.
 //ask !ki,ad,c,p,p'. ENCrypted(ki,ad,c,p) /\ ENCrypted(ki,ad,c,p') => p=p'

 val DEC: ki:id -> s:(;ki) decryptor -> ad:(;ki)LHAEPlain.adata ->
   c:cipher
   { (SafeId(ki) => ?p'. ENCrypted(ki,ad,c,p')) /\ Length(c) >= MinTlen(ki) /\ Length(c) <= max_TLSCipher_fragment_length } ->
-  ( (s': (;ki) decryptor (*MK unspecified for now: {StateID(ki,Reader,s') = StateID(ki,Reader,s)+1}*) )  *
-    (p : (;ki,ad,CipherRangeClass(ki,Length(c)))plain (*MK: ignoring this for now: {!p'. ENCrypted(ki,ad,c,p') => p=p'}*) ))
+  ( (s': (;ki) decryptor  )  *
+    (p : (;ki,ad,CipherRangeClass(ki,Length(c)))plain  ))

 type entry =
   (ki:id * ad:(;ki)LHAEPlain.adata * rg:range * c:cipher * p:(;ki,ad,rg)plain)
@@ -95,28 +84,16 @@

 val cfind: e:id -> ad:(;e)LHAEPlain.adata -> c:cipher -> xs: entry list -> (rg:range * p:(;e,ad,rg) Encode.plain){ENCrypted(e,ad,c,p) /\ Length(c) = TargetLength (e, rg)}

-//MK is this outdated? Should do some cleanup.
-(* AP
-val ENC: ki:id -> s:(;ki) encryptor -> tlen:int -> p:(;ki,tlen) plain ->
-  ( s':(;ki)encryptor *
-   c:cipher{  StateID(s') = StateID(s)+1 /\  ENCrypted(ki,tlen,StateID(s),p,c) /\ Length(c)=tlen})
-
-  (s':(;ki)decryptor *
-   p:(;ki,Length(c))plain{  StateID(s') = StateID(s)+1 /\  !p'. ENCrypted(ki,Length(c),StateID(s),p',c) => p=p'})
-*)
-
-
-
 private val lastblock:  alg:blockCipher -> c:cipher {Length(c)>=BlockSize(alg)} -> bytes

 // internal function declarations
-//TODO state should also have a role, but GENOne returns the state for both roles.
+
 //private val GENOne: i:id -> 'a //(;i) state
 private val cbcenc: blockCipher -> CoreCiphers.key -> CoreCiphers.iv -> bytes -> bytes
 private val cbcdec: blockCipher -> CoreCiphers.key -> CoreCiphers.iv -> bytes -> bytes

 val ENC_int: i:id -> s:(;i)encryptor -> tlen:nat{!enc,mac. i.aeAlg = MtE(CBC_Stale(enc),mac) => tlen>=BlockSize(enc)} -> bytes ->
-( (s': (;i) encryptor (*MK unspecified for now: {StateID(i,Writer,s') = StateID(i,Writer,s)+1} *)
+( (s': (;i) encryptor
   ) *
   (c:cipher {Length(c)=tlen}
   )
@@ -124,4 +101,4 @@

 private val DEC_int: ki:id -> s:(;ki) decryptor ->
                                         c:cipher {Length(c) >= MinTlen(ki) /\ Length(c) <= max_TLSCipher_fragment_length /\ (!enc,mac. ki.aeAlg = MtE(CBC_Stale(enc),mac) \/ ki.aeAlg = MtE(CBC_Fresh(enc),mac) => Length(c)>=BlockSize(enc)) } ->
-                                        (;ki) decryptor * (;PlainLength(ki,Length(c)))lbytes //MK removed: ad:(;ki)LHAEPlain.adata
\ No newline at end of file
+                                        (;ki) decryptor * (;PlainLength(ki,Length(c)))lbytes
diff -Ewbur /opt/mitls/lib/ENC.fsi /opt/miTLS-0.8.1/lib/ENC.fsi
--- /opt/mitls/lib/ENC.fsi      2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/ENC.fsi        2014-12-04 17:11:24.000000000 +0100
@@ -17,4 +17,3 @@

 val ENC: id -> encryptor -> LHAEPlain.adata -> Range.range -> Encode.plain -> (encryptor * cipher)
 val DEC: id -> decryptor -> LHAEPlain.adata -> cipher -> (decryptor * Encode.plain)
-
Only in /opt/mitls/lib: ENC_RC4.fs
Only in /opt/mitls/lib: ENC_RC4.fs7
Only in /opt/mitls/lib: ENC_RC4.fsi
diff -Ewbur /opt/mitls/lib/Encode.fs /opt/miTLS-0.8.1/lib/Encode.fs
--- /opt/mitls/lib/Encode.fs    2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/Encode.fs      2014-12-04 17:11:25.000000000 +0100
@@ -102,26 +102,14 @@
           if plain.ok then
             match LHAEPlain.parseExtPad e ad rg f with
             | Error(x) ->
-#if DEBUG
-                let reason = perror __SOURCE_FILE__ __LINE__ "" in
-#else
                 let reason = "" in
-#endif
                 Error(AD_bad_record_mac,reason)
             | Correct(f) -> correct f
           else
-#if DEBUG
-              let reason = perror __SOURCE_FILE__ __LINE__ "" in
-#else
               let reason = "" in
-#endif
               Error(AD_bad_record_mac,reason)
         else
-#if DEBUG
-           let reason = perror __SOURCE_FILE__ __LINE__ "" in
-#else
            let reason = "" in
-#endif
            Error(AD_bad_record_mac,reason)

 let encodeNoPad (e:id) (tlen:nat) (rg:range) (ad:LHAEPlain.adata) data tag =
@@ -149,7 +137,7 @@
     let ivL = ivSize e in
     let pl = tlen - lb - lm - ivL in
     if pl > 0 && pl <= 256 then
-        //CF here we miss refinements to prove 0 < pl <= 256
+
         let payload = b @| tag @| pad pl in
         if length payload <> tlen - ivL then
             Error.unexpected "[encode] Internal error."
diff -Ewbur /opt/mitls/lib/Encode.fs7 /opt/miTLS-0.8.1/lib/Encode.fs7
--- /opt/mitls/lib/Encode.fs7   2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/Encode.fs7     2014-12-04 17:11:25.000000000 +0100
@@ -26,8 +26,6 @@
   f :(;i,ad,r)plain ->
   f':(;i,ad,CipherRangeClass(i,TargetLength(i,r))) plain
     //{Payload(i,B(ad),r,f) = Payload(i,B(ad),RangeClass(i,r),f')}
-//CF Markulf, why commenting it out?
-//CF I don't see how we can use widen & get integrity without a stronger spec.

 function val PlainLength: id * nat -> nat
 definition !e,tlen.
@@ -51,7 +49,6 @@
   b:(;r) rbytes{ SafeId(e) \/ B(b) = LHAEPlain.Payload(e,B(ad),r,f) }

 // the MACed bytes, i.e. ad @| 2-byte length of payload @| payload
-//CF should ask some injectivity

 function val MACPlain : 'a * 'b * 'c * 'd -> 'e
 private definition !e,r,ad,f. MACPlain(e,r,ad,f) = ad @| VLBytes(2,LHAEPlain.Payload(e,ad,r,f))
@@ -109,18 +106,9 @@
   ps:(;e,ad,rg) plain ->
   res:(;e,ad,rg)LHAEPlain.plain Result

-(* KB we need to add some refinement to ensure that verify
-   will not fail for MACed values *)
-
-(* CF to verify the 3rd postcondition, we need something like
-   SafeId(e) => Version(e) = TLS_1p1 \/ Version(e) = TLS_1p2 \/ ps.ok = true
-
-*)
-
 predicate val Encoded: 'e * 'a * 'b * 'c * 'd -> bool

 private val pad: l:int { 0 < l /\ l <= 256 } -> b:bytes{Length(b) = l}
-//CF we will need a more precise refinement for the MEE proof

 val encode:
     e:id{not SafeId(e) /\ (?alg,mac. e.aeAlg  = MtE(CBC_Stale(alg),mac) \/ e.aeAlg  = MtE(CBC_Fresh(alg),mac))} ->
@@ -138,12 +126,8 @@
        tlen:nat{tlen - IVSize(e) >= ( MacKeySize(MacAlg(e)) + FixedPadSize(e,()) ) /\
        rg = CipherRangeClass(e,tlen)} ->
        (;PlainLength(e,tlen))lbytes ->
-       ps:(;e,ad,rg)plain//AP{ Decoded(e,ad,ps) }
-//AP with some
-//AP private definition Decoded(e,ad,ps) <=> (Encoded(e,ad,ps.plain,ps.tag,p) => ps.ok = true)
+       ps:(;e,ad,rg)plain

-//CF why do we need "NoPad" variants again?
-// AP We should merge the two.
 val encodeNoPad: e:id{not SafeId(e) /\ (?mac. e.aeAlg  = MACOnly(mac) \/
          e.aeAlg  = MtE(Stream_RC4_128,mac))} ->
        tlen:nat{tlen <= max_TLSCipher_fragment_length} -> rg:range{tlen = TargetLength(e,rg)} ->
@@ -177,7 +161,7 @@

 // This property is needed to prove the first ask below;
 // it follows by case analysis on all enc/mac algorithms of TLS (see TLSConstants.fs7)
-//CF 14-07-16 this should not be needed with F*'s typed ADTs
+
 private theorem !e,h. BlockSize(e) <= MacSize(h)

 ask !id,enc,mac.
@@ -186,14 +170,13 @@
 ask !id,enc,mac.
     id.aeAlg = MtE(CBC_Fresh(enc),mac) => MinTlen(id) >= BlockSize(enc)

-
 val plain: e:id{not AuthId(e)} ->
   ad:(;e)LHAEPlain.adata -> tlen:nat{tlen <= max_TLSCipher_fragment_length /\ tlen >= MinTlen(e)} ->
   (;PlainLength(e,tlen))lbytes ->
   (;e,ad,CipherRangeClass(e,tlen)) plain

 val repr:  e:id{not SafeId(e)} ->
-  ad:(;e)LHAEPlain.adata -> rg:range -> //AP {rg is fRange}
+  ad:(;e)LHAEPlain.adata -> rg:range ->
   (;e,ad,rg) plain ->
   (;PlainLength(e,TargetLength(e,rg)))lbytes{TargetLength(e,rg) <= max_TLSCipher_fragment_length}

@@ -201,23 +184,13 @@
 // Auxiliary definitions and assumptions for typing
 //------------------------------------------------------------------------------------------------------

-//CF this was too weak: no constraint on f! patched //MK we should need AuthId somewhere.
 private definition !e,pl. MAC.Msg(e,pl) <=>
      (SafeId(e) \/ (?ad,r,f. Length(ad) = 8 + StatefulPlain.ADLength(e)
                           /\ B(pl) = MACPlain(e,r,B(ad),f)))

-
 private ask !i,t. not SafeId(i) /\ MAC.Msg(i,t) =>
        (?ad,r,p. B(t) = B(ad) @| VLBytes(2,LHAEPlain.Payload(i,B(ad),r,p)) )

 private ask !i,ad,b,t. (?ad'',r'',f''. B(t) = B(ad'') @| VLBytes(2,LHAEPlain.Payload(i,B(ad''),r'',f'')) /\ Length(ad'') = 8 + StatefulPlain.ADLength(i) ) /\
        B(t) = B(ad) @| VLBytes(2,B(b)) /\ Length(ad) = 8 + StatefulPlain.ADLength(i) =>
        (?ad',r,p. B(ad) @| VLBytes(2,B(b)) = B(ad') @| VLBytes(2,LHAEPlain.Payload(i,B(ad'),r,p)) /\ ad = ad' )
-
-//CF Comments:
-//CF
-//CF AP and CF agree: Encode is indexed by (e and) its public length after encoding (rather than its range).
-//CF We define function from:
-//CF - public length of ciphertext to public length of encoded plaintext (either identity, or minus iv length)
-//CF - from tlen to public range of decoded authenticated fragment
-//CF - (and the inverse functions)
diff -Ewbur /opt/mitls/lib/HASH.fs7 /opt/miTLS-0.8.1/lib/HASH.fs7
--- /opt/mitls/lib/HASH.fs7     2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/HASH.fs7       2014-12-04 17:11:26.000000000 +0100
@@ -2,8 +2,6 @@

 (* Core cryptographic hash algorithms; trusted only to have the right tag length *)

-// CF the crypto assumptions are in MAC and PRF, not here
-
 open Bytes
 open TLSConstants

diff -Ewbur /opt/mitls/lib/HMAC.fs7 /opt/miTLS-0.8.1/lib/HMAC.fs7
--- /opt/mitls/lib/HMAC.fs7     2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/HMAC.fs7       2014-12-04 17:11:26.000000000 +0100
@@ -26,4 +26,3 @@
 val MACVERIFY:
   a:macAlg -> k:key {Length(k)=MacKeySize(a)} ->
   data -> t:mac {Length(k)=MacSize(a)} -> bool
-
diff -Ewbur /opt/mitls/lib/HSFragment.fs7 /opt/miTLS-0.8.1/lib/HSFragment.fs7
--- /opt/mitls/lib/HSFragment.fs7       2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/HSFragment.fs7 2014-12-04 17:11:26.000000000 +0100
@@ -9,7 +9,7 @@
 private type (;i:id) stream = {sb:bytes list}

 predicate Sent of i:id * (;i) stream * r:range * (;i,r)fragment
-assume !i,s,r,f. Sent(i,s,r,f) (*KB No Handshake/Alert/CCS Authentication *)
+assume !i,s,r,f. Sent(i,s,r,f)

 type (;i:id,s:(;i)stream,r:range)plain = f:(;i,r)fragment{AuthId(i) => Sent(i,s,r,f)}

@@ -23,8 +23,6 @@
 val fragmentPlain: i:id -> r:range -> b:(;r) rbytes -> f:(;i,EmptyStream(i),r) plain{B(b) = Payload(i,r,f)}
 val fragmentRepr:  i:id -> r:range -> f:(;i,r) fragment -> b:(;r) rbytes{B(b) = Payload(i,r,f)}

-//AP Unless the two streams are the same, this functions breaks the streaming
-//AP authentication property (which we currently don't prove for HS/CCS/Alert)
 val reStream: i:id -> s:(;i)stream -> r:range -> p:(;i,s,r)plain -> s':(;i)stream ->
        p':(;i,s',r)plain{Payload(i,r,p) = Payload(i,r,p')}

@@ -37,6 +35,3 @@
 function val Extend: i:id * s:(;i)stream * r:range * (;i,r)fragment -> 'a // (;i)stream
 private definition !i,s,r,f. Extend(i,s,r,f) = {sb = f.frag :: s.sb }
 val extend: i:id -> s:(;i)stream -> r:range -> f:(;i,r)fragment -> s':(;i)stream{s'=Extend(i,s,r,f)}
-
-
-
diff -Ewbur /opt/mitls/lib/HSFragment.fsi /opt/miTLS-0.8.1/lib/HSFragment.fsi
--- /opt/mitls/lib/HSFragment.fsi       2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/HSFragment.fsi 2014-12-04 17:11:26.000000000 +0100
@@ -26,5 +26,3 @@
 #if ideal
 val widen: id -> range -> range -> fragment -> fragment
 #endif
-
-
diff -Ewbur /opt/mitls/lib/Handshake.fs /opt/miTLS-0.8.1/lib/Handshake.fs
--- /opt/mitls/lib/Handshake.fs 2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/Handshake.fs   2014-12-04 17:11:25.000000000 +0100
@@ -15,9 +15,6 @@
 // the ``#if verify'' compilation is set for F7 typechecking but not F# compilation
 // it is used to isolate dynamic assumes and expects, which only affect the logic
 // and to elide code for ciphersuites we don't verify yet
-// CF could be improved later, eg to securely ignore them
-
-// CF ``#if avoid'' should disappear.

 type events =
     | Authorize of Role * SessionInfo
@@ -34,7 +31,6 @@

 (* verify data authenticated by the Finished messages *)
 type log = bytes         (* message payloads so far, to be eventually authenticated *)
-//CF also defined in HandshakeMessages??

 // The constructor indicates either what we are doing locally or which peer message we are expecting,

@@ -306,7 +302,7 @@
     if i = true then
         state
     else
-        let si = epochSI(ci.id_in) in // FIXME: which epoch to choose? Here it matters since they could be mis-aligned
+        let si = epochSI(ci.id_in) in
         match si.sessionID with
         | xx when length xx = 0 -> state
         | sid ->
@@ -324,7 +320,6 @@
    let id_out = abbrEpoch ci.id_out ai si pe in
     {ci with id_in = id_in; id_out = id_out}

-
 type outgoing =
   | OutIdle of nextState
   | OutSome of range * HSFragment.plain * nextState
@@ -334,10 +329,7 @@
   | OutComplete of range * HSFragment.plain * nextState

 let check_negotiation (r:Role) (si:SessionInfo) (c:config) =
-  Pi.assume (Negotiated(r,si,c,c)) (* FIXME: Dummy definition.
-                                      Define valid negotiations *)
-  //CF ??
-
+  Pi.assume (Negotiated(r,si,c,c))

 let next_fragment ci state =
     match state.hs_outgoing with
@@ -353,8 +345,7 @@
                 let nki_in = id next_ci.id_in in
                 let nki_out = id next_ci.id_out in
                 let (reader,writer) = PRF.keyGenClient nki_in nki_out ms in
-                //CF now passing si, instead of next_ci.id_out
-                //CF but the precondition should be on F(si)
+
                 let cvd = PRF.makeVerifyData si ms Client log in
                 let cFinished = messageBytes HT_finished cvd in
                 let log = log @| cFinished in
@@ -377,7 +368,7 @@
                 let (rg,f,_) = makeFragment ki_out CCSBytes in
                 let ci = {ci with id_out = e} in
 #if verify
-                Pi.expect (Complete(ci)); // CF should disappear!
+                Pi.expect (Complete(ci));
 #endif
                 OutCCS(rg,f,ci,w,
                        {state with hs_outgoing = cFinished;
@@ -393,7 +384,7 @@
                 let (rg,f,_) = makeFragment ki_out CCSBytes in
                 let ci = {ci with id_out = e} in
 #if verify
-                Pi.expect(Complete(ci)); // CF should disappear!
+                Pi.expect(Complete(ci));
 #endif
                 OutCCS(rg,f,ci,w,
                        {state with hs_outgoing = sFinished;
@@ -488,9 +479,6 @@
   | InCCSAck of ConnectionInfo * StatefulLHAE.state * hs_state
   | InCCSError of alertDescription * string * hs_state

-
-
-
 /// ClientKeyExchange
 let find_client_cert_sign certType certAlg (distName:list<string>) pv hint =
     match pv with
@@ -550,7 +538,7 @@
         match Cert.get_chain_public_encryption_key si.serverID with
         | Error(z) -> Error(z)
         | Correct(pubKey) ->
-    (*KB: RSA-PMS-KEM (client) *)
+
             let pms = PMS.genRSA pubKey config.maxVer in
             let encpms = RSA.encrypt pubKey config.maxVer pms in
             let mex = clientKeyExchangeBytes_RSA si encpms in
@@ -564,7 +552,7 @@
         | Correct(pk) ->
             (match parseClientKeyExchange_RSA si data with
             | Correct(encPMS) ->
-        (*KB: RSA-PMS-KEM (server) *)
+
                 let res = RSA.decrypt skey si cv config.check_client_version_in_pms_for_old_tls encPMS in
                 correct(pk,(*RSAPMS(pk,cv,encPMS),*)res)
             | Error(z) -> Error(z))
@@ -580,7 +568,7 @@
          | Correct(v) ->
            let (pk,clientKEXBytes,rsapms)  = v in
            let cv = cfg.maxVer in
-           (*KB: RSA-MS-KEM (client) *)
+
            let pms = PMS.RSAPMS(pk,cv,rsapms) in
            let pmsid = pmsId pms in
            let log = log @| clientKEXBytes in
@@ -604,7 +592,7 @@
          | Correct(v) ->
            let (pk,clientKEXBytes,rsapms)  = v in
            let cv = cfg.maxVer in
-           (*KB: RSA-MS-KEM (client) *)
+
            let pms = PMS.RSAPMS(pk,cv,rsapms) in
            let pmsid = pmsId pms in
            let si = {si with pmsId = pmsid} in
@@ -631,7 +619,7 @@
          | Correct(v) ->
            let (pk,clientKEXBytes,rsapms)  = v in
            let cv = cfg.maxVer in
-           (*KB: RSA-MS-KEM (client) *)
+
            let pms = PMS.RSAPMS(pk,cv,rsapms) in
            let pmsid = pmsId pms in
            let si = {si with pmsId = pmsid} in
@@ -639,11 +627,11 @@
            let (si,ms) = extract si pms log in

 #if verify
-           (* KB: need to prove Sig.Msg(a,PK(sk),log) here if cert_req = Some ((cl,a,sk)) *)
+
            Pi.expect (UpdatesPmsClientID(si_old,si));
            Pi.expect (ClientLogBeforeCertificateVerifyRSA_Auth(si,log));
 #endif
-           (* FIXME: here we should shred pms *)
+
            let (certificateVerifyBytes,_) = makeCertificateVerifyBytes si ms algs skey log in
            let log = log @| certificateVerifyBytes in

@@ -657,7 +645,6 @@
            correct ({state with hs_outgoing = new_outgoing},si,ms,log))
     | _ -> Error.unexpected "[prepare_client_output_full_RSA] unreachable pattern match"

-
 (*
 let sessionInfoCertBytesAuth (si:SessionInfo) (cert_req:Cert.sign_cert)=
   if si.client_auth then
@@ -691,7 +678,6 @@
   (cert_req:Cert.sign_cert) (dhp:dhparams) (sy:DHGroup.elt) (log:log) : Result<(hs_state * SessionInfo * PRF.masterSecret * log)> =
     (* pre: Honest(verifyKey(si.server_id)) /\ StrongHS(si) -> DHGroup.PP(dhp) /\ ServerDHE(dhp,sy,si.init_crand @| si.init_srand) *)
     (* moreover, by definition ServerDHE(dhp,sy,si.init_crand @| si.init_srand) implies ?sx.DHE.Exp(dhp,sx,sy) *)
-    (*FIXME formally, the need for signing nonces is unclear *)

     match cert_req with
     | Some x when si.client_auth = true ->
@@ -704,14 +690,13 @@
          let cfg = state.poptions in

          (* this implements ms-KEM(DH).enc with pk = (dhp,sy) and (pv,h,l) from si *)
-         (*KB DH-PMS-KEM (client) *)
+
          let (cy,dhpms) = DH.clientGenExp dhp sy in
          (* post: DHE.Exp(dhp,x,cy) *)

          let clientKEXBytes = clientKEXExplicitBytes_DH cy in
          let log = log @| clientKEXBytes in

-         (*KB DH-MS-KEM *)
          let pms = PMS.DHPMS(dhp.dhp,dhp.dhg,sy,cy,dhpms) in
          let pmsid = pmsId pms in
          let si = {si with pmsId = pmsid} in
@@ -723,11 +708,8 @@
          (* thus we have Honest(verifyKey(si.server_id)) /\ StrongHS(si) -> PRFs.Secret(ms) *)
          (* si is now constant *)

-         (*FIXME unclear what si guarantees for the ms; treated as an abstract index for now *)
-         (*FIXME DHE.zeroPMS si pms; *)
-
 #if verify
-           (* KB: need to prove Sig.Msg(a,PK(sk),log) here if cert_req = Some ((cl,a,sk)) *)
+
          Pi.expect (UpdatesPmsClientID(si_old,si));
          Pi.expect (ClientLogBeforeCertificateVerifyDHE_Auth(si,log));
 #endif
@@ -751,14 +733,13 @@
          let cfg = state.poptions in

          (* this implements ms-KEM(DH).enc with pk = (dhp,sy) and (pv,h,l) from si *)
-         (*KB DH-PMS-KEM (client) *)
+
          let (cy,dhpms) = DH.clientGenExp dhp sy in
          (* post: DHE.Exp(dhp,x,cy) *)

          let clientKEXBytes = clientKEXExplicitBytes_DH cy in
          let log = log @| clientKEXBytes in

-         (*KB DH-MS-KEM *)
          let pms = PMS.DHPMS(dhp.dhp,dhp.dhg,sy,cy,dhpms) in
          let pmsid = pmsId pms in
          let si = {si with pmsId = pmsid} in
@@ -770,9 +751,6 @@
          (* thus we have Honest(verifyKey(si.server_id)) /\ StrongHS(si) -> PRFs.Secret(ms) *)
          (* si is now constant *)

-         (*FIXME unclear what si guarantees for the ms; treated as an abstract index for now *)
-         (*FIXME DHE.zeroPMS si pms; *)
-
          let to_send = clientCertBytes @| clientKEXBytes in
          let new_outgoing = state.hs_outgoing @| to_send in
 #if verify
@@ -786,14 +764,13 @@
          let cfg = state.poptions in

          (* this implements ms-KEM(DH).enc with pk = (dhp,sy) and (pv,h,l) from si *)
-         (*KB DH-PMS-KEM (client) *)
+
          let (cy,dhpms) = DH.clientGenExp dhp sy in
          (* post: DHE.Exp(dhp,x,cy) *)

          let clientKEXBytes = clientKEXExplicitBytes_DH cy in
          let log = log @| clientKEXBytes in

-         (*KB DH-MS-KEM *)
          let pms = PMS.DHPMS(dhp.dhp,dhp.dhg,sy,cy,dhpms) in
          let pmsid = pmsId pms in
          let si = {si with pmsId = pmsid} in
@@ -805,9 +782,6 @@
          (* thus we have Honest(verifyKey(si.server_id)) /\ StrongHS(si) -> PRFs.Secret(ms) *)
          (* si is now constant *)

-         (*FIXME unclear what si guarantees for the ms; treated as an abstract index for now *)
-         (*FIXME DHE.zeroPMS si pms; *)
-
          let to_send = clientKEXBytes in
          let new_outgoing = state.hs_outgoing @| to_send in
 #if verify
@@ -817,7 +791,6 @@
          correct ({state with hs_outgoing = new_outgoing},si,ms,log)
     | _ -> Error.unexpected "[prepare_client_output_full_DHE] unreachable pattern match"

-
 let on_serverHello_full (ci:ConnectionInfo) crand log to_log (shello:ProtocolVersion * srand * sessionID * cipherSuite * Compression * bytes) extL =
     let log = log @| to_log in
     let (sh_server_version,sh_random,sh_session_id,sh_cipher_suite,sh_compression_method,sh_neg_extensions) = shello in
@@ -848,7 +821,6 @@
     else
         unexpected "[on_serverHello_full] Unknown ciphersuite"

-
 let parseMessageState (ci:ConnectionInfo) state =
     match parseMessage state.hs_incoming with
     | Error(z) -> Error(z)
@@ -951,7 +923,7 @@
                                     let (reader,writer) = PRF.keyGenClient nki_in nki_out ms in
                                     let nout = next_ci.id_out in
                                     let nin = next_ci.id_in in
-                                    (* KB: the following should come from the sessiondb *)
+
                                     Pi.expect (Authorize(Client,si)); // annotation
                                     recv_fragment_client ci
                                         {state with pstate = PSClient(ServerCCSResume(nout,writer,
@@ -1020,7 +992,7 @@
                     else
                         InError(AD_bad_certificate_fatal, perror __SOURCE_FILE__ __LINE__ "Server sent wrong certificate type",state))
             | ServerCertificateDH (si,log) ->
-                InError(AD_internal_error, perror __SOURCE_FILE__ __LINE__ "Unimplemented",state) // TODO
+                InError(AD_internal_error, perror __SOURCE_FILE__ __LINE__ "Unimplemented",state)
             | _ ->
                 InError(AD_unexpected_message, perror __SOURCE_FILE__ __LINE__ "Certificate arrived in the wrong state",state))

@@ -1110,9 +1082,6 @@
                     let client_cert = find_client_cert_sign certType alg distNames si.protocol_version state.poptions.client_name in
                     let si' = {si with client_auth = true} in

-                    (* KB: Inserted another authorize here. We lack a mechanism for the client to refuse client auth! *)
-                    (* AP: Client identity is fixed at protocol start. An empty identity will generate an empty certificate
-                       message, which means refusal of client auth. *)
 #if verify
                     Pi.expect (UpdatesClientAuth(si,si'));
 #endif
@@ -1234,7 +1203,6 @@
                     InError(AD_decode_error, perror __SOURCE_FILE__ __LINE__ "",state)
             | _ -> InError(AD_unexpected_message, perror __SOURCE_FILE__ __LINE__ "ServerHelloDone arrived in the wrong state",state))

-
         | HT_finished ->
             (match cState with
             | ServerFinished(si,ms,e,cvd,log) ->
@@ -1250,7 +1218,7 @@
                     in
                     (* Should prove from checkVerifyData above *)
 #if verify
-                    Pi.expect (Complete(ci)); // CF should disappear
+                    Pi.expect (Complete(ci));
 #endif
                     check_negotiation Client si state.poptions;
                     InComplete({state with pstate = PSClient(ClientIdle(cvd,payload)); sDB = sDB}))
@@ -1310,7 +1278,7 @@
 #if verify
   failwith "not implemented fixed DH"
 #else
-  Error(AD_internal_error, perror __SOURCE_FILE__ __LINE__ "Unimplemented") // TODO
+  Error(AD_internal_error, perror __SOURCE_FILE__ __LINE__ "Unimplemented")
 #endif

 let prepare_server_output_full_DHE (ci:ConnectionInfo) state si certAlgs sExtL log =
@@ -1331,7 +1299,7 @@
         let certificateB = serverCertificateBytes c in

         (* ServerKeyExchange *)
-        (*KB DH-PMS-KEM (server 1) *)
+
         let dhparams_filename = state.poptions.dhDefaultGroupFileName in
         let ops = state.poptions in
         let dhstrength = ops.dhPQMinLength in
@@ -1382,7 +1350,6 @@

     (* ServerKEyExchange *)

-    (*KB DH-PMS-KEM (server 1) *)
     let default_params_filename = state.poptions.dhDefaultGroupFileName in
     let ops = state.poptions in
     let dhstrength = ops.dhPQMinLength in
@@ -1477,14 +1444,6 @@
             | None -> Error(AD_handshake_failure, perror __SOURCE_FILE__ __LINE__ "Compression method negotiation"))
         | None ->     Error(AD_handshake_failure, perror __SOURCE_FILE__ __LINE__ "Ciphersuite negotiation")

-
-(*CF: recursive only to enable processing of multiple messages;
-      can we loop externally, and avoid passing agreedVersion?
-      we retry iff the result is not InAck or InError.
-      What can we do after InError btw? *)
-
-(*CF: we should rediscuss this monster pattern matching, factoring out some of it. *)
-
 let rec recv_fragment_server (ci:ConnectionInfo) (state:hs_state) (agreedVersion:option<ProtocolVersion>) =
     match parseMessageState ci state with
     | Error(z) -> let (x,y) = z in  InError(x,y,state)
@@ -1493,7 +1452,7 @@
       | None ->
           (match agreedVersion with
           | None      -> InAck(state)
-          | Some (pv) -> InVersionAgreed(state,pv)) (*CF: why? AP: Needed in first handshake, to check the protocol version at the record level. (See sec E.1 RFC5246) *)
+          | Some (pv) -> InVersionAgreed(state,pv))
       | Some (res) ->
       let (state,hstype,payload,to_log) = res in
       match state.pstate with
@@ -1598,7 +1557,7 @@
                                 InQuery(certs,false,{state with pstate = PSServer(ServerCheckingCertificateDHE(si,dhp,gx,x,log,certs,to_log))})
                     else
                         InError(AD_bad_certificate_fatal, perror __SOURCE_FILE__ __LINE__ "Client sent wrong certificate type",state))
-            | ClientCertificateDH  (si,log) -> (* TODO *) InError(AD_internal_error, perror __SOURCE_FILE__ __LINE__ "Unimplemented",state)
+            | ClientCertificateDH  (si,log) ->  InError(AD_internal_error, perror __SOURCE_FILE__ __LINE__ "Unimplemented",state)
             | _ -> InError(AD_unexpected_message, perror __SOURCE_FILE__ __LINE__ "Certificate arrived in the wrong state",state))

         | HT_client_key_exchange ->
@@ -1608,14 +1567,13 @@
                 | Error(z) -> let (x,y) = z in  InError(x,y,state)
                 | Correct(x) ->
                     let (pk,rsapms) = x in
-                (*KB: RSA-MS-KEM (server) *)
+
                     let pms = PMS.RSAPMS(pk,cv,rsapms) in
                     let pmsid = pmsId pms in
                     let si = {si with pmsId = pmsid} in
                     let log = log @| to_log in
                     let (si,ms) = extract si pms log in

-                    (* TODO: we should shred the pms *)
                     (* move to new state *)
                     if si.client_auth then (
 #if verify
@@ -1643,22 +1601,20 @@
                        (pv,h,l) are included in si, sk is ((dhp,gx),x), c is y *)

                     (* these 2 lines implement pms-KEM(DH).dec(pv?, sk, c) *)
-            (*KB DH-PMS-KEM (server 2) *)
+
                     let dhpms = DH.serverExp dhp gx y x in

-            (*KB DH-MS-KEM *)
                     let pms = PMS.DHPMS(dhp.dhp,dhp.dhg,gx,y,dhpms) in
                     let si_old = si in
                     let si = {si_old with pmsId = pmsId(pms)} in
 #if verify
-                    Pi.expect(UpdatesPmsID(si_old,si)); (*KB: to be removed*)
+                    Pi.expect(UpdatesPmsID(si_old,si));

 #endif
                     (* StrongHS(si) /\ DHE.Exp(dhp,?cx,y) -> DHE.Secret(pms) *)
                     let (si,ms) = extract si pms log in
                     (* StrongHS(si) /\ DHE.Exp(dhp,?cx,y) -> PRFs.Secret(ms) *)

-                    (* TODO in e.g. DHE: we should shred the pms *)
                     (* we rely on scopes & type safety to get forward secrecy*)
                     (* move to new state *)
                     if si.client_auth then (
@@ -1686,14 +1642,12 @@
                 | Error(z) -> let (x,y) = z in  InError(x,y,state)
                 | Correct(y) ->
                     let log = log @| to_log in
-                    //MK We should also store the pmsId
-            (*KB DH-PMS-KEM (server 2) *)
+
                     let dhpms = DH.serverExp dhp gx y x in

-            (*KB DH-MS-KEM *)
-                    let pms = PMS.DHPMS(dhp.dhp,dhp.dhg,gx,y,dhpms) in //MK is the order of y, gx right?
+                    let pms = PMS.DHPMS(dhp.dhp,dhp.dhg,gx,y,dhpms) in
                     let (si,ms) = extract si pms log in
-                    (* TODO: here we should shred pms *)
+
                     (* move to new state *)
                     recv_fragment_server ci
                       {state with pstate = PSServer(ClientCCS(si,ms,log))}
@@ -1736,7 +1690,7 @@
                 if PRF.checkVerifyData si ms Client log payload then
                     (
 #if verify
-                    Pi.expect (Complete(ci)); // CF Should disappear!
+                    Pi.expect (Complete(ci));
 #endif
                     check_negotiation Server si state.poptions;
                     InComplete({state with pstate = PSServer(ServerIdle(payload,svd))}))
@@ -1753,7 +1707,7 @@
     {state with hs_incoming = new_inc}

 let recv_fragment ci (state:hs_state) (r:range) (fragment:HSFragment.fragment) =
-    // FIXME: cleanup when Hs is ported to streams and deltas
+
     let ki_in = id ci.id_in in
     let b = HSFragment.fragmentRepr ki_in r fragment in
     if length b = 0 then
@@ -1766,7 +1720,7 @@
         | PSServer (_) -> recv_fragment_server ci state None

 let recv_ccs (ci:ConnectionInfo) (state: hs_state) (r:range) (fragment:HSFragment.fragment): incomingCCS =
-    // FIXME: cleanup when Hs is ported to streams and deltas
+
     let ki_in = id ci.id_in in
     let b = HSFragment.fragmentRepr ki_in r fragment in
     if equalBytes b CCSBytes then
@@ -1800,14 +1754,13 @@
   let pop = state.poptions in
   pop.minVer

-// CF ?? the need for q, the Pi.assume, and code duplication
 let authorize (ci:ConnectionInfo) (state:hs_state) (q:Cert.chain) =
     let pstate = state.pstate in
     match pstate with
     | PSClient(cstate) ->
         (match cstate with
         | ClientCheckingCertificateRSA(si,log,certs,agreedVersion,to_log) when certs = q ->
-            // CF why logging certs for RSA and not DH? why letting the user change the cert??
+
             if certs = q then
               let log = log @| to_log in
               let si' = {si with serverID = certs} in
diff -Ewbur /opt/mitls/lib/Handshake.fs7 /opt/miTLS-0.8.1/lib/Handshake.fs7
--- /opt/mitls/lib/Handshake.fs7        2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/Handshake.fs7  2014-12-04 17:11:26.000000000 +0100
@@ -2,54 +2,6 @@

 open CoreKeys

-(* KB Handshake Verification Status:
-   Remove injected Pi.assume(CompleteEpoch(...))
-   Remove injected Pi.assume(Authorize(...)) for resumed sessions
-   Remove injected Pi.assume(LMsg(...)) for signature use
-   Add elements from the epoch into log predicate: cr,sr,cvd,svd,role
-   Added cr, sr into resumption log predicates. Need to add cvd, svd into all predicates.
-
-   Maybe rename SentCCS to EpochFinished? Just before makeVerifyData. Maybe add a new event after makeVerifyData.
-
-   Want to remove CompleteEpoch. Make Complete private. Use only asks.
-   Want to introduce special SentCCSResume
-   Want to introduce clientSigAlg and serverSigAlg in SessionInfo
-   Want to introduce vd_out and vd_in into ConnectionInfo: update when sending CCS, when receiving Finished
-   Introduce old and new vd into SentCCS and SentCCSResume
-*)
-
-(*
- MK. Comments about Handshake from other modules:
-
- TODO from Sig.fs7: there is some adhocness processing of sigHashAlg, sigAlg, hashAlg left in Handshake.fs
-
- CF
- --- summary of our discussion on Apr 29, towards typechecking the HS.
-
- MK. factually a bit outdated, but moved here from PRF to mark the 1 year anniversary. :)
-
- The following predicate controls StAE idealization
- (relative to StAE's algorithmic strength)
- it is ideally used much before it can be proved as the HS completes.
-
-From its definition in TLSInfo.fs7 we know that
-SafeHS_SI(si) <=> !r:Role.
-     HonestMS(MsI(si)) /\
-     SafeKDF(SiId(id,r) /\
-     SafeVD(si)
-
- In HS, we have
-  - KeyGenClient(id.csrConn, id.pv, id.aeAlg, id.ext) for id=Id(e) is a precondition to the event ClientSentCCS(e)
-  - KeyCommit(id.csrConn, id.pv, id.aeAlg, id.ext)    for id=Id(e) is a precondition to the event ServerSentCCS(e)
-  - HonestMS /\ StrongVD are sufficient to guarantee
-    matching ClientSentCCS(e) and ServerSentCCS(e), hence getting
-     (1) SafeKDF, and
-     (2) e is the only wide index associated with Id(e)
-
-    This enables us to prove Complete, roughly as currently defined:
-    Complete <=> (HonestPMS /\ StrongHS => SafeHS)
-*)
-
 open Bytes
 open Error
 open TLSError
@@ -74,18 +26,12 @@
 // If we select a session from the DB, the user previously authorized it
 private theorem !r,si. SessionDB.Authorize(r,si) => Authorize(r,si)

-//CF why this indirection to SessionDB? wrong direction? is it too early?
-
-
 predicate UpdatesClientAuth of SessionInfo * SessionInfo
 predicate EvSentFinishedFirst of ConnectionInfo * bool
-predicate Negotiated of Role * SessionInfo * config * config //CF dynamically assumed, why?
+predicate Negotiated of Role * SessionInfo * config * config
 predicate CompleteEpoch of Role * epoch
 predicate Complete of ConnectionInfo

-// CF CompleteEpoch duplicating TLSInfo with different arity??
-// CF UpdatesClientAuth missing; LMsg declare below.
-
 val check_negotiation: r:Role -> si:SessionInfo -> cfg:config -> unit{?cfg'. Negotiated(r,si,cfg,cfg')}

 (* Anonymous clients are authorized for client-unauthenticated sessions *)
@@ -96,7 +42,6 @@
 private assume !r,si,si'. Authorize(Server,si) /\ SessionHelloParams(si,()) =
   SessionHelloParams(si',()) /\ si'.serverID = si.serverID /\ si'.clientID = si.clientID /\ si'.client_auth = si.client_auth => Authorize(Server,si')

-
 private definition !a,k,t. Sig.Msg(a,k,t)
   <=> ((?si,pk,pv,r.
            ClientLogBeforeCertificateVerifyRSA_Auth(si,t) /\
@@ -117,7 +62,6 @@
            k = Cert.SigPKCert(si.serverID,a))
            )

-
 ask !si,pk,pv,r,t,a,k.
            ClientLogBeforeCertificateVerifyRSA_Auth(si,t)
          /\ si.pmsId = PmsId(PMS.RSAPMS(pk,pv,r))
@@ -125,7 +69,6 @@
          /\  k = Cert.SigPKCert(si.clientID,a)
            => Sig.Msg(a,k,t)

-
 ask !si,p,g,gc,gs,r,a,k,t.
            ClientLogBeforeCertificateVerifyDHE_Auth(si,t) /\
               si.pmsId = PmsId(PMS.DHPMS(p,g,gs,gc,r)) /\
@@ -141,7 +84,6 @@
            k = Cert.SigPKCert(si.serverID,a)
            => Sig.Msg(a,k,t)

-
 ask !si,p,g,gs,a,k,t.
            B(t) = B(si.init_crand) @| B(si.init_srand) @| DHEParamBytes(p,g,gs) /\
            Length(si.init_crand) = 32 /\
@@ -150,8 +92,7 @@
            k = Cert.SigPKCert(si.serverID,a) =>
            (DHGroup.PP(p,g) /\ DH.HonestExponential(p,g,gs))

-
-predicate LMsg of  a:Sig.alg * (;a)Sig.skey * log // CF only for testing, will go
+predicate LMsg of  a:Sig.alg * (;a)Sig.skey * log
 assume !cl,a,sk,l. LMsg(a,sk,l) => Sig.Msg(a,Sig.PK(sk),l)

 predicate LClientFinishedResume of epoch * log // for testing
@@ -175,7 +116,6 @@
         SentCCSAbbr(Server,{abbr_crand = ai.abbr_crand; abbr_srand = ai.abbr_srand; abbr_session_hash = si.session_hash; abbr_vd = ai.abbr_vd}) /\
         ServerLogBeforeServerFinishedResume(ai,si,b)))

-
 ask !si,b. PRF.VerifyData(MsI(si),Client,b) /\
     ServerLogBeforeClientFinished(si,b) => SentCCS(Client,si)

@@ -202,10 +142,6 @@
        MsI(si) = MsI(si') => si = si'
 *)

-
-
-(* KB: revisit this defn; its evolved many times *)
-
 private definition !role,e.
   CompleteEpoch(role,e)
   <=>
@@ -228,7 +164,6 @@

 (* Negotiated remains to be defined but it can be a nice global spec of what HS is meant to achieve.
    Especially interesting would be proving that the result is the "best possible" *)
-// CF irrelevant here? status?

 (*
 private definition !ci. Complete(ci) <=>
@@ -368,9 +303,6 @@
             EpochSI(newin) = EpochSI(newout) /\
             oldout = Pred(newout) /\ oldin = Pred(newin))

-
-
-
 // The constructor indicates either what we are doing locally or which peer message we are expecting,
 type (;ci:ConnectionInfo) serverState =  (* note that the CertRequest bits are determined by the config *)
                     (* we may omit some ProtocolVersion, mostly a ghost variable *)
@@ -397,7 +329,6 @@
        DHGroup.PP(dhp.dhp,dhp.dhg) /\ DH.HonestExponential(dhp.dhp,dhp.dhg,gx) /\
        ServerLogBeforeClientKeyExchangeDHE(si,l) /\ (si.client_auth = true => (si.clientID <> [] /\ Authorize(Server,si)))}

-
    | ClientKeyExchangeDH_anon     of SessionInfo * dhp:dhparams * gx:(;dhp.dhp,dhp.dhg)DHGroup.elt * (;dhp.dhp,dhp.dhg,gx)DH.secret * log{
           DHGroup.PP(dhp.dhp,dhp.dhg) /\ DH.HonestExponential(dhp.dhp,dhp.dhg,gx)}

@@ -472,7 +403,6 @@
    | ServerIdle                   of cVerifyData * sVerifyData
    (* the ProtocolVersion is the highest TLS version proposed by the client *)

-
 type (;ci:ConnectionInfo) clientState =
    | ServerHello                  of cr:crand * sid:sessionID * cl:(clientExtension list) * cvd:cVerifyData * svd:sVerifyData * l:log{ClientLogBeforeServerHello(cr,l)}

@@ -604,25 +534,6 @@
 function val Config: ci:ConnectionInfo * s:(;ci)hs_state -> config
 private definition !ci,s. Config(ci,s) = s.poptions

-// AP: Commenting out until we restore streams for HS. Should be ported to EmptyStream as functions
-// AP: function val HSOutStream:  ci:ConnectionInfo * (;ci)hs_state -> 'a //(;ci.id_out)stream
-// AP: function val CCSOutStream: ci:ConnectionInfo * (;ci)hs_state -> 'a //(;ci.id_out)stream
-// AP: function val HSInStream:   ci:ConnectionInfo * (;ci)hs_state -> 'a //(;ci.id_in) stream
-// AP: function val CCSInStream:  ci:ConnectionInfo * (;ci)hs_state -> 'a //(;ci.id_in) stream
-// AP:
-// AP: predicate EmptyStreams of ci:ConnectionInfo * (;ci)hs_state
-// AP: predicate SameStreams of ci:ConnectionInfo * (;ci)hs_state * (;ci)hs_state
-// AP: definition !ci,s. EmptyStreams(ci,s) <=> (
-// AP:                 HSFragment.EmptyStream(ci.id_in,HSInStream(ci,s)) /\
-// AP:                 HSFragment.EmptyStream(ci.id_in,CCSInStream(ci,s)) /\
-// AP:                 HSFragment.EmptyStream(ci.id_out,HSOutStream(ci,s)) /\
-// AP:                 HSFragment.EmptyStream(ci.id_out,CCSOutStream(ci,s)) )
-// AP: definition !ci,s,s'. SameStreams(ci,s,s') <=> (
-// AP:                 HSInStream(ci,s') = HSInStream(ci,s) /\
-// AP:                 CCSInStream(ci,s') = CCSInStream(ci,s) /\
-// AP:                 HSOutStream(ci,s') = HSOutStream(ci,s) /\
-// AP:                 CCSOutStream(ci,s') = CCSOutStream(ci,s) )
-
 type (;ci:ConnectionInfo,c:config) nextState = s:(;ci)hs_state {Config(ci,s) = c}

 val init:  rl:Role  -> c:config  ->
@@ -653,7 +564,6 @@
 val invalidateSession: ci:ConnectionInfo -> s:(;ci)hs_state -> s':(;ci,Config(ci,s))nextState
 (*{SameStreams(ci,s,s')} *)

-
 val getFullEpochs: ci:ConnectionInfo -> si:SessionInfo -> ci':ConnectionInfo{
     NextFullEpochs(ci.id_in,ci.id_out,ci'.id_in,ci'.id_out) /\
     EpochSI(ci'.id_in) = si /\
@@ -694,7 +604,6 @@
                    (;ci,Config(ci,s))incoming
 val authorize:     ci:ConnectionInfo -> s:(;ci)hs_state ->
                    c:Cert.chain -> (;ci,Config(ci,s))incoming
-// CF fix? as written, authorize provides no guarantees that c is related to ci before/after the call.

 type (;ci:ConnectionInfo,c:config)incomingCCS =
   | InCCSAck of ci':ConnectionInfo * cs:(;Id(ci'.id_in),Reader)StatefulLHAE.state * (;ci',c)nextState
@@ -817,8 +726,6 @@
        (;ci,Config(ci,s))incoming
 val enqueue_fragment: ci:ConnectionInfo -> s1:(;ci)hs_state -> bytes -> s2:(;ci)hs_state{Config(ci,s1) = Config(ci,s2)}

-(* CF removed large commented out stuff; see prior revisions *)
-
 (*
 val sessionInfoCertBytesAuth: (si:SessionInfo) ->
   (clo: (Cert.chain * a:Sig.alg * (;a)Sig.skey) option) ->
Only in /opt/mitls/lib: HandshakeComments.txt
diff -Ewbur /opt/mitls/lib/HandshakeMessages.fs /opt/miTLS-0.8.1/lib/HandshakeMessages.fs
--- /opt/mitls/lib/HandshakeMessages.fs 2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/HandshakeMessages.fs   2014-12-04 17:11:26.000000000 +0100
@@ -114,7 +114,6 @@
 //         | Error z -> Error z
 //     | Error z -> Error z

-
 (** General message parsing *)
 let splitMessage ht data =
   if length data >= 1 then
@@ -349,7 +348,6 @@

 let CCSBytes = abyte 1uy

-
 (** A.4.2 Server Authentication and Key Exchange Messages *)

 let serverHelloDoneBytes = messageBytes HT_server_hello_done empty_bytes
@@ -357,7 +355,7 @@
 let serverCertificateBytes cl = messageBytes HT_certificate (Cert.certificateListBytes cl)

 let clientCertificateBytes (cs:option<(Cert.chain * Sig.alg * Sig.skey)>) =
-    // TODO: move this match outside, and merge with serverCertificateBytes
+
     match cs with
     | None -> let clb = Cert.certificateListBytes [] in messageBytes HT_certificate clb
     | Some(v) ->
@@ -427,11 +425,7 @@
             match parseDistinguishedNameList distNamesBytes el with
             | Error(z) -> Error(z)
             | Correct (distNamesList) ->
-            #if avoid
-            failwith "commenting out since we run out of memory"
-            #else
             correct (certTypeList,sigAlgs,distNamesList)
-            #endif

         else Error(AD_decode_error, perror __SOURCE_FILE__ __LINE__ "")
     else Error(AD_decode_error, perror __SOURCE_FILE__ __LINE__ "")
diff -Ewbur /opt/mitls/lib/HandshakeMessages.fs7 /opt/miTLS-0.8.1/lib/HandshakeMessages.fs7
--- /opt/mitls/lib/HandshakeMessages.fs7        2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/HandshakeMessages.fs7  2014-12-04 17:11:26.000000000 +0100
@@ -19,7 +19,6 @@
     val clientHelloBytes: cr:random -> ...  -> m:bytes{B(m) = ClientHelloMsg(cr,...)}
     val parseClientHello: m:bytes -> (cr:crand * ...  {?... . MessageBytes(HT_client_hello,B(m)) = ClientHelloMsg(cr,...}) Result

-
     Part 2: Predicates only, relating the current log to the more
     abstract parameters in the session info. (We have many distinct
     predicates, grouped by disjunctions as we join paths in the state
@@ -33,12 +32,6 @@

  *)

-(*  CF we may extend those parameters, e.g. to mention the existence of
-    received parameters used to correctly build the session info.
-
-    We may agree on more parameters, by extending the session info. *)
-
-
 (* Message Predicates *)
 type PreHandshakeType =
     | HT_hello_request
@@ -153,8 +146,6 @@
        (pv:ProtocolVersion * cr:crand * sid:sessionID * cs:cipherSuites * cm:Compression list * ext:bytes
          {?cs',cm'. MessageBytes(HT_client_hello,B(m)) = ClientHelloMsg(pv,cr,sid,cs',cm',ext)}) Result

-//KB TODO? /\ ContainsCipherSuites(cs',cs) /\ ContainsCompressions(cm',cm)}) Result
-
 ask !pv,cr,s,cs,cm,ex,pv',cr',s',cs',cm',ex'.
           IsProtocolVersion(pv) /\ IsProtocolVersion(pv')
        => BLength(B(cr)) = BLength(B(cr'))
@@ -220,7 +211,6 @@
                ( !cl,a',b'. clo = Some((cl,a',b')) => B(b) = CertificateMsg(cl)
                )}

-
 val parseClientOrServerCertificate: b:bytes ->
        (bl:Cert.cert list{
          MessageBytes(HT_certificate,B(b)) = CertificateMsg(bl)
@@ -287,7 +277,6 @@
            ClientKeyExchangeMsg_RSA(si.protocol_version,encpms) =
           MessageBytes(HT_client_key_exchange,B(b))}) Result

-
 function val ClientKeyExchangeMsg_DHE: bytes -> cbytes
 private definition !b.
        ClientKeyExchangeMsg_DHE(b) =
@@ -315,7 +304,7 @@
 val parseDigitallySigned: al:Sig.alg list -> b:bytes -> pv:ProtocolVersion ->
        ((a:Sig.alg * p:bytes){
                B(b) = DigitallySignedBytes(a,p,pv)
-               //KB TODO? /\ SigHashAlgContains(al,a)
+
        }) Result

 function val DHEParamBytes: bytes * bytes * bytes -> cbytes
@@ -359,7 +348,6 @@
 private definition !pv,a,sign.
                 CertificateVerifyMsg(pv,a,sign) = MessageBytes(HT_certificate_verify,DigitallySignedBytes(a,sign,pv))

-
 val makeCertificateVerifyBytes: si:SessionInfo -> (;si)PRF.masterSecret -> a:Sig.alg -> k:(;a)Sig.skey ->
   l:log{Sig.Msg(a,Sig.PK(k),l)} ->
        b:bytes * sign:bytes{
@@ -373,7 +361,6 @@
                /\ ((si.protocol_version <> SSL_3p0 /\ Sig.Strong(a) /\ Sig.Honest(a,Cert.SigPKCert(si.clientID,a))) =>
                     Sig.Msg(a,Cert.SigPKCert(si.clientID,a),l)))}

-
 //function val ServerFinishedMsg: si:SessionInfo * (;si)PRF.masterSecret * log -> bytes
 function val ServerFinishedMsg: sVerifyData -> cbytes

@@ -384,7 +371,6 @@

 definition !svd. ClientFinishedMsg(svd) = MessageBytes(HT_finished,B(svd))

-
 (* SessionInfo update predicates *)

 predicate UpdatesPmsClientID of SessionInfo * SessionInfo
@@ -402,7 +388,6 @@
       si'.client_auth = si.client_auth /\
       si'.sessionID = si.sessionID)

-
 predicate UpdatesPmsID of SessionInfo * SessionInfo
 definition !si,si'.
    UpdatesPmsID(si,si') <=>
@@ -420,7 +405,6 @@
       si'.serverSigAlg = si.serverSigAlg /\
       si'.sessionID = si.sessionID)

-
 predicate UpdatesClientID of SessionInfo * SessionInfo
 definition !si,si'.
    UpdatesClientID(si,si') <=>
@@ -438,7 +422,6 @@
       si'.client_auth = si.client_auth /\
       si'.sessionID = si.sessionID)

-
 predicate UpdatesClientIDSigAlg of SessionInfo * SessionInfo
 definition !si,si'.
    UpdatesClientIDSigAlg(si,si') <=>
@@ -455,7 +438,6 @@
       si'.client_auth = si.client_auth /\
       si'.sessionID = si.sessionID)

-
 predicate UpdatesClientSigAlg of SessionInfo * SessionInfo
 definition !si,si'.
    UpdatesClientSigAlg(si,si') <=>
@@ -525,7 +507,6 @@
       si'.client_auth = si.client_auth /\
       si'.sessionID = si.sessionID)

-
 predicate UpdatesClientAuth of SessionInfo * SessionInfo
 definition !si,si'.
    UpdatesClientAuth(si,si') <=>
@@ -543,7 +524,6 @@
       si'.serverSigAlg = si.serverSigAlg /\
       si'.sessionID = si.sessionID)

-
 (* Server Log predicates *)

 predicate ServerLogBeforeClientCertificateRSA of SessionInfo * ProtocolVersion * log
@@ -600,7 +580,6 @@
            ServerKeyExchangeMsg_DHE(si.protocol_version,p,g,y,a,sign) @|
            ServerHelloDoneMsg(empty_bytes))))

-
 predicate ServerLogBeforeClientKeyExchangeRSA of SessionInfo * ProtocolVersion * log
 predicate ServerLogBeforeClientKeyExchangeRSA_Auth of SessionInfo * ProtocolVersion * log
 predicate ServerLogBeforeClientKeyExchangeRSA_NoAuth of SessionInfo * ProtocolVersion * log
@@ -648,7 +627,6 @@
      si.pmsId = PmsId(PMS.RSAPMS(Cert.RSAPKCert(si.serverID),pv,r)) /\
      B(l) = B(l') @| ClientKeyExchangeMsg_RSA(si.protocol_version,encpms))

-
 predicate ServerLogBeforeClientCertificateVerifyDHE of SessionInfo * log

 definition !si,pv,l.
@@ -734,7 +712,6 @@
 predicate ClientLogBeforeServerHelloDoneRSA_Auth of SessionInfo * log
 predicate ClientLogBeforeServerHelloDoneRSA_NoAuth of SessionInfo * log

-
 definition !si,pv,l.
   ClientLogBeforeServerHelloDoneRSA(si,l) <=>
   ((si.client_auth = true /\ ClientLogBeforeServerHelloDoneRSA_Auth(si,l)) \/
@@ -790,7 +767,6 @@
   (?l',b. ClientLogBeforeServerHelloDoneDHE(si,l') /\
         B(l) = B(l') @| ServerHelloDoneMsg(b))

-
 predicate ClientLogBeforeCertificateVerifyRSA_Auth of SessionInfo * log

 definition !si,pv,l.
@@ -801,7 +777,6 @@
      B(l) = (B(l') @| CertificateMsg(si.clientID))
              @| ClientKeyExchangeMsg_RSA(si.protocol_version,encpms))

-
 predicate ClientLogBeforeCertificateVerifyDHE_Auth of SessionInfo * log

 definition !si,pv,l.
@@ -812,7 +787,6 @@
      B(l) = (B(l') @| CertificateMsg(si.clientID))
          @| ClientKeyExchangeMsg_DHE(b))

-
 predicate ClientLogBeforeClientFinishedRSA of SessionInfo * log
 predicate ClientLogBeforeClientFinishedRSA_Auth of SessionInfo * log
 predicate ClientLogBeforeClientFinishedRSA_TryNoAuth of SessionInfo * log
@@ -841,7 +815,6 @@
      B(l) = (B(l') @| CertificateMsg(si.clientID))
          @| ClientKeyExchangeMsg_RSA(si.protocol_version,encpms))

-
 definition !si,pv,l.
   ClientLogBeforeClientFinishedRSA_NoAuth(si,l) <=>
   (?si',l',encpms. ClientLogAfterServerHelloDoneRSA(si',l') /\
@@ -890,14 +863,12 @@
         (ClientLogBeforeClientFinishedRSA(si,l) \/
          ClientLogBeforeClientFinishedDHE(si,l))

-
 predicate ClientLogBeforeServerFinished of SessionInfo * log
 definition !si,l.
   ClientLogBeforeServerFinished(si,l) <=>
   (?l',cvd. ClientLogBeforeClientFinished(si,l') /\
      B(l) = B(l') @| ClientFinishedMsg(cvd))

-
 (* resumption log predicates *)

 predicate ServerLogBeforeServerFinishedResume of abbrInfo * SessionInfo * log
@@ -913,9 +884,6 @@
   (?l',svd.   ServerLogBeforeServerFinishedResume(ai,si,l') /\
     B(l) = B(l') @| ServerFinishedMsg(svd))

-(* KB: All these predicates must note all elements of the epoch except for the predecessor.
-   It may be worth defining a new type for the following:
-   current_crand, current_srand, si, cvd, svd, role *)
 predicate ClientLogBeforeServerFinishedResume of abbrInfo * SessionInfo * log
 definition !ai,si,l.
   ClientLogBeforeServerFinishedResume(ai,si,l) <=>
@@ -929,7 +897,6 @@
   (?l',svd.   ClientLogBeforeServerFinishedResume(ai,si,l') /\
     B(l) = B(l') @| ServerFinishedMsg(svd))

-
 (* -------------------------------------------------------------------- *)
 ask !si,si',t. ClientLogBeforeCertificateVerifyRSA_Auth(si,t) /\
                    ServerLogBeforeClientCertificateVerifyRSA(si',t) =>
@@ -993,7 +960,6 @@
                   Length(cr) = 32 /\ Length(sr) = 32 /\
                   B(t) = B(cr) @| B(sr) @| DHEParamBytes(p,g,gs)  => false

-
 ask !si,ai,si',t. ClientLogBeforeClientFinished(si,t) /\
                    ServerLogBeforeClientFinishedResume(ai,si',t)  => false

Only in /opt/mitls/lib: IdealDataStream.fs
Only in /opt/mitls/lib: IdealDataStream.fsi
diff -Ewbur /opt/mitls/lib/KEF.fs /opt/miTLS-0.8.1/lib/KEF.fs
--- /opt/mitls/lib/KEF.fs       2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/KEF.fs 2014-12-04 17:11:26.000000000 +0100
@@ -38,7 +38,6 @@
     let i = msi si in
     PRF.coerce i res

-
 let private accessRSAPMS (pk:RSAKey.pk) (cv:ProtocolVersion) pms =
   match pms with
   #if ideal
@@ -82,7 +81,6 @@
    Note that in this way many idealized master secrets can
    be derived from the same pms. *)

-
 let extract si pms: PRF.masterSecret =
     #if ideal
     if safeCRE si then
@@ -97,8 +95,6 @@
     #endif
         extractMS si (accessPMS pms)

-//MK unused? type log = bytes
-
 let private extractMS_extended si pmsBytes : PRF.masterSecret =
     let ca = kefAlg_extended si in
     let sh = si.session_hash in
diff -Ewbur /opt/mitls/lib/KEF.fs7 /opt/miTLS-0.8.1/lib/KEF.fs7
--- /opt/mitls/lib/KEF.fs7      2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/KEF.fs7        2014-12-04 17:11:26.000000000 +0100
@@ -10,14 +10,11 @@
 // concrete PMS --> MS derivation.
 // this implements the KEF call in the "generic ms-KEM construction".

-//MK unused? type log = bytes
-
 val extract:
     si:SessionInfo ->
        pms: pms { si.pmsId = PmsId(pms) } ->
     (;si) PRF.masterSecret

-// MK in addition includes the si.session_hash in the extraction, unverified for now
 val extract_extended:
     si:SessionInfo ->
        pms: pms { si.pmsId = PmsId(pms) } ->
diff -Ewbur /opt/mitls/lib/KEF.fsi /opt/miTLS-0.8.1/lib/KEF.fsi
--- /opt/mitls/lib/KEF.fsi      2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/KEF.fsi        2014-12-04 17:11:26.000000000 +0100
@@ -9,8 +9,5 @@
 open TLSError
 open PMS

-//MK unused? type log = bytes
-
 val extract: SessionInfo -> pms -> PRF.masterSecret
 val extract_extended: SessionInfo -> pms -> PRF.masterSecret
-
diff -Ewbur /opt/mitls/lib/LHAE.fs /opt/miTLS-0.8.1/lib/LHAE.fs
--- /opt/mitls/lib/LHAE.fs      2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/LHAE.fs        2014-12-04 17:11:26.000000000 +0100
@@ -57,7 +57,6 @@
         let ek = AEAD_GCM.COERCE e rw ekb ivb in
         GCM(ek)

-
 let LEAK e rw k =
     match k with
     | MACOnlyK(mk) -> MAC.LEAK e mk
@@ -182,7 +181,7 @@

 let rec cmem (e:id) (ad:LHAEPlain.adata) (c:ENC.cipher) (xs: list<entry>) =
 #if verify
-  failwith "specification only" //MK seems pretty bad. CF 14-07-16 needs fixing
+  failwith "specification only"
 #else
   match xs with
   | (e',ad',r,p,c')::_ when e=e' && ad=ad' && c=c' -> let x = (r,p) in Some x
@@ -193,13 +192,8 @@

 let encrypt (e:id) key data rg plain =
   let (key,cipher) = encrypt' e key data rg plain in
-#if ideal_F
-  if safeId  e then
-    log := (e,data,rg,plain,cipher)::!log
-  else ()
-#endif
 #if ideal
-  (* CF we do not log in all cases, as we do not have ENCrypted for MAC-only suites *)
+
   if safeId  e then
     log := (e,data,rg,plain,cipher)::!log
   else ();
@@ -208,13 +202,6 @@

 let decrypt (e:id) (key: LHAEKey) data (cipher: bytes) =
   let err = (AD_bad_record_mac,"") in
-#if ideal_F
-  if safeId  e then
-    match cmem e data cipher !log with
-    | Some _ -> decrypt' e key data cipher
-    | None   -> Error err
-  else
-#endif
 #if ideal
   if safeId  e then
     match cmem e data cipher !log with
diff -Ewbur /opt/mitls/lib/LHAE.fs7 /opt/miTLS-0.8.1/lib/LHAE.fs7
--- /opt/mitls/lib/LHAE.fs7     2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/LHAE.fs7       2014-12-04 17:11:27.000000000 +0100
@@ -35,10 +35,7 @@
 definition !enc,mac. KeySize(MtE(enc,mac))  = MacKeySize(mac) + EncKeySize(enc) + KeyDerivationIVSize(MtE(enc,mac))
 definition !enc,prf. KeySize(AEAD(enc,prf)) = AEADKeySize(enc) + AEADIVSize(enc)

-//CF not clearly useful MK helps typechecking LHAE.encrypt'
 ask !i,mac.     i.aeAlg = MACOnly(mac) => KeySize(i.aeAlg) = MacKeySize(mac)
-//MK strangely the following isn't needed for that
-//MK ask !i,mac,enc. i.aeAlg = MtE(enc,mac) => KeySize(i.aeAlg) = MacKeySize(mac) + EncKeySize(enc) + KeyDerivationIVSize(MtE(enc,mac))

 val GEN:    i:id     -> (;i)encryptor * (;i)decryptor
 val COERCE: i:id{not AuthId(i)} -> rw:rw -> b:bytes{Length(b) = KeySize(i.aeAlg)} -> (;i,rw)LHAEKey
@@ -58,7 +55,6 @@
 private definition !e,aenc,mac,ad,c.
   e.aeAlg = AEAD(aenc,mac) => (ENCrypted(e,ad,c) <=> ?p. AEAD_GCM.ENCrypted(e,ad,c,p))

-//CF 14-07-16 usage?
 ask !e,enc,mac,ad,c.
   e.aeAlg = MtE(enc,mac) /\ ( SafeId(e) => ENCrypted(e,ad,c)) =>
   (SafeId(e) => (?p. ENC.ENCrypted(e,ad,c,p)))
@@ -85,11 +81,6 @@
   entry list -> res:(r:range * (;i,ad,r)LHAEPlain.plain) option {
     ( !rg,p. res = Some ((rg,p)) => (ENCrypted(i,ad,c) /\ rg = CipherRangeClass(i,Length(c))) ) /\
        ( res = None => not ENCrypted(i,ad,c) )}
-//CF 14-07-17 we effectively assume this non-trivial postcondition; TODO.
-
-(*CF
-theorem !i,d,rg0,p0,rg1,p1,c. (ENCrypted(i,d,rg0,p0,c) /\ ENCrypted(i,d,rg1,p1,c)) => p0 = p1
-*)

 private val decrypt': i:id -> k:(;i) decryptor -> ad:(;i)LHAEPlain.adata ->
   c:cipher{SafeId(i) => ENCrypted(i,ad,c)} -> res:
@@ -98,16 +89,6 @@
     rg:range *
     p:(;i,ad,rg) LHAEPlain.plain) {rg = CipherRangeClass(i,Length(c))} ) Result

-(* TODO MK seems outdated: partial functional correctness when decrypting what we encrypted
-  {
-   !pl,p,tag,rg.
-       (    Length(c) = EncryptedLength(i,rg)
-         /\ MACed(e,ad,pl,tag)
-     /\ Encoded(e,ad,pl,tag,p)
-     /\ ENCrypted(e,Length(c),StateID(e,Encryptor(k)),c,p)
-   => ?k',r'. res = Correct((k',r',pl)) }
-*)
-
 val decrypt: i:id -> (;i) decryptor -> ad:(;i)LHAEPlain.adata ->
   c:cipher -> res:
   ( ((;i) decryptor *  rg:range * (;i,ad,rg) LHAEPlain.plain)
@@ -120,130 +101,3 @@
                ))}
 // The last two lines are equivalent to (but easier to verify than)
 // !p. ENC.ENCrypted(i,ad,c,p) <=> (?k,r. res = Correct((k,r,p)))
-
-
-
-
-(* CF 13-01-07 verification notes
-
-We need a full independent spec of StrongAEId & StrongAuthId
-something like the functions below and the corresponding logical specs.
-
-let strongAEId pv cs = match cs with
-  | NullCipherSuite | SCSV of _ | OnlyMACCipherSuite(_,_) -> false
-  | CipherSuite(_,ea) ->
-      match ea with
-           | MtE(eAlg, hAlg) -> int_cma pv hAlg &&
-                                    ind_cpa pv eAlg &&
-                                                        int_ctxt pv hAlg eAlg
-               | AEAD (_,_)      -> false // until we handle GCM
-
-let strongAuthId pv cs = match cs with
-  | NullCipherSuite | SCSV of _ -> false
-  | OnlyMACCipherSuite(_,hAlg)  -> int_cma hAlg
-  | CipherSuite(_,ea) ->
-      match ea with
-           | MtE(eAlg, hAlg) -> int_cma pv hAlg
-               | AEAD (_,_)      -> false // until we handle GCM
-
-and the corresponding logical specs such that, e.g.,
-
-ask !i. StrongAEId(i) => StrongAuthId(i)
-ask INT_CTXT(pv,h,e) =>
-     pv = TLS_1p2
-  \/ ?kex,hAlg. e = CipherSuite(kex,MtE(_,hAlg) && ...
-
-(Note that we actually don't need full CMA when we have INT-CTXT, but this is practically irrelevant.)
-
-There are several ideal properties of AEAD:
-
-1. (When SafeId:) filter out any cipher that is not an honest encryption---a.k.a "INT-CTXT"
-                implemented by #ideal_F in AEAD.fs
-
-2. (When SafeId:) additionally decrypt by table lookup---so that we can get plain secrecy by typing
-                implemented by #ideal in AEAD.fs
-
-3. (When Auth:) filter out any (i,plain,AD) forgery---aka "INT-PTXT" or "CMA"
-                implemented by #ideal in MAC.fs
-
-For F7 clarity, we distinguish several verification steps (using flags/Makefile):
-
-1. (When SafeId, decryption correctness:) decryptions of honest ciphers always succeed, returning the plaintext
-   Together with INT-CTXT & our "at most one encryption per AD" assumption, this justifies moving from 1 to 2.
-   We might also explain it with a "Decryption error oracle".
-
-2. If we decrypt by table lookup, then, we implement parametric AEAD (to complete the SafeId proof)
-   this essentially relies on CPA of the underlying encryption.
-
-3. (When AuthId, irrespective of SafeId & INT-CTXT:) AEAD is PTXT wrt to some user-defined Msg property.
-
-We agreed that #if ideal refers to typechecking 2.
-
-The postcondition of decryption thus consists of
-
-// proved in step 3, sufficient to retrieve Msg(i,ad,p) as a predicate attached to the INT-CTXT log
-(AuthId(i) => ((!p. (?r. res = Correct(i,r,p))
-               <=> ( ?c. INT-CTXT(i,ad,p,c))))
-/\
-// a stronger "SafeId" authentication property, which also yields Msg(i,ad,p)
-(SafeId(i) => ((!p. ( ?r. res = Correct(i,r,p))
-                      <=> ( INT-CTXT(i,ad,p,c)))
-/\
-// a functional property
-(SafeId(i) => ?p. res = Correct((i,Range(i,c),p))) \/ res = Error(AD_bad_record_mac,"")
-
---- The sequence of games is
-
-* indistinguishability of filtering out bad ciphers at safe indexes (by INT-CTXT assumption)
-  The joint INT-CTXT assumption still has to be proved "by hand" for now,
-  although the functional property above helps.
-
-* indistinguishability of decryption by lookup at safe indexes
-  (by typechecking a full spec for the two variants when the lookup succeeds)
-
-* secrecy by typing (CPA), relying on nested plains.
-  for that step, we need to encapsulate Encode & Mac encryption processing into DataStream;
-
-  the current, specific approach is to idealize repr as max-sized-zero at safe indexes
-  within encode (by ENC-CPA parametricity) then typecheck parametricy over delta.
-
-  a generic pattern would be (up to indexing)
-
-  abstract_repr: delta -> high_bytes (within a range)
-  abstract_map: (bytes -> bytes) -> high_bytes -> high_bytes (within computed range)
-
-
-(independently:)
-
-* CMA for Auth but not SafeId.
-
-*)
-
-(* CF 12-04-09 discussion points:
-//
-// plaintext integrity follows from abstraction:
-// - a precondition for coercing to  (;i,rg,ad) plain is that i is un-AuthId
-// - a precondition for leaking from (;i,rg,ad) plain is that i is un-SafeId
-//
-// additionally, the decryption refinement guarantees
-// functional correctness & ciphertext integrity
-//
-// INT-CTXT(i,ad,p,c) is a runtime event recorded by encrypt, stating
-// "c is a correct encryption for i, ad, some rg, and p
-//
-// the range for encryption is not recorded in INT-CTXT,
-// (as indeed only the secret length is authenticated, not the range).
-//
-// our interface is compatible with state for the underlying encryption
-// (but does not rely on it); this is convenient for RC4, for IVs in old TLS
-//
-// how do we deal with corrupted peers?
-// why do we have two cases? I propose instead:
-//
-// AuthId(i) =>
-// ( !p. res = Correct(CipherRange(i,c),p) <=> INT-CTXT(i,ad,p,c) )
-//
-// We are still in-between encryptor/decryptor and keys, why?
-// Are TLS 1.0 IVs now part of the mutable key?
-// Note that CipherRange depends on the TLS version too.
-*)
diff -Ewbur /opt/mitls/lib/LHAEPlain.fs7 /opt/miTLS-0.8.1/lib/LHAEPlain.fs7
--- /opt/mitls/lib/LHAEPlain.fs7        2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/LHAEPlain.fs7  2014-12-04 17:11:27.000000000 +0100
@@ -56,7 +56,6 @@
 val makeExtPad:  id:id -> ad:(;id)adata -> r:range -> p:(;id,ad,r)plain -> p':(;id,ad,r)plain{p=p'}
 val parseExtPad: id:id -> ad:(;id)adata -> r:range -> p:(;id,ad,r)plain -> res:((p':(;id,ad,r)plain{p=p'}) Result){?p. res = Correct(p)}

-
 (* These coercions are used only in StatefulLHAE.fs;
    they are not part of the "plain" interface to LHAE. *)

@@ -76,18 +75,3 @@
   r:range ->
   p:(;i,ad',r)plain ->
   f:(;i,ad,h,r)StatefulPlain.plain{p = StAEToLHAE(f)}
-
-
-
-
-
-(* CF cut?
-private ask !i,r,f,lad. (AuthId(i) /\ (?had,sn,ph. MakeAD(i,(sn,ph),had) = lad /\ StatefulPlain.Sent(i,had,(sn,ph),r,f.contents)) ) =>
-                        (!had', sn', ph'. MakeAD(i,(sn',ph'),had') = lad /\ StatefulPlain.StAEHistory(i,ph') /\ StatefulPlain.HLength(i,ph') = sn' => StatefulPlain.Sent(i,had',(sn',ph'),r,f.contents))
-
-ask !i,ad,sn,ph,ad',r,x. (ad = MakeAD(i,(sn,ph),ad') /\ StatefulPlain.Sent(i,ad',(sn,ph),r,x.contents)) => LHAESent(i,ad,r,x)
-
-ask !i,ad,h,h',ad',ad''. ad = MakeAD(i,h,ad') /\ ad = MakeAD(i,h',ad'') =>
-    (StatefulPlain.SeqN(i,h) = StatefulPlain.SeqN(i,h') /\ ad' = ad'')
-*)
-//CF ask !i,ad,ad',ad'',sn,h,h',r,f. AuthId(i) /\ StatefulPlain.Sent(i,ad',(sn,h),r,f) /\ StatefulPlain.StAEHistory(i,h') /\  HLength(i,h') = sn => h = h'
diff -Ewbur /opt/mitls/lib/MAC.fs7 /opt/miTLS-0.8.1/lib/MAC.fs7
--- /opt/mitls/lib/MAC.fs7      2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/MAC.fs7        2014-12-04 17:11:27.000000000 +0100
@@ -79,7 +79,6 @@

 ask !i,alg. (AuthId(i) /\ alg = MacAlg(i)) => (alg = MAC_SHA256.a \/ alg = MAC_SHA1.a)

-
 type text = bytes
 predicate val Msg: id * text -> bool

@@ -105,7 +104,6 @@
 val Mac:    i:id -> k:(;i) key -> t:text{Msg(i,t)} -> m:(;i) tag
 val Verify: i:id -> k:(;i) key -> t:text -> m:(;i) tag -> b:bool{ (b=true /\ AuthId(i)) => Msg(i,t) }

-
 (*
 // typing the log for an ideal functionality that
 // directly specifies the security of MAC (not used anymore)
diff -Ewbur /opt/mitls/lib/MAC_SHA1.fs7 /opt/miTLS-0.8.1/lib/MAC_SHA1.fs7
--- /opt/mitls/lib/MAC_SHA1.fs7 2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/MAC_SHA1.fs7   2014-12-04 17:11:27.000000000 +0100
@@ -27,7 +27,6 @@
   ki:id -> (;ki) key -> t:text ->
   tag -> b:bool { b=true => Msg(ki,t) }

-
 (* typing the log for the ideal functionality *)

 type entry = (ki:id * t:text * tag){Msg(ki,t)}
Only in /opt/mitls/lib: Makefile
diff -Ewbur /opt/mitls/lib/Nonce.fs /opt/miTLS-0.8.1/lib/Nonce.fs
--- /opt/mitls/lib/Nonce.fs     2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/Nonce.fs       2014-12-04 17:11:27.000000000 +0100
@@ -13,7 +13,6 @@
   if l = n then r
   else unexpected "CoreRandom.random returned incorrect number of bytes"

-
 let noCsr = random 64 // a constant value, with negligible probability of being sampled, excluded by idealization

 #if ideal
diff -Ewbur /opt/mitls/lib/Nonce.fs7 /opt/miTLS-0.8.1/lib/Nonce.fs7
--- /opt/mitls/lib/Nonce.fs7    2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/Nonce.fs7      2014-12-04 17:11:27.000000000 +0100
@@ -10,9 +10,6 @@
 // the idealized code returns globally pairwise-distinct values
 // this is securely implemented by returning values that have a negligible probability of collision

-// TODO do we need more than that, e.g. no clash with prior adv nonces?
-// MK I don't think so, where would this appear in the proof?
-
 val noCsr: (;64) lbytes
 // null value for indexing the initial epoch

diff -Ewbur /opt/mitls/lib/PMS.fs /opt/miTLS-0.8.1/lib/PMS.fs
--- /opt/mitls/lib/PMS.fs       2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/PMS.fs 2014-12-04 17:11:27.000000000 +0100
@@ -41,12 +41,10 @@
 let leakRSA (pk:RSAKey.pk) (cv:ProtocolVersion) pms =
   match pms with
   #if ideal
-  | IdealRSAPMS(_) -> Error.unexpected "pms is dishonest" //MK changed to unexpected from unreachable
+  | IdealRSAPMS(_) -> Error.unexpected "pms is dishonest"
   #endif
   | ConcreteRSAPMS(b) -> b

-
-
 // The trusted setup for Diffie-Hellman computations
 open DHGroup
 open CoreKeys
diff -Ewbur /opt/mitls/lib/PMS.fs7 /opt/miTLS-0.8.1/lib/PMS.fs7
--- /opt/mitls/lib/PMS.fs7      2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/PMS.fs7        2014-12-04 17:11:27.000000000 +0100
@@ -6,20 +6,17 @@
 open Bytes
 open TLSConstants

-
 (** RSA ciphersuites **)

 // ``These parameters can encrypt HonestRSAPMSs.''
-//CF unclear why we need this intermediate predicate
+
 predicate SafeRSA of RSAKey.pk * ProtocolVersion
 definition !pk,cv. SafeRSA(pk,cv) <=> RSAKey.Honest(pk) /\ RSAKey.Strong(cv)

-
 // In this file RSA refers to any crypto materials used for the RSA KEX.

 // representation of PMS as RSA plaintexts.
 type rsarepr = (;48)lbytes
-//CF we considered indexing it by cv & refining with ?b. it = VersionBytes(cv) @| b

 //#begin-abstractionRSA
 (* private , only shared with KEF *)
@@ -45,8 +42,6 @@
 val honestRSAPMS: pk:RSAKey.pk -> cv:ProtocolVersion -> pms: (;pk,cv) rsapms ->
   b:bool { b=true <=> HonestRSAPMS(pk,cv,pms) }

-//CF see SafeRSA in TLSInfo
-//CF we get it as a runtime invariant, from the refinement of IdealRSAPMS
 private ask !pk,cv,pms.
   HonestRSAPMS(pk,cv,pms) => SafeRSA(pk,cv)

@@ -62,12 +57,9 @@
 // used for concrete RSA encryption
 //#end-abstractionRSA

-
-
 open DHGroup
 open CoreKeys

-//MK SafeDH is much more specific involving the contributions to the pms. This is probably by necessity.
 // The DH parameters, generator, and gx and gy values yield a good dhpms
 predicate SafeDH of p:bytes * g:bytes * (;p,g)DHGroup.elt * (;p,g)DHGroup.elt
 //#begin-abstractionDH
@@ -94,7 +86,6 @@
 val coerceDH: dhp:dhparams -> gx:(;dhp.dhp,dhp.dhg)elt -> gy:(;dhp.dhp,dhp.dhg)elt {not SafeDH(dhp.dhp,dhp.dhg,gx,gy)}-> (;dhp.dhp,dhp.dhg)elt -> (;dhp.dhp,dhp.dhg,gx,gy) dhpms
 //#end-abstractionDH

-
 // multiplexing the PMS representations
 type pms =
   | RSAPMS of pk:RSAKey.pk * cv:ProtocolVersion * (;pk,cv)rsapms
diff -Ewbur /opt/mitls/lib/PMS.fsi /opt/miTLS-0.8.1/lib/PMS.fsi
--- /opt/mitls/lib/PMS.fsi      2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/PMS.fsi        2014-12-04 17:11:27.000000000 +0100
@@ -9,8 +9,6 @@
 open DHGroup
 open CoreKeys

-//CF some of those types are private to PMS & KEF
-
 type rsarepr = bytes
 type rsaseed = {seed: rsarepr}
 type rsapms =
@@ -45,15 +43,10 @@

 val coerceDH: dhparams -> DHGroup.elt -> DHGroup.elt -> DHGroup.elt -> dhpms

-
 (* Used when generating key material from the MS.
    The result must still be split into the various keys.
    Of course this method can do the splitting internally and return a record/pair *)

-
-
-//TODO SSL 3 specific encoding function for certificate verify
-
 type pms =
   | RSAPMS of RSAKey.pk * ProtocolVersion * rsapms
   | DHPMS of bytes * bytes * elt * elt * dhpms
diff -Ewbur /opt/mitls/lib/PRF.fs /opt/miTLS-0.8.1/lib/PRF.fs
--- /opt/mitls/lib/PRF.fs       2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/PRF.fs 2014-12-04 17:11:27.000000000 +0100
@@ -95,7 +95,6 @@
             (ck,sk)
 #endif

-
 type derived = StatefulLHAE.reader * StatefulLHAE.writer

 type state =
@@ -105,8 +104,6 @@
 //  | Done
 //  | Wasted

-
-
 #if ideal

 type event = Mismatch of id
@@ -126,14 +123,9 @@
   | (csr', s')::entries when csr = csr' -> (csr,s)   :: entries
   | (csr', s')::entries                 -> (csr', s'):: update csr s entries

-//CF to circumvent an F7 limitation?
 let commit csr pv a ext = Committed(pv,a,ext)
 #endif

-//CF We could statically enforce the state machine.
-
-
-
 let keyCommit (csr:csrands) (pv:ProtocolVersion) (a:aeAlg) (ext:negotiatedExtensions) : unit =
   #if ideal
   match read csr !kdlog with
@@ -162,8 +154,6 @@
             (StatefulLHAE.COERCE rdId Reader ck)
             (StatefulLHAE.COERCE wrId Writer sk)

-
-//CF We could merge the two keyGen.
 let keyGenClient (rdId:id) (wrId:id) ms =
     #if ideal
     let pv = pv_of_id rdId in
@@ -204,15 +194,13 @@
     | Committed(pv',aeAlg',ext') ->
         // when SafeKDF, the client keyGens only on fresh Ids,
         // hence we will never have AuthId(rdId) for this csr.
-        //CF tricky case; revisit at some point.
+
         (Pi.assume(Mismatch(rdId));
         deriveKeys rdId wrId ms Server)
     | Derived(wrId',rdId',derived) when safeKDF(rdId)  ->
         // by typing the commitment, we know that rdId has matching csr pv aeAlg
         if rdId = wrId'
-        //CF was, to be discussed:
-        //CF if rdId.msId   = wrId'.msId &&  rdId.kdfAlg = wrId'.kdfAlg
-        //MK this looks so simple it may be just right! Maybe too good to be true?
+
         then
             derived // we benefit from the client's idealization
         else
@@ -227,7 +215,6 @@
     deriveKeys rdId wrId ms Server
     #endif

-
 (** VerifyData **)

 type text = bytes
@@ -259,7 +246,7 @@
 let makeVerifyData si (ms:masterSecret) role data =
   let tag = verifyData si ms role data in
   #if ideal
-  //MK rename predicate and function
+
   //if safeVD si then
   let i = msi si in
   let msdataoption = assoc role tag !log in
@@ -279,11 +266,10 @@
   #if ideal
   // we return "false" when concrete verification
   // succeeds but shouldn't according to the log
-  && ( safeVD si  = false || mem (msi si) role data !log ) //MK: rename predicate and function
+  && ( safeVD si  = false || mem (msi si) role data !log )
   //#end-ideal2
   #endif

-
 (** ad hoc SSL3-only **)

 let ssl_certificate_verify (si:SessionInfo) ms (algs:sigAlg) log =
@@ -292,4 +278,3 @@
   | SA_RSA -> TLSPRF.ssl_verifyCertificate MD5 s log @| TLSPRF.ssl_verifyCertificate SHA s log
   | SA_DSA -> TLSPRF.ssl_verifyCertificate SHA s log
   | _      -> Error.unexpected "[ssl_certificate_verify] invoked on a wrong signature algorithm"
-
diff -Ewbur /opt/mitls/lib/PRF.fs7 /opt/miTLS-0.8.1/lib/PRF.fs7
--- /opt/mitls/lib/PRF.fs7      2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/PRF.fs7        2014-12-04 17:11:27.000000000 +0100
@@ -39,7 +39,6 @@
 // - all authentic Finished messages so far, to filter out forgeries in their "MAC verify".
 // - all safe connection keys generated so far, to share them with the second, matching ideal key derivation.

-
 (** Master secrets are either ideally sampled or concretely derived & coerced **)

 val sample: i:msId -> (;i)ms
@@ -55,7 +54,6 @@
 //#end-coerce
 val leak: i:msId {not HonestMS(i)} -> (;i)ms -> repr

-
 (** Key derivation **)

 //This is just twice LHAE.KeySize but simplified to exclude AEAD.
@@ -98,7 +96,6 @@
        not SafeKDF(wrId) (* needed to coerce to StatefulLHAE *) } ->
   (;rdId.msId)ms -> Role -> (;rdId,wrId) derived

-
 // USAGE RESTRICTION:
 // For each CSR,
 // - the server linearly calls "keyCommit csr a" then "keyGenServer csr a" ...
@@ -119,7 +116,6 @@
 // definition SafeKDF(id) <=> HonestMS(id.msId) /\ StrongKDF(id.kdfAlg) /\
 //                            KeyCommit(id.csrConn,id.pv,id.aeAlg,id.ext) /\ KeyGenClient(id.csrConn,id.pv,id.aeAlg,id.ext)

-
 // See comments in the code as we assume Mismatch to reflect freshness assumptions.
 // we may also rely more finely on the log, to define Match
 // more precisely as " KeyCommit ; KeyGenClient " with no KeyGenServer in-between.
@@ -138,7 +134,6 @@
   // We could define final states Done and Wasted for
   // csr for which a server has already generated, or will never generate keys.

-
 type kdentry = csr:csrands * (;csr) state
 val kdlog : kdentry list ref
 val read: csr:csrands -> kdentry list -> (;csr) state
@@ -165,7 +160,6 @@
 private val wrap2:
   rdId: id{Match(rdId)} -> wrId: id -> (;rdId,wrId) derived -> csr:csrands -> (;csr) state

-
 val keyGenClient:
   rdId: id -> wrId: id { wrId = Swap(rdId) } ->
   (;rdId.msId)ms -> (;rdId,wrId) derived  { KeyGenClient(rdId.csrConn,rdId.pv,rdId.aeAlg,rdId.ext) }
@@ -174,7 +168,6 @@
   rdId: id -> wrId: id { wrId = Swap(rdId) } ->
   (;rdId.msId)ms -> (;rdId,wrId) derived

-
 (** VerifyData authenticator in Finished messages **)

 // Master secrets are also used to generate and check verifyData tags,
@@ -182,7 +175,6 @@

 // We specify it as we do for MACs,
 // whereas we have a stronger PRF assumption.
-// TODO reduction from joint MAC & KDF to PRF.

 // Some verbatim handshake message log as text...
 // MACed into tags (with a fixed, irrelevant length)
@@ -201,7 +193,7 @@
 private val log: entry list ref
 private val mem: i:msId -> r:Role -> t:text -> entry list -> b:bool{ b=true => VerifyData(i,r,t) }
 private val assoc: r:Role -> vd:tag -> entry list -> (i:msId * t:text{VerifyData(i,r,t) /\ MakeVerifyData(i,r,t,vd)}) option
-//MK: old assoc 31/07/2014: private val assoc: i:msId -> r:Role -> t:text -> entry list -> vdo:tag option{!vd. vdo=Some(vd) => VerifyData(i,r,t) /\ MakeVerifyData(i,r,t,vd) }
+
 //private val cons: si:SessionInfo -> tag -> r:Role -> t:text {VerifyData(si,r,t)} -> entry list -> entry list

 private val verifyData: si:SessionInfo -> (;MsI(si)) ms -> r:Role -> t:text -> tag
@@ -222,7 +214,6 @@
   r:Role -> t:text -> tag:tag (* the expected value *) ->
   b:bool{(b = true /\ SafeVD(si)) => VerifyData(MsI(si),r,t)}

-
 (** ad hoc SSL3-only function; untrusted. **)

 assume !si. si.protocol_version = SSL_3p0 => not StrongVD(VdAlg(si))
diff -Ewbur /opt/mitls/lib/PRF.fsi /opt/miTLS-0.8.1/lib/PRF.fsi
--- /opt/mitls/lib/PRF.fsi      2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/PRF.fsi        2014-12-04 17:11:27.000000000 +0100
@@ -29,4 +29,3 @@
 val checkVerifyData: SessionInfo -> ms -> Role -> bytes -> bytes -> bool

 val ssl_certificate_verify: SessionInfo -> ms -> TLSConstants.sigAlg -> bytes -> bytes
-
Only in /opt/mitls/lib: PwDataStream.fs
Only in /opt/mitls/lib: PwDataStream.fs7
Only in /opt/mitls/lib: PwDataStream.fsi
Only in /opt/mitls/lib: README.metrics
Only in /opt/mitls/lib: README.txt
Only in /opt/mitls/lib: REPORT_2013_12_19.xlsx
Only in /opt/mitls/lib: RPCPlain.fs7
diff -Ewbur /opt/mitls/lib/RSA.fs /opt/miTLS-0.8.1/lib/RSA.fs
--- /opt/mitls/lib/RSA.fs       2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/RSA.fs 2014-12-04 17:11:27.000000000 +0100
@@ -136,4 +136,3 @@
         #endif
             PMS.coerceRSA pk cv pmsb
         //#end-ideal2
-
diff -Ewbur /opt/mitls/lib/RSA.fs7 /opt/miTLS-0.8.1/lib/RSA.fs7
--- /opt/mitls/lib/RSA.fs7      2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/RSA.fs7        2014-12-04 17:11:27.000000000 +0100
@@ -18,7 +18,7 @@

 val encrypt:
   pk:pk -> cv:ProtocolVersion -> pms:(;pk,cv) PMS.rsapms ->
-  b:bytes //TODO delete {PMS.EncryptedRSAPMS(pk,cv,pms,b)}
+  b:bytes

 // This is not just plain RSA_PKCS1 decryption.
 // We put in place protocol regression, Bleichenbacher and related timing attack countermeasures.
@@ -35,13 +35,8 @@
         where the countermeasures are applied at the ms-KEM level
    *)

-
 // The rest of the interface is internal to RSA.fs

-// TODO where do we require/use that cv_check be used everywhere with Honest keys?
-// MK we require it for compatibity with the Easycrypt proof
-// TODO explain that letting the adversary choose further strengthen our RSA assumption.
-
 // Ideally, we add an indirection from a fresh dummy pms to the ideal pms (before encryption)
 // and we maintain a table to undo it (after concrete decryption)

diff -Ewbur /opt/mitls/lib/RSAKey.fs /opt/miTLS-0.8.1/lib/RSAKey.fs
--- /opt/mitls/lib/RSAKey.fs    2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/RSAKey.fs      2014-12-04 17:11:27.000000000 +0100
@@ -1,9 +1,7 @@
 #light "off"

-
 module RSAKey

-
 open Bytes

 type pk = { pk : CoreACiphers.pk }
@@ -11,9 +9,8 @@

 type pred = SK_PK of sk * pk

-
 #if ideal
-// TODO just a placeholder for now.
+
 let honest_log = ref[]
 let honest (pk:pk): bool = failwith "only used in ideal implementation, unverified"
 let strong (pv:TLSConstants.ProtocolVersion): bool = failwith "only used in ideal implementation, unverified"
Only in /opt/mitls/lib: RSAPMS.fs
diff -Ewbur /opt/mitls/lib/Range.fs /opt/miTLS-0.8.1/lib/Range.fs
--- /opt/mitls/lib/Range.fs     2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/Range.fs       2014-12-04 17:11:27.000000000 +0100
@@ -39,7 +39,6 @@
             | Stream_RC4_128 -> 0
             | CBC_Stale(_) | CBC_Fresh(_) -> 1

-
 let maxPadSize id =
 #if TLSExt_extendedPadding
     if TLSExtensions.hasExtendedPadding id then
@@ -135,7 +134,6 @@
         else
             res

-
 let minMaxPad (i:id) =
     let maxPad = maxPadSize i in
     let fp = fixedPadSize i in
diff -Ewbur /opt/mitls/lib/Range.fs7 /opt/miTLS-0.8.1/lib/Range.fs7
--- /opt/mitls/lib/Range.fs7    2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/Range.fs7      2014-12-04 17:11:27.000000000 +0100
@@ -21,7 +21,6 @@
 predicate SubRange of range * range
 definition !l0,l1,h0,h1. SubRange((l0,h0),(l1,h1)) <=> l1 <= l0 && h0 <= h1

-
 (* lengths of IVs and padding for AE(id) *)

 function val IVSize: id -> nat
@@ -33,32 +32,23 @@
        (!i,aealg,macalg. i.aeAlg = AEAD(aealg,macalg) => IVSize(i) = 0)
 val ivSize: e:id -> l:nat{l=IVSize(e)}

-// CF 14-07-15 usage?
 ask !i. (?mac. i.aeAlg = MACOnly(mac) \/ i.aeAlg = MtE(Stream_RC4_128,mac)) => IVSize(i) = 0

-// CF 14-07-15 what does it mean? Why the unit? Pls document new ones...
 function val FixedPadSize: id * unit -> nat
 definition
-       (* AP: for LH
-       (HasExtendedPadding(i) => FixedPadSize(i,())=2) /\
-    (not HasExtendedPadding(i) =>
-       *)
+
                ( (!i,mac.       i.aeAlg = MACOnly(mac)            => FixedPadSize(i,())=0 ) /\
                  (!i,aeAlg,mac. i.aeAlg = AEAD(aeAlg,mac)         => FixedPadSize(i,())=0 ) /\
                  (!i,mac.       i.aeAlg = MtE(Stream_RC4_128,mac) => FixedPadSize(i,())=0 ) /\
                  (!i,alg,mac.   i.aeAlg = MtE(CBC_Stale(alg),mac) => FixedPadSize(i,())=1 ) /\
                  (!i,alg,mac.   i.aeAlg = MtE(CBC_Fresh(alg),mac) => FixedPadSize(i,())=1 )
                )
-       (* AP: for LH
-       )
-       *)
+
 val fixedPadSize: id:id -> l:nat{l=FixedPadSize(id,())}

-function val MaxPadSize: i:id * unit -> nat //TODO MK fix spec
+function val MaxPadSize: i:id * unit -> nat
 definition
-       (* AP: for LH
-    (  not HasExtendedPadding(i) =>
-       *)
+
                (
                (!i,mac. i.aeAlg = MACOnly(mac)                 => MaxPadSize(i,()) = 0)  /\
                (!i,aeAlg,mac. i.aeAlg = AEAD(aeAlg,mac)        => MaxPadSize(i,()) = 0)  /\
@@ -74,12 +64,7 @@
                (!i,alg,mac. i.aeAlg = MtE(CBC_Stale(alg),mac) /\ PvOfId(i) = SSL_3p0
                                                                                        => MaxPadSize(i,()) = BlockSize(alg))
                )
-       (* AP: for LH
-       ) /\
-       (       HasExtendedPadding(i) =>
-               MaxPadSize(i,()) = fragmentLength
-       )
-       *)
+
 val maxPadSize: i:id -> l:nat{l = MaxPadSize(i,())}

 (* the range that can be conveyed in one fragment *)
@@ -87,8 +72,6 @@
 predicate RangeFragment of id * range
 definition !i,l,h. RangeFragment(i,(l,h)) <=>
        h <= fragmentLength
-//AP /\ h - l <= MaxPadSize(i,())
-

 (* minimal padding length for a given plaintext length (in bytes) *)

@@ -107,7 +90,6 @@

 private val minimalPadding: e:id -> l:nat -> l':nat{l' = MinimalPadding(e,l)}

-
 (* TargetLength: ciphertext length for AE, including IV *)

 function val TargetLength: id * range -> nat
@@ -147,7 +129,6 @@
        (h >= 0 /\ e.aeAlg = MtE(CBC_Stale(alg),mac)) =>
        TargetLength(e,(l,h)) >= BlockSize(alg)

-
 (* CipherRangeClass: given a cipher length, what's the range of plaintexts? *)

 function val CipherRangeClass: id * nat -> range
@@ -219,8 +200,6 @@
   r:range {r = CipherRangeClass(e,tlen)}

 theorem !e,t,rg.  rg = CipherRangeClass(e,t) => t = TargetLength(e,rg)
-// CF 14-07-15 usage? proof?
-

 function val RangeClass: id * range -> range
 definition !e,r. RangeClass(e,r) = CipherRangeClass(e,TargetLength(e,r))
@@ -228,10 +207,5 @@
 val rangeClass: e:id -> r0:range -> r1:range{r1 = RangeClass(e,r0)}

 theorem !e,r. SubRange(r,RangeClass(e,r))
-// CF 14-07-15 usage? proof?
-

 val minMaxPad: i:id -> l:nat * h:nat{ l = FixedPadSize(i,()) /\ h = MaxPadSize(i,())}
-
-//AP type (;e:id)frange = l:nat * h:nat{l<=h /\ TargetLength(e,rg) <= max_TLSCipher_fragment_length
-//AP                                                                   /\ h-l <= MaxPad(e)}
diff -Ewbur /opt/mitls/lib/Record.fs /opt/miTLS-0.8.1/lib/Record.fs
--- /opt/mitls/lib/Record.fs    2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/Record.fs      2014-12-04 17:11:27.000000000 +0100
@@ -53,11 +53,7 @@
 let recordPacketOut e conn pv rg ct fragment =
     (* No need to deal with compression. It is handled internally by TLSPlain,
        when returning us the next (already compressed!) fragment *)
-    (*TODO
-    match make_compression conn.rec_ki.sinfo fragment with
-    | Error (x,y) -> Error (x,y)
-    | Correct compressed ->
-    *)
+
     let initEpoch = isInitEpoch e in
     match conn with
     | NullState when initEpoch = true ->
@@ -77,31 +73,6 @@
          packet)
     | _ -> unexpected "[recordPacketOut] Incompatible ciphersuite and key type"

-
-(* CF: an attempt to simplify for typechecking
-let recordPacketOut2 conn clen ct fragment =
-    let suite = conn.rec_ki.sinfo.cipher_suite
-    let conn, payload =
-        if isNullCipherSuite suite then
-            conn,
-            fragment_to_cipher conn.rec_ki clen fragment
-        else
-            let ad = makeAD conn ct in
-            if isOnlyMACCipherSuite suite then
-                let key = getMACKey conn.key in
-                let text = mac_plain_to_bytes (ad_fragment conn.rec_ki ad fragment)
-                let mac = Mac.MAC conn.rec_ki key text
-                conn,
-                fragment_mac_to_cipher conn.rec_ki clen fragment (bytes_to_mac mac)
-            else
-                let key = getLHAEKey conn.key in
-                let newIV, payload = LHAE.encrypt conn.rec_ki key conn.iv3 clen ad fragment
-                {conn with iv3 = newIV},
-                payload
-    incN conn,
-    makePacket ct conn.local_pv payload
-*)
-
 let recordPacketIn e conn ct payload =
     let initEpoch = isInitEpoch e in
     match conn with
@@ -132,4 +103,3 @@
         let i = id e in
         TLSFragment.emptyHistory e
     | SomeState(h,_) -> h
-
diff -Ewbur /opt/mitls/lib/Record.fs7 /opt/miTLS-0.8.1/lib/Record.fs7
--- /opt/mitls/lib/Record.fs7   2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/Record.fs7     2014-12-04 17:11:27.000000000 +0100
@@ -16,12 +16,10 @@
 val parseHeader: b:(;5)lbytes ->
        ((ContentType * ProtocolVersion * n:nat){n>0 /\ n <= max_TLSCipher_fragment_length}) Result

-
 (** Connections (multiplexing 4 TLS protocols) *)

 (* Record states are history-dependent StAE states *)

-// CF why do we need a NullState?
 private type (;e:epoch,rw:rw) ConnectionState =
        | NullState
        | SomeState of h :(;e)TLSFragment.history * st:(;Id(e),rw)StatefulLHAE.state
@@ -50,7 +48,7 @@
 val recordPacketOut:
   e:epoch -> s:(;e) sendState -> pv:ProtocolVersion ->
   rg:range ->
-  ct:ContentType{ct=Application_data => OpenState(e)} -> //MK required by TLSFragment.extendHistory
+  ct:ContentType{ct=Application_data => OpenState(e)} ->
   f:(;e,ct,History(e,Writer,s),rg) TLSFragment.plain ->
   (s':(;e) sendState * wire:bytes)
   { Auth(e) => (History(e,Writer,s') = TLSFragment.ExtendHistory(e,ct,History(e,Writer,s),rg,f))}
@@ -61,7 +59,3 @@
   wire:bytes{Length(wire) <= max_TLSCipher_fragment_length} ->
   ( (s':(;e)recvState * rg:range * f:(;e,ct,History(e,Reader,s),rg) TLSFragment.plain)
     { Auth(e) => History(e,Reader,s') = TLSFragment.ExtendHistory(e,ct,History(e,Reader,s),rg,f) }                       ) Result
-
-//TODO val historyStream: e:epoch -> st:(;e) ConnectionState ->
-//TODO  ct:TLSConstants.ContentType -> s:(;e)stream{s=HistoryStream(e,ct,History(e,st))}
-
diff -Ewbur /opt/mitls/lib/Record.fsi /opt/miTLS-0.8.1/lib/Record.fsi
--- /opt/mitls/lib/Record.fsi   2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/Record.fsi     2014-12-04 17:11:27.000000000 +0100
@@ -23,24 +23,7 @@
 val parseHeader: bytes -> Result<(ContentType * ProtocolVersion * nat)>
 val makePacket: ContentType -> ProtocolVersion -> bytes -> bytes

-//CF postV1, do some uniform renaming, e.g. s/Out/Send/
 val recordPacketOut: epoch -> sendState -> ProtocolVersion -> range -> ContentType -> TLSFragment.fragment -> (sendState * bytes)
 val recordPacketIn : epoch -> recvState -> ContentType -> bytes -> Result<(recvState * range * TLSFragment.fragment)>

 val history: epoch -> rw -> ConnectionState -> TLSFragment.history
-
-//CF val historyStream: epoch -> ConnectionState -> ContentType -> DataStream.stream
-
-(*TODO val dataAvailable: recvState -> Result<bool> *)
-(*TODO val coherentrw: SessionInfo -> recvState -> sendState -> bool *)
-
-(*TODO ProtocolVersion:
-  - the interface can be used only for setting and checking them (they are never passed up)
-  - initially, sendState is the minimal and recvState is Unknown.
-  - for receiving only, the "Unknown" ProtocolVersion means that we do not know yet,
-    so we are accepting any reasonable one in each record.
-    Conservatively, we change from Unknown to the first received version. *)
-
-(*TODO for now, we do not provide an interface for reporting sequence number overflows *)
-
-
diff -Ewbur /opt/mitls/lib/SessionDB.fs7 /opt/miTLS-0.8.1/lib/SessionDB.fs7
--- /opt/mitls/lib/SessionDB.fs7        2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/SessionDB.fs7  2014-12-04 17:11:27.000000000 +0100
@@ -26,46 +26,3 @@

 // Useful for the user of miTLS
 val getAllStoredIDs: t -> SessionIndex list
-
-(* TODO proposed patch for tickets:
-
-type ticket = bytes // constraints on size?
-
-type (;sid:sessionID, r:Role) StorableSession =
-     si:SessionInfo
-   * (;si) PRF.masterSecret
-   * o:(ticket option) { Authorize(r,si) } /\
-                         (o = None => si.sessionID = sid) /\
-                         (r = Server => o = None) }
-
-// As suggested in RFC 5077, our client generates a random sid when the server provides a ticket,
-// so that the client app can use it to trigger the resumption (ignoring whether ticketed or not)
-
-// The sid is not a unique index so, from the client viewpoint, using an sid does not necessarily
-// guarantee that the resulting epoch has the same parameters as the original session.
-// For instance, the server/adversay may have reused the sid.
-// As usual, the client should check the resulting epoch index.
-
-// MK: why is this called TAKE 2?
-// TAKE 2: we will index our database with client-random | server-random instead of this poor sid.
-// we need not reflect it in the sessionInfo either; we might have a boolean flagging possible resumption.
-
-val noSid
-
-// server-only; in the database, we'll store some keys as well as some sessions.
-
-val newKey: t -> keyName // no need for formal corruption?
-val forget: t -> keyName -> unit
-
-val sessionTicket: keyName -> (;noSid,Server) StorableSession -> ticket
-val ticketSession: ticket -> (keyName * (;noSid,Server) StorableSession) Result
-
-private val keys = AE.key list
-
-// parsed; note that the IV and MAC are integrated into AE ciphers.
-
-private type ticketContents = {
-       keyName : bytes
-       cipher  : bytes }
-
-*)
diff -Ewbur /opt/mitls/lib/SessionDB.fsi /opt/miTLS-0.8.1/lib/SessionDB.fsi
--- /opt/mitls/lib/SessionDB.fsi        2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/SessionDB.fsi  2014-12-04 17:11:27.000000000 +0100
@@ -5,9 +5,6 @@
 open TLSInfo
 open Date

-//CF type SessionIndex = sessionID * Role * Cert.hint
-//CF flattened for simpler refinements
-
 type StorableSession = SessionInfo * PRF.masterSecret * epoch
 type SessionIndex = sessionID * Role * Cert.hint

diff -Ewbur /opt/mitls/lib/Sig.fs /opt/miTLS-0.8.1/lib/Sig.fs
--- /opt/mitls/lib/Sig.fs       2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/Sig.fs 2014-12-04 17:11:27.000000000 +0100
@@ -30,7 +30,6 @@
 // We maintain two logs:
 // - a log of honest public keys (a,pk), not necessarily with strong crypto
 // - a log of (a,pk,t) entries for all honestly signed texts
-// CF We could also implement it on top of ideal non-agile Sigs.

 type entry = alg * pkey * text
 //in F7: type entry = a:alg * pk:(;a) pk * t:text * s:(;a) sigv { Msg(a,pk,t) }
@@ -185,4 +184,3 @@
 let coerce (a:alg)  (p:pkey)  (csk:CoreSig.sigskey) : skey =
     let (_,ahash)=a in
     { skey = (csk, ahash); pub = p}
-
diff -Ewbur /opt/mitls/lib/Sig.fs7 /opt/miTLS-0.8.1/lib/Sig.fs7
--- /opt/mitls/lib/Sig.fs7      2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/Sig.fs7        2014-12-04 17:11:27.000000000 +0100
@@ -91,15 +91,6 @@
 val verify:  a:alg -> pk:(;a) pkey -> t:text -> m:(;a) sigv ->
   b:bool {(b=true /\ Strong(a) /\ Honest(a,pk)) => Msg(a,pk,t)}

-// CF leak & create_pkey are currently useless, would make sense only with a dynamic Honest predicate; cut?
-
-// MK how to extract & check the algs from certs?
-// MK how does the server control the choice of algorithms? For now hardcoded.
-// MK adjust compromise model, connect it to Cert (mostly for the benefit of the adversary)
-// MK our current implementation does not allow access to the gen function.
-// MK consequently all secret keys used in runs of our protocol are thus coerced keys and we thus don't have any safe instances
-// CF these comments concern the (non)-usage of this interface, not the Sig module; relocate?
-
 //-------- the rest is internal to Sig.fs

 type honest_entry = (a:alg * sk:(;a)skey * pk:(;a)pkey{Honest(a,pk) /\ pk = PK(sk)})
@@ -113,5 +104,3 @@
 private val log: entry list ref
 private val consLog: a:alg -> pk:(;a) pkey -> t:text {Msg(a,pk,t)} -> entry list -> entry list
 private val has_mac: a:alg -> pk:(;a) pkey -> t:text -> entry list -> b:bool{b = true => Msg(a,pk,t)}
-
-
diff -Ewbur /opt/mitls/lib/Sig.fsi /opt/miTLS-0.8.1/lib/Sig.fsi
--- /opt/mitls/lib/Sig.fsi      2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/Sig.fsi        2014-12-04 17:11:27.000000000 +0100
@@ -6,7 +6,7 @@
 open TLSConstants

 (* ------------------------------------------------------------------------ *)
-type alg   = sigHashAlg //MK: now defined in TLSConstants.fs7: sigAlg * hashAlg
+type alg   = sigHashAlg

 type text = bytes
 type sigv = bytes
@@ -19,7 +19,6 @@

 val create_pkey: alg -> CoreSig.sigpkey -> pkey

-//MK: why are these functions needed, alg is known from the index?
 val sigalg_of_skeyparams : CoreSig.sigskey -> sigAlg
 val sigalg_of_pkeyparams : CoreSig.sigpkey -> sigAlg

diff -Ewbur /opt/mitls/lib/StatefulLHAE.fs7 /opt/miTLS-0.8.1/lib/StatefulLHAE.fs7
--- /opt/mitls/lib/StatefulLHAE.fs7     2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/StatefulLHAE.fs7       2014-12-04 17:11:27.000000000 +0100
@@ -5,95 +5,13 @@
 open Bytes
 open TLSInfo
 open Range
-open StatefulPlain //CF added for lighter notations
+open StatefulPlain

 (* This module is parameterized by StatefulPlain, providing
    abstract types 'plain' for plaintext and 'history' for sequences of plaintexts

    The functionality is indexed by succEpochs, also treated abstractly. *)

-(* CF
-   (We pass those, rather than tight indexes, because tight indexes are ghost.)
-
-   From each id, we can get:
-   - a (tight, abstract, comparable) instance identifier
-     [consisting of the connection CSR, the Role, plus the MS index, plus the AE algorithm]
-   - the AE algorithm
-   - two idealization predicates Auth & Safe
-
-   From this module's viewpoint, we can (linearly) re-index
-   as long as none of those are affected.
-
-   Usage restrictions:
-   1. aeAlg, Auth & Safe depend only on the tight index.
-   2. Auth must imply StrongAuth(alg), Safe must imply StrongAE(alg)
-   3. The user may call GEN at most once for every tight index.
-   4. The user may encrypt (or decrypt) at most once from every state.
-
-   Notes: - TLSInfo defines Auth and Safe as SafeHS /\ Strong*,
-            Hence the actual idealization parameter is just SafeHS.
-                       A better name for it may be HonestStAE
-
-                 - Anyway, they do *not* depend on handshake completion,
-                   as the instance exists before Sig.verify and verifyData;
-                       the late postconditions of Handshake are just means
-                       to deduce Auth/Safe from application-level predicates.
-
-          - This supposes we stick to epochs as wide indexes;
-               otherwise conditions 1 and 3 are simpler.
-
-          - Conditions 3 and 4 is necessary at least for functional correctness.
-                   They are currently enforced by code inspection.
-
-          - PRF actually calls GEN at most once for every (CSR,Role).
-                   ensuring that Auth readers & writers share the same algorithm.
-                       We believe this will be addressed within PRF.
-
-
-   We may either define
-
-   type (;ki:id,rw:rw) state = (;I(ki),rw:rw) st
-   // this permits decryption at any id with matching I(ki)
-   // this is inocuous because there is at most one such id.
-
-   or systematically use aeIndex instead of id
-
-   or hide it under a "re-indexing" function that enforces some of those restrictions.
-
-  Questions:
-
-  - Intuitively, parametricity is not affected by index tightening
-    because of the agreement on epochs between readers & writers plus
-       the linearity assumption. How to make it formal?
-       In the lookup table, as we decrypt,
-       we will now get a value indexed only by the writer's id, ki' or I(ki').
-
-    One possibility is to index plaintexts etc tightly,
-    using I(ki), or even (CSR,Role), a rather large change that
-       propagates to the main API.
-
-    Another may be to return a ghost writer index ki', and use Complete => ki = ki'.
-       For instance, StatefulPlain might provide a re-indexing identity
-
-  - What is the purpose of the Safe => ... postconditons of encryp & decrypt?
-    whould it be Auth => ... ? why relying both on type abstraction and refinements?
-
-*)
-
-
-(* MK old?
-Theorems:
- * (By Typing) The F# code for StatefulLHAE meets its F7 interface.
- * (Corollary) In safe epochs, the history, each plaintext, and LHAE keys are
-   kept confidential.
- * (Corollary) In safe epochs, the overall length of plaintext in
-   the history is kept confidential (within a range).
- * (Corollary) In safe epochs, the sequence of plaintexts returned
-   by decryption (at the receiver) is a prefix of the sequence of
-   plaintexts passed to encryption (at the sender.)
-
-*)
-
 private type (;ki:id,rw:rw) state = {
   key    : (;ki,rw) LHAE.LHAEKey;  // possibly stateful
   history: (;ki) history           // ghost state, except for the sequence number
@@ -117,10 +35,6 @@
 // when AuthId(i), the reader decrypts by table lookup
 // turning forgeries into errors; retrieving the "right" history index; returning the concrete decrypted range

-//CF 21/4: ENCrypted is an event tracking written cipher fragments; not sure about details and contents ?!
-//CF e.g.    * the decrypted rg is NOT authenticated
-//CF         * the states are not necessarily synchronized; only the histories are when AuthId(i)
-
 type cipher = LHAE.cipher

 predicate ENCrypted of e:id * h:(;e)history * ad:(;e)adata * cipher
@@ -147,19 +61,3 @@
        rg = CipherRangeClass(ki,Length(c)) /\
        (SafeId(ki) => ENCrypted(ki,History(ki,Reader,rd),ad,c))
   }) Result
-
-(* AP Older version, equivalent to the current one (?), but more difficult to typecheck
-  r:((;ki) reader * rg:range * (;ki,ad,History(ki,Reader,rd),rg) plain) Result
-  { !rd',rg,f. r = Correct((rd',rg,f)) =>
-               (   History(ki,Reader,rd') =
-                   ExtendHistory(ki,ad,History(ki,Reader,rd),rg,f) /\
-                   rg = CipherRangeClass(ki,Length(c)) /\
-                (SafeId(ki) =>
-                               ( (!rd',rg,f. r = Correct((rd',rg,f)) => ENCrypted(ki,History(ki,Reader,rd),ad,c)) // /\
-                               //  (!rg,p. ENCrypted(ki,rd,ad,rg,Payload(ki,ad,rg,p),c) => (?rd',rg. res = Correct((rd',rg,p))))
-                               )
-                        ) ) }
-*)
-
-//CF 21/4: as stated, we need the resulting readers and writers to have explicitly-updated histories (irrespective of AUTH)
-//CF 21/4: can we return an option instead? Otherwise we may have to specify which errors can be returned.
diff -Ewbur /opt/mitls/lib/StatefulPlain.fs /opt/miTLS-0.8.1/lib/StatefulPlain.fs
--- /opt/mitls/lib/StatefulPlain.fs     2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/StatefulPlain.fs       2014-12-04 17:11:27.000000000 +0100
@@ -48,7 +48,6 @@

 type plain = fragment

-//CF just for performance? justified because the history is ghost.
 let consHistory (i:id) (h:prehistory) (d:adata) (r:range) (f:fragment) =
 #if ideal
     (d,r,f)::h
@@ -65,8 +64,7 @@
   res

 let plain (i:id) (h:history) (ad:adata) (r:range) (b:bytes) =
-    //CF cut: let i = unAuthIdInv i in
-    //CF cut: let h = TLSFragment.emptyHistory i //CF Not Auth: we can pick any history
+
     let ct = parseAD i ad in
     {contents = TLSFragment.fragment i ct r b}
 let reprFragment (i:id) (ad:adata) (r:range) (f:plain) =
diff -Ewbur /opt/mitls/lib/StatefulPlain.fs7 /opt/miTLS-0.8.1/lib/StatefulPlain.fs7
--- /opt/mitls/lib/StatefulPlain.fs7    2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/StatefulPlain.fs7      2014-12-04 17:11:27.000000000 +0100
@@ -32,13 +32,11 @@
 //     (PvOfId(i) <> SSL_3p0 /\ b= prefix @| VersionBytes(i.pv) => ParseAD(i,b) = ParseCT(prefix) )
 //ADBytes(i,ct) = (CTBytes(ct) @| VersionBytes(i.pv )))

-//CF why do we need to parse AD again?
-val makeAD:  i:id -> ct:ContentType -> ad:(;i)adata{B(ad)=ADBytes(i,ct)} //MK Strange see ask below /\ ParseAD(i,B(ad)) = ct
-private val parseAD: i:id -> ad:(;i)adata -> ct:ContentType{B(ad)=ADBytes(i,ct)} //MK /\ ParseAD(i,B(ad))=ct}
+val makeAD:  i:id -> ct:ContentType -> ad:(;i)adata{B(ad)=ADBytes(i,ct)}
+private val parseAD: i:id -> ad:(;i)adata -> ct:ContentType{B(ad)=ADBytes(i,ct)}

 ask !i,ct,ad. B(ad)=ADBytes(i,ct) => ParseAD(i,B(ad))=ct

-
 private type (;i:id,ad:cbytes,r:range) fragment = {contents: (;i,ParseAD(i,ad),r)TLSFragment.fragment}

 function val Payload: i:id * ad:cbytes * r:range * (;i,ad,r)fragment -> cbytes
@@ -80,30 +78,18 @@

 predicate Sent of i:id * ad:cbytes *  h:(;i)history * r:range * (;i,ad,r)fragment

-//CF was too strong
-//CF private definition !e,ad,sh,r,f.
-//CF    Sent(Id(e),ad,sh,r,f) <=>
-//CF    TLSFragment.RecordSent(e,ParseAD(Id(e),ad),Multiplexed(e,sh),r,f.contents)
-
-//CF temporary, until we derive it from event-based affinity.
-//CF and actually not sufficient...
-
 private definition !i,ad,sh,r,f.
     Sent(i,ad,sh,r,f) <=>
         (?e. i = Id(e) /\
               TLSFragment.RecordSent(e,ParseAD(i,ad),Multiplexed(e,sh),r,f.contents))

-
 private definition !i. StAEHistory(i,[])
 private definition !i,ad,sn,h,r,f.
     (StAEHistory(i,h) /\ Sent(i,B(ad),(sn,h),r,f)) => StAEHistory(i,(ad,r,f)::h)

-//CF how do we prove it? where do we use it?
 theorem !i,ad,sn,h,r,f.
     Sent(i,B(ad),(sn,h),r,f) => (StAEHistory(i,h) /\ HLength(i,h) = sn)

-
-
 //------------------------------------------------------------------------------------------------------
 // `Plain' interface towards StatefulLHAE, encapsulating TLS-specific headers and content types
 //------------------------------------------------------------------------------------------------------
@@ -149,35 +135,8 @@
     i:id -> h:(;i)prehistory -> ad:(;i)adata -> r:range ->
        f:(;i,B(ad),r)fragment -> h':(;i)prehistory{h' = (ad,r,f)::h}

-//CF Sent grows linearly
-//CF assume !i.          Sent(i,(0,[]))
-//CF assume !i,h,ad,r,x. Sent(i,ExtendHistory(i,h,ad,r,x)) => Sent(i,h)
-//CF assume !i,ad,h,h',r,f. (AuthId(i) /\ Sent(i,ad,h,r,f) /\ Sent(i,ad,h',r,f) /\ SeqN(i,h) = SeqN(i,h')) => h = h'
-
-//CF usage?
 assume !i,ad,h,h',r,f. (AuthId(i) /\ StAEHistory(i,h) /\ StAEHistory(i,h') /\ HLength(i,h) = HLength(i,h')) => h = h'

-//MK---------------------------------------------------- Everything until here is epoch free
-
-
-
-(* CF 14-07-15 ??
-private assume !e,e',ad,sh,r,d.
-       (Id(e) = Id(e') /\
-       (AuthId(Id(e)) => TLSFragment.RecordSent(e',ad,Multiplexed(e',sh),r,d))) =>
-       (AuthId(Id(e)) => TLSFragment.RecordSent(e,ad,Multiplexed(e,sh),r,d))
-
-private ask !e,ct,sh,r,f.
-  (AuthId(Id(e)) => TLSFragment.RecordSent(e,ct,Multiplexed(e,sh),r,f.contents)) =>
-  (AuthId(Id(e)) => Sent(Id(e),ADBytes(Id(e),ct),sh,r,f))
-
-private ask !e,ad,sh,r,f.
-  (AuthId(Id(e)) => Sent(Id(e),ad,sh,r,f)) =>
-  (AuthId(Id(e)) => TLSFragment.RecordSent(e,ParseAD(Id(e),ad),Multiplexed(e,sh),r,f.contents))
-
-*)
-
-//CF usage?
 val RecordPlainToStAEPlain:
     e:epoch -> ct:ContentType ->
     ad:(;Id(e))adata{B(ad) = ADBytes(Id(e),ct)}  ->
@@ -192,6 +151,5 @@
     ad:(;Id(e))adata{B(ad) = ADBytes(Id(e),ct)} ->
     h:(;e) TLSFragment.history ->
     sh:(;Id(e)) history{h = Multiplexed(e,sh)} -> rg:range ->
-    d:(;Id(e),ad,sh,rg) plain ->                                       //MK has {AuthId(i) => Sent(i,B(ad),sh,rg,d)} refinement
-    f:(;e,ct,h,rg) TLSFragment.plain{f=StAEToRecord(Id(e),ct,rg,d)}    //MK has {Auth(e) => RecordSent(e,ct,h,rg,f) } refinement
-
+    d:(;Id(e),ad,sh,rg) plain ->
+    f:(;e,ct,h,rg) TLSFragment.plain{f=StAEToRecord(Id(e),ct,rg,d)}
Only in /opt/mitls/lib: Stream.fs
Only in /opt/mitls/lib: Stream.fs7
Only in /opt/mitls/lib: Stream.fsi
diff -Ewbur /opt/mitls/lib/TLS.fs /opt/miTLS-0.8.1/lib/TLS.fs
--- /opt/mitls/lib/TLS.fs       2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/TLS.fs 2014-12-04 17:11:27.000000000 +0100
@@ -42,7 +42,6 @@

 let request c po = Dispatch.request c po

-
 let read ca =
   let cb,outcome = Dispatch.read ca in
     match outcome with
@@ -89,8 +88,6 @@
       | WriteAgain | WriteAgainFinishing | WriteAgainClosing ->
           unexpected "[write] writeAll should never ask to write again"

-
-
 let full_shutdown c = Dispatch.full_shutdown c
 let half_shutdown c = Dispatch.half_shutdown c

diff -Ewbur /opt/mitls/lib/TLS.fs7 /opt/miTLS-0.8.1/lib/TLS.fs7
--- /opt/mitls/lib/TLS.fs7      2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/TLS.fs7        2014-12-04 17:11:28.000000000 +0100
@@ -127,7 +127,6 @@
 val connect : Tcp.NetworkStream -> c:config -> (;Client,c) nullCn
 val resume  : Tcp.NetworkStream -> sid:sessionID ->  c:config -> (;Client,c) nullCn
 // even if the server declines, we authenticate the client's intent to resume from this sid.
-// AP: Agreed, but there's no refinement keeping track of the desired sid.

 val rekey: c:Connection {Role(c) = Client} -> conf:config ->
        (b:bool * c':Connection) {
@@ -159,9 +158,6 @@
 // we echo the query so that we have an explicit user decision to blame.
 val authorize : c:Connection -> q:query-> (;c)ioresult_i
 val refuse    : c:Connection -> q:query -> unit
-// AP: we will have to internally send a fatal alert,
-// AP: and this might fail. We might want to give some feedback to the user.
-// AP: Same as for half_shutdown

 val getSessionInfo: k:succEpoch -> s:SessionInfo{s = EpochSI(k)}

@@ -170,42 +166,3 @@

 val getInStream : c:Connection -> s:(;ConnectionEpochIn (c)) stream{s = CnStream_i(c)}
 val getOutStream: c:Connection -> s:(;ConnectionEpochOut(c)) stream{s = CnStream_o(c)}
-
-(* FIXME:
-   For each call through this API, say connect(x,p) returning r,
-   we may use homonymous events, say Connect(x,p) & Connected(x,p,r),
-   or something more ad hoc, like Writing, generated internally between Write & Written
-   (s/Write/Writing/ later)
-
-   Missing:
-
-   predicate val Nego(cp,sp,ki)
-   // ki (or some other part of ci?) is an outcome of negotiating
-   // with initial parameters cp and sp; we will write its logical def.
-   // it would be great if ki was unique, and non-existent if cp, sp are not compatible.
-
-   We miss some "Finished" event,
-   generated by the Handshake for each party, as it sends the CCS, carried by the Finished message
-   To generate this event, we have a precise precondition that depends on the ciphersuite etc
-   (from Handshake), to support fast start
-
-   The other end logically receives that event after verifying the other guy's Finished message
-   We reveal that event in the TLS interface, as a consequence of read returning Handshake.
-   We may reveal that event early, using another ioresult_i, e.g. to enable "fast start".
-
-   Example: as the client receives notification of a complete handshake, we have a thm:
-
-   !c,c'. Read(c,Handshake(c')) =>
-          ?sp.   Nego(cp(c),sp,ki(c'))
-                     /\ Next(c,c') /\ Epoch(c') = Epoch(c)+1
-                     /\ ?c''. (Authorized(c'',serverCerts(c')) /\ Prior(c'',c))
-                         /\ ( StrongHandshakeCipherSuite(ki(c')) /\ Honest(serverCerts(ki(c')))
-                              => ServerFinished(sp,ki)
-
-   Problem: intuitively, events tracking calls & returns are threaded by their connections,
-   but logically that information is missing. To this end, we may explicitly thread connections,
-   using
-
-   Next(c,c') <=> UID(c') = UID(c) /\ Seqn(c') = Seqn(c) + 1
-   Prior(c,c') <=> UID(c') = UID(c) /\ Epoch(c') = Epoch(c) /\ Seqn(c) < Seqn(c')
-*)
diff -Ewbur /opt/mitls/lib/TLSConstants.fs /opt/miTLS-0.8.1/lib/TLSConstants.fs
--- /opt/mitls/lib/TLSConstants.fs      2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/TLSConstants.fs        2014-12-04 17:11:28.000000000 +0100
@@ -317,7 +317,6 @@

     | SCSV (TLS_EMPTY_RENEGOTIATION_INFO_SCSV)            -> abyte2 ( 0x00uy, 0xFFuy )

-(* KB: Must define known cipher suites as a predicate before typechecking the following: *)
     | _ -> unexpected "[cipherSuiteBytes] invoked on an unknown ciphersuite"

 let parseCipherSuite b =
@@ -385,7 +384,6 @@

     | _ -> Error(AD_decode_error, perror __SOURCE_FILE__ __LINE__ "")

-
 let consCipherSuites (cs:cipherSuite) (css:cipherSuites) = cs::css

 // called by the server handshake;
@@ -410,17 +408,6 @@
     | cs::css -> cipherSuiteBytes cs @|
                  cipherSuitesBytes css

-(*CF we could use sub instead, with proper refinements:
-let rec cipherSuites_of_bytes2 i b =
-    if i <= Length(b) + 2 then
-        cipherSuite_of_bytes (sub b i 2) :: cipherSuites_of_bytes2 (i+2) b
-    else if i = Length(b) then
-        []
-    else
-        Error // the cipherSuite had an odd length!
-*)
-
-
 let isAnonCipherSuite cs =
     match cs with
     | CipherSuite ( DH_anon, _ )   -> true
@@ -474,7 +461,6 @@
   | PRF_TLS_1p01 of prflabel          // MD5 xor SHA1
   | PRF_TLS_1p2 of prflabel * macAlg  // typically SHA256 but may depend on CS

-
 type kefAlg = prePrfAlg
 type kdfAlg = prePrfAlg
 type vdAlg = ProtocolVersion * cipherSuite
@@ -490,7 +476,7 @@
    // | CipherSuite ( ECDH*, MtE (_,SHA384)) -> SHA384
     | CipherSuite ( _ , CS_MtE ( _ , _ )) -> MA_HMAC(SHA256)
     | CipherSuite ( _ , CS_AEAD ( _ , hAlg ))   -> MA_HMAC(hAlg)
-    | OnlyMACCipherSuite (_, hAlg) -> MA_HMAC(SHA256) //MK should this be MA_HMAC(hAlg)?
+    | OnlyMACCipherSuite (_, hAlg) -> MA_HMAC(SHA256)
     | NullCipherSuite         -> unexpected "[prfHashAlg_of_ciphersuite] invoked on an invalid ciphersuite"
     | SCSV (_)                -> unexpected "[prfHashAlg_of_ciphersuite] invoked on an invalid ciphersuite"

@@ -533,7 +519,6 @@
           | AES_128_CBC -> CBC_Fresh(AES_128)
           | AES_256_CBC -> CBC_Fresh(AES_256))

-
 let aeAlg cs pv =
     match cs with
     | OnlyMACCipherSuite (_,alg) ->
@@ -548,7 +533,6 @@
         AEAD(e,mac)
     | _ -> unexpected "[aeAlg] invoked on an invalid ciphersuite"

-
 let encAlg_of_aeAlg ae =
     match ae with
     | MtE(e,m) -> e
@@ -569,7 +553,6 @@

 let mkIntTriple x:(int*int*int) = x

-
 (* Not for verification, just to run the implementation. See TLSInfo.fs *)
 type cipherSuiteName =
     | TLS_NULL_WITH_NULL_NULL
@@ -724,7 +707,6 @@
             | Error(x,y) -> Error(x,y)
             | Correct(rem) -> correct (n::rem)

-
 (* From Formats *)

 type preContentType =
@@ -775,24 +757,6 @@
     then correct b
     else Error(AD_decode_error, perror __SOURCE_FILE__ __LINE__ "")

-(*CF
-let split_at_most data len =
-    if len >= length data then
-        (data,empty_bstr)
-    else
-        split data len
-
-let rec appendList (xl:list<bytes>) : bytes =
-    match xl with
-    | [] -> empty_bstr
-    | h::t -> append h (appendList t)
-
-let rec splitList (b:bytes) (il:list<int>) : list<bytes> =
-    match il with
-    | [] -> [b]
-    | h::t -> let (x,y) = split b h in x::(splitList y t)
-*)
-
 type certType =
     | RSA_sign
     | DSA_sign
@@ -846,7 +810,6 @@
         | SA_DSA -> [DSA_fixed_dh]
         | _ -> unexpected "[defaultCertTypes] invoked on an invalid ciphersuite"

-
 let rec distinguishedNameListBytes names =
     match names with
     | [] -> empty_bytes
@@ -864,9 +827,6 @@
             match vlsplit 2 data with
             | Error(z) -> Error(z)
             | Correct (nameBytes,data) ->
-            let name = iutf8 nameBytes in (* FIXME: I have no idea wat "X501 represented in DER-encoding format" (RFC 5246, page 54) is. I assume UTF8 will do. *)
+            let name = iutf8 nameBytes in
             let res = name :: res in
             parseDistinguishedNameList data res
-
-
-
diff -Ewbur /opt/mitls/lib/TLSConstants.fs7 /opt/miTLS-0.8.1/lib/TLSConstants.fs7
--- /opt/mitls/lib/TLSConstants.fs7     2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/TLSConstants.fs7       2014-12-04 17:11:28.000000000 +0100
@@ -4,12 +4,6 @@
    This file also declares those that are assumed to be strong
    (such assumption are on both the algorithms and their implementation) *)

-(* CF 14-06-20 this file is part of the public API; it should *not*
-               include random constants and internal formats.
-               post-v1, we will cut out "TLSFormat" with TLS internal
-               formatting stuff and possibly "Assumptions" with all
-               algorithmic strength assumptions. *)
-
 open Bytes
 open Error
 open TLSError
@@ -29,7 +23,6 @@

 type ProtocolVersion = p:PreProtocolVersion{ IsProtocolVersion(p) }

-
 (** Not abstract, but meant to be used only by crypto modules and CipherSuites *)

 type blockCipher =
@@ -53,7 +46,6 @@
 // assume(IND_CPA(CBC_Stale(AES_256))) (see: http://www.isg.rhul.ac.uk/tls/ )
 //#end-cipherAssert

-
 (** Algorithms for the MAC module *)

 type hashAlg =
@@ -76,7 +68,6 @@
 // some unreasonable assumption
 // assume(INT_CMA_M(MD5))

-
 (** Signing algorithms for the Sig module *)

 type sigAlg =
@@ -94,7 +85,6 @@
 // assume(INT_CMA_S(SA_DSA,SHA,[SHA]))
 // assume(INT_CMA_S(SA_ECDSA,SHA,[SHA]))

-
 (** algorithms for the record protocol *)

 type aeadAlg =
@@ -103,7 +93,7 @@

 type aeAlg = // for specification of INT_CTXT predicate
     | MACOnly of macAlg
-    | MtE of encAlg * macAlg // TODO MK later, add the protocol version
+    | MtE of encAlg * macAlg
     | AEAD of aeadAlg * macAlg // macAlg is for the PRF

 predicate INT_CTXT of ProtocolVersion * aeAlg
@@ -112,8 +102,6 @@
 // This follows from Paterson et al.
 // assume !e,m. PRF(m) /\ SPRP(e) => INT_CTXT(TLS_1p2,MtE(CBC_Fresh(e),m))

-//CF we omit an intermediate predicate StrongAuthAlg for now
-
 predicate StrongAEAlg of ProtocolVersion * aeAlg
 definition !pv,ae. StrongAEAlg(pv,ae) <=>
   (?e,m. ae = MtE(e,m) /\
@@ -123,7 +111,6 @@

 ask !ae,m,pv. ae=MACOnly(m) => not StrongAEAlg(pv,ae)

-
 (** algorithms for the Handshake *)

 // all these kex have server auth & optional client auth,
@@ -144,12 +131,9 @@
 // In our code, we have some extra key agility:
 // we get StrongHS for the rest even if one of them is false.

-
 (* With F7, we need to declare both logical functions for lengths, constants, etc
    and their concrete F# implementations, typechecked against these logical functions. *)

-(* TODO: use uniform naming convention, e.g. length implements Length; make more defs private *)
-
 function val SigAlgBytes: sigAlg -> cbytes
 private definition
     (SigAlgBytes(SA_RSA)   = [|1uy|]) /\
@@ -186,14 +170,6 @@
 private definition BlockSize(AES_256)  = 16
 val blockSize: a:blockCipher -> l:nat {l=BlockSize(a)}

-(* AP: Commenting out as it looks unused in 'lib'
-function val EncAlgBlockSize: encAlg -> nat
-assume !x. EncAlgBlockSize(x) >= 0
-private definition !b. EncAlgBlockSize(CBC_Stale(b)) = BlockSize(b)
-private definition !b. EncAlgBlockSize(CBC_Fresh(b)) = BlockSize(b)
-private definition EncAlgBlockSize(Stream_RC4_128) = 0
-*)
-
 function val AEADKeySize: aeadAlg -> nat
 assume !x. AEADKeySize(x) >= 0
 private definition AEADKeySize(AES_128_GCM) = 16
@@ -281,7 +257,6 @@

 type cipherSuites = cipherSuite list

-
 (** Compression *)

 // By design, we entirely disable TLS-level compression
@@ -309,20 +284,12 @@
 definition CompressionsBytes([]) = [||]
 definition !h,t. CompressionsBytes(h::t) = CompressionBytes(h) @| CompressionsBytes(t)

-(* TODO This is in preparation of stricter post-conditions for parseCompressions. Currently unused.
-private assume !cl. ContainsCompressions(cl,cl) /\
-   (!cl. ContainsCompressions(cl,[])) /\
-   (!h,t,cl. ContainsCompressions(t,cl) => ContainsCompressions(h::t,cl)) /\
-   (!h,t,h',t'. ContainsCompressions(t,t') => ContainsCompressions(h::t,h'::t'))
-*)
-
 val compressionBytes: c:Compression -> b:bytes{CompressionBytes(c) = B(b)}
 val compressionMethodsBytes: cl:Compression list -> b:bytes{B(b) = CompressionsBytes(cl)}
 val parseCompression: b:bytes -> (c:Compression{B(b)=CompressionBytes(c)}) Result
 val parseCompressions: b:bytes -> cl:Compression list
 // We do not guarantee anything about the parsing of compression methods at the server
 // As invalid bytes are ignored B(b) = CompressionsBytes(cl) does not hold.
-// CF ???

 (** Versions *)

@@ -344,11 +311,6 @@
 val geqPV: a:ProtocolVersion -> b:ProtocolVersion -> r:bool
 val somePV: a: ProtocolVersion -> b:ProtocolVersion option {b = Some(a)}

-
-(* FIXME (post-v1): same duplication between logical and concrete function definitions,
-   already seen in TLSConstants.
-   CF: we could have saved a bit by not making cipherSuite abstract for F7.  *)
-
 predicate val IsNullCiphersuite: cipherSuite -> bool
 private definition !x. IsNullCiphersuite(x) <=> x = NullCipherSuite
 val nullCipherSuite: c:cipherSuite{IsNullCiphersuite(c)}
@@ -357,8 +319,6 @@
 predicate val IsSCSVCiphersuite: cipherSuite -> bool
 private definition !x. IsSCSVCiphersuite(x) <=> ?z. x = SCSV(z)

-(* TODO: predicates similar to the ones above, to be done when handling handshake *)
-//CF 14-06-16 recheck
 val isAnonCipherSuite: cipherSuite -> bool
 val isDHCipherSuite: cipherSuite -> bool
 val isDHECipherSuite: cipherSuite -> bool
@@ -366,8 +326,6 @@
 val isOnlyMACCipherSuite: cipherSuite -> bool
 val contains_TLS_EMPTY_RENEGOTIATION_INFO_SCSV: cipherSuites -> bool

-
-
 val verifyDataLen_of_ciphersuite: cipherSuite -> nat

 function val CiphersuitePrfMacAlg: cipherSuite -> macAlg
@@ -376,21 +334,15 @@
     (!a,b, hAlg.   CiphersuitePrfMacAlg( CipherSuite ( a , CS_AEAD ( b , hAlg )) )  = MA_HMAC(hAlg)   ) /\
     (!a,   hAlg.   CiphersuitePrfMacAlg( OnlyMACCipherSuite (a, hAlg) )             = MA_HMAC(SHA256) )

-
 val prfMacAlg_of_ciphersuite: cs:cipherSuite  -> ma:macAlg { ma=CiphersuitePrfMacAlg(cs) }
 val verifyDataHashAlg_of_ciphersuite: cs:cipherSuite -> hashAlg
 val sessionHashAlg: ProtocolVersion -> cipherSuite -> hashAlg

-// KB: Beware that these refinements are not visible and are not used by F7.
-// CF We rely on these labels being pairwise distinct to get domain separation
-// CF for the underlying PRF; for now this is used only informally,
-// CF to justify separate crypto assumptions; these refinements are unused.
 type prflabel = b:bytes { b=Utf8("master secret") \/ b=Utf8("extended master secret") \/ b=Utf8("key expansion") }
 val extract_label: l:prflabel {l=Utf8("master secret")}
 val extended_extract_label: l:prflabel {l=Utf8("extended master secret")}
 val kdf_label: l:prflabel {l=Utf8("key expansion")}

-
 // We need descriptors for the algorithm keyed by PMS and MS (named "PRF" in TLS)
 // Given pv and cs, and except for SSL3,
 // the same algorithm is used for extraction, key derivation, and verifyData
@@ -417,8 +369,7 @@
   pa=PRF_TLS_1p01(kdf_label) \/
   (?ma. pa=PRF_TLS_1p2(kdf_label,ma))}

-type vdAlg = ProtocolVersion * cipherSuite // TODO write supporting specs and functions
-
+type vdAlg = ProtocolVersion * cipherSuite

 function val TLSMACAlg: hashAlg   * ProtocolVersion -> macAlg
 function val TLSENCAlg: cipherAlg * ProtocolVersion -> encAlg
@@ -462,7 +413,6 @@
 private definition !kex,ae.
     CipherSuiteKEXAlg(CipherSuite(kex,ae)) = kex

-
 private definition !kex,mac,pv.
     CipherSuiteAuthEncAlg(OnlyMACCipherSuite(kex,mac),pv) = MACOnly(TLSMACAlg(mac,pv))
 private definition !kex,enc,mac,pv.
@@ -470,7 +420,6 @@
 private definition !kex,ae,prf,pv.
     CipherSuiteAuthEncAlg(CipherSuite(kex,CS_AEAD(ae,prf)),pv) = AEAD(ae,TLSMACAlg(prf,pv))

-
 function val AEMacAlg: aeAlg -> macAlg
 definition !mac.     AEMacAlg(MACOnly(mac)) = mac
 definition !mac,enc. AEMacAlg(MtE(enc,mac)) = mac
@@ -485,7 +434,6 @@
 ask !cs,pv,mac,enc. CipherSuiteAuthEncAlg(cs,pv) = MtE(enc,mac) => CipherSuiteMACAlg(cs,pv) = mac
 ask !cs,pv,mac,enc. CipherSuiteAuthEncAlg(cs,pv) = MtE(enc,mac) => CipherSuiteENCAlg(cs,pv) = enc

-
 private val tlsEncAlg: c:cipherAlg -> pv:ProtocolVersion -> e:encAlg{e = TLSENCAlg(c,pv)}
 private val tlsMacAlg: c:hashAlg -> pv:ProtocolVersion -> e:macAlg{e = TLSMACAlg(c,pv)}

@@ -557,51 +505,11 @@

     /\ CipherSuiteBytes(SCSV (TLS_EMPTY_RENEGOTIATION_INFO_SCSV))            = [| 0x00uy; 0xFFuy |]

-
 function val CipherSuitesBytes: cipherSuites -> cbytes
 private definition
    (CipherSuitesBytes([]) = [||]) /\
    (!h,t. CipherSuitesBytes(h::t) = CipherSuiteBytes(h) @| CipherSuitesBytes(t))

-
-
-(* TODO We currently do not rely on correct server side parsing of ciphersuites.
-
-old:
-predicate ContainsCipherSuite of cipherSuites * cipherSuite
-private definition !b,cs. ContainsCipherSuite(b,cs) <=>
-                (?h,t. b = h::t /\ (h = cs \/ ContainsCipherSuite(t,cs)))
-
-predicate ContainsCipherSuites of cipherSuites * cipherSuites
-private definition !b,l. ContainsCipherSuites(b,l) <=>
-  (l = [] \/
-   (?h,t. l = h::t /\ ContainsCipherSuite(b,h) /\ ContainsCipherSuites(b,t)))
-
-new by Cedric:
-
-predicate ContainsCipherSuite of bytes * cipherSuite
-private assume !b,cs. ContainsCipherSuite(b,cs) <=>
-                (?b1,b2. b = b1 @| b2 /\ Length(b1) = 2 /\
-                        (b1 = CipherSuiteBytes(cs) \/ ContainsCipherSuite(b2,cs)))
-
-predicate ContainsCipherSuites of bytes * cipherSuites
-private assume !b,l. ContainsCipherSuites(b,l) <=>
-  (l = [] \/
-   (?h,t. l = h::t /\ ContainsCipherSuite(b,h) /\ ContainsCipherSuites(b,t)))
-
-ask !b1,b2,cs. (Length(b1) = 2 /\ ContainsCipherSuite(b2,cs)) => ContainsCipherSuite(b1 @| b2, cs)
-//requires induction
-assume !b1,b2,l. (Length(b1) = 2 /\ ContainsCipherSuites(b2,l)) => ContainsCipherSuites(b1 @| b2, l)
-
-another style by Cedric:
-
-function val ParseCipherSuites: bytes -> cipherSuites
-private assume !b. (b = empty_bytes /\ ParseCipherSuites(b) = []) \/
-               (?b1,b2,c. b = b1 @| b2 /\ Length(b1) = 2 /\ b1 = CipherSuiteBytes(c) /\ ParseCiphersuites(b) = c::ParseCipherSuites(b2)) /\
-               (?b1,b2. b = b1 @| b2 /\ Length(b1) = 2 /\ (!c. b1 <> CipherSuiteBytes(c)) /\ ParseCiphersuites(b) = ParseCipherSuites(b2))
-
-*)
-
 private val consCipherSuites: cs:cipherSuite -> css:cipherSuites -> css':cipherSuites{css' = cs::css}

 val cipherSuiteBytes: c:cipherSuite -> b:bytes{Length(b)=2 /\ B(b) = CipherSuiteBytes(c)}
@@ -617,8 +525,6 @@

 val mkIntTriple: (nat * nat * nat) -> (nat * nat * nat)

-
-
 (* This type is not used for verification, just to run the
    implementation and let the client refer to concrete ciphersuites *)

@@ -682,7 +588,6 @@
   {ct = Change_cipher_spec \/ ct = Alert \/
    ct = Handshake \/ ct = Application_data}

-// CF what is this doing here?
 val bytes_of_seq: sn:nat -> b:bytes{Length(b) = 8 /\ b = IntBytes(8,sn)}
 val seq_of_bytes: b:bytes{Length(b)=8} -> sn:nat{b = IntBytes(8,sn)}

@@ -724,7 +629,6 @@
 ask !i,b. BLength(B(IntBytes(i,BLength(b))) @| b) = i + BLength(b)
 ask !i,b. BLength(VLBytes(i,b)) = i + BLength(b)

-// CF document why we need to assume this?
 // relies on associativity
 theorem !i,b1,b2,c1,c2.
   i >= 0 =>
@@ -755,7 +659,7 @@
            b:bytes{B(b)=CertTypesBytes(ctl)}
 val parseCertificateTypeList: b:bytes ->
        ctl:certType list{
-           //KB TODO? B(b) = CertTypesBytes(ctl)
+
          }

 function val DefaultCertTypes: bool * cipherSuite -> certType list
@@ -776,6 +680,5 @@
 val distinguishedNameListBytes: n:string list -> b:bytes{B(b)=DistinguishedNameListBytes(n)}
 val parseDistinguishedNameList: b:bytes -> s:string list ->
        (res:string list{
-//KB TODO?             (* ?l. res = l @ s /\ b = DistinguishedNameListBytes(l) *)              s = [] => B(b) = DistinguishedNameListBytes(res)
-       }) Result

+       }) Result
diff -Ewbur /opt/mitls/lib/TLSExtensions.fs /opt/miTLS-0.8.1/lib/TLSExtensions.fs
--- /opt/mitls/lib/TLSExtensions.fs     2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/TLSExtensions.fs       2014-12-04 17:11:28.000000000 +0100
@@ -403,7 +403,7 @@
     | TLSConstants.RSA_fixed_dh | TLSConstants.RSA_sign -> default_sigHashAlg_fromSig pv SA_RSA

 let rec cert_type_list_to_SigHashAlg ctl pv =
-    // FIXME: Generates a list with duplicates!
+
     match ctl with
     | [] -> []
     | h::t -> (cert_type_to_SigHashAlg h pv) @ (cert_type_list_to_SigHashAlg t pv)
@@ -414,7 +414,7 @@
     | TLSConstants.RSA_fixed_dh | TLSConstants.RSA_sign -> SA_RSA

 let rec cert_type_list_to_SigAlg ctl =
-    // FIXME: Generates a list with duplicates!
+
     match ctl with
     | [] -> []
     | h::t -> (cert_type_to_SigAlg h) :: (cert_type_list_to_SigAlg t)
diff -Ewbur /opt/mitls/lib/TLSExtensions.fs7 /opt/miTLS-0.8.1/lib/TLSExtensions.fs7
--- /opt/mitls/lib/TLSExtensions.fs7    2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/TLSExtensions.fs7      2014-12-04 17:11:28.000000000 +0100
@@ -9,8 +9,6 @@
 open TLSConstants
 open TLSInfo

-(* AP: New interface: to be proved *)
-
 // Following types used only in Handshake
 type clientExtension
 type serverExtension
@@ -37,68 +35,13 @@
 // Extended master secret
 val hasExtendedMS: negotiatedExtensions -> bool

-
 // Extended padding
 predicate HasExtendedPadding of id
 val hasExtendedPadding: id:id -> b:bool{b = true <=> HasExtendedPadding(id)}

-(* AP: OLD Interface
-type extensionType =
-    | HExt_renegotiation_info
-
-function val ExtensionTypeBytes: extensionType -> cbytes
-private definition ExtensionTypeBytes(HExt_renegotiation_info) = [|0xFFuy; 0x01uy|]
-
-val extensionTypeBytes: et:extensionType -> b:bytes{B(b)=ExtensionTypeBytes(et)}
-val parseExtensionType: b:bytes -> (et:extensionType{B(b)=ExtensionTypeBytes(et)}) Result
-val isExtensionType: et:extensionType -> ext:(extensionType * bytes) ->
-       b:bool{b = true => (?et',d. ext=(et',d) /\ et = et')}
-
-function val ExtensionBytes: extensionType * cbytes -> cbytes
-private definition !et,b.
-       ExtensionBytes(et,b) = ExtensionTypeBytes(et) @| VLBytes(2,b)
-predicate ContainsExtensions of cbytes * (extensionType * bytes) list
-// FIXME: Next is wrong!
-private definition !b,l. ContainsExtensions(b,l)
-
-val extensionBytes: et:extensionType -> d:bytes -> b:bytes{B(b)=ExtensionBytes(et,d)}
-val consExt: extensionType * bytes -> (extensionType * bytes) list -> (extensionType * bytes) list
-val parseExtensionList: b:bytes -> cur:(extensionType * bytes) list ->
-       (res:(extensionType * bytes) list{ContainsExtensions(B(b),res)}) Result
-
-val renegotiationInfoExtensionBytes: vd:bytes ->
-       b:bytes{B(b)=ExtensionBytes(HExt_renegotiation_info,VLBytes(1,B(vd)))}
-val parseRenegotiationInfoExtension: b:bytes ->
-       (vd:bytes{B(b)=VLBytes(1,B(vd))}) Result
-
-function val ExtensionsBytes: cbytes -> cbytes
-private definition !b. ExtensionsBytes(b) = VLBytes(2,b)
-val extensionsBytes: en:bool -> vd:bytes ->
-       b:bytes{(en = true /\ B(b) = ExtensionsBytes(ExtensionBytes(HExt_renegotiation_info,VLBytes(1,B(vd)))) ) \/
-                       (en = false /\ b = empty_bytes)}
-
-val parseExtensions: b:bytes -> (res:(extensionType * bytes) list
-       {(b = empty_bytes /\ res = [] ) \/
-        (b <> empty_bytes /\ ?ext. B(b) = VLBytes(2,ext) /\ ContainsExtensions(ext,res) )
-       }) Result
-
-val check_reneg_info: got:bytes -> exp:bytes ->
-       b:bool{b=true => (?d. B(got) = VLBytes(1,d) /\ exp = d)}
-
-// TODO: That's tricky. There's a hidden invariant on whether we are in the first, or subsequent handshake.
-val checkClientRenegotiationInfoExtension:
-       (extensionType * bytes) list -> cipherSuites -> bytes -> bool
-
-// TODO: Need to deal with lists to say something about this function
-val inspect_ServerHello_extensions:
-       (extensionType * bytes) list -> bytes ->
-               unit Result
-
-*)
-
 // Signature and Hash Algorithms

-function val SigHashAlgBytes: 'a (*TODO Sig.alg, can't use because it's a pair *) -> cbytes
+function val SigHashAlgBytes: 'a  -> cbytes
 private definition !s,h. SigHashAlgBytes((s,h)) = HashAlgBytes(s) @| SigAlgBytes(h)

 val sigHashAlgBytes: a:Sig.alg -> b:bytes{B(b)=SigHashAlgBytes(a)}
diff -Ewbur /opt/mitls/lib/TLSExtensions.fsi /opt/miTLS-0.8.1/lib/TLSExtensions.fsi
--- /opt/mitls/lib/TLSExtensions.fsi    2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/TLSExtensions.fsi      2014-12-04 17:11:28.000000000 +0100
@@ -35,8 +35,6 @@
 val hasExtendedPadding: id -> bool
 #endif

-//CF what are those doing here? relocate?
-//AP Partially relocate to TLSConstants, partially implement the mandatory signature extension, and embed them there. Maybe TODO before v1.0?
 val sigHashAlgBytes: Sig.alg -> bytes
 val parseSigHashAlg: bytes -> Result<Sig.alg>
 val sigHashAlgListBytes: list<Sig.alg> -> bytes
diff -Ewbur /opt/mitls/lib/TLSFragment.fs /opt/miTLS-0.8.1/lib/TLSFragment.fs
--- /opt/mitls/lib/TLSFragment.fs       2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/TLSFragment.fs 2014-12-04 17:11:28.000000000 +0100
@@ -11,16 +11,16 @@

 type fragment =
     | FHandshake of HSFragment.fragment //Cf Handshake.fragment
-    | FCCS of HSFragment.fragment //CF Handshake.ccsFragment
-    | FAlert of HSFragment.fragment //CF Alert.fragment
-    | FAppData of AppFragment.fragment //CF AppData.fragment
+    | FCCS of HSFragment.fragment
+    | FAlert of HSFragment.fragment
+    | FAppData of AppFragment.fragment
 type plain = fragment

 type history = {
-  handshake: HSFragment.stream; //CF Handshake.stream;
-  ccs:       HSFragment.stream; //CF Handshake.stream;
-  alert:     HSFragment.stream; //CF Alert.stream;
-  appdata:   DataStream.stream //CF AppData.stream;
+  handshake: HSFragment.stream;
+  ccs:       HSFragment.stream;
+  alert:     HSFragment.stream;
+  appdata:   DataStream.stream
 }

 let emptyHistory e =
@@ -100,7 +100,6 @@
     | Application_data,FAppData(f) -> let d,s' = AppFragment.delta e ss.appdata r f in
                                       {ss with appdata = s'}
     | _,_                          -> unexpected "[extendHistory] invoked on an invalid contenttype/fragment"
-    //CF unreachable too, but we'd need to list the other 12 cases to prove it.

 let makeExtPad i ct r frag =
     match ct,frag with
@@ -143,5 +142,5 @@
     | Application_data,FAppData(f) -> let f1 = AppFragment.widen i r0 f in
                                       FAppData(f1)
     | _,_                          -> unexpected "[widen] invoked on an invalid contenttype/fragment"
-    //CF unreachable too
+
 #endif
diff -Ewbur /opt/mitls/lib/TLSFragment.fs7 /opt/miTLS-0.8.1/lib/TLSFragment.fs7
--- /opt/mitls/lib/TLSFragment.fs7      2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/TLSFragment.fs7        2014-12-04 17:11:29.000000000 +0100
@@ -10,29 +10,6 @@
 open Error
 open TLSError

-(* CF [13/05/2013 21:18:54] KB on our current History design:
-
-TLSFragment.history and its associated predicates are indexed by epoch
-and not id only because they include the application datastream
-"DataStream.stream" which is indexed by epoch and not id.
-
-One way to clean this up would be to introduce an AppFragment.stream type
-that is indexed by ids (by hiding the DataStream's epoch parameter as a
-ghost element, as in AppFragment.fragment)
-
-StatefulPlain.History is the complete history of the TLS channel.
-Record then multiplexes this history into TLSFragment.history
-
-Since TLSFragment.history is fully determined by StatefulPlain.history
-(see the logical function StatefulPlain.Multiplexed), we actually do not
-need to maintain TLSFragment.history, but we still do in order to make our
-invariants in Dispatch easier to state.
-
-*)
-
-
-//CF are we still planning to define clones of HSFragment or not?
-
 type (;i:id,ct:ContentType,rg:range) fragment =
     | FHandshake of f:(;i,rg)HSFragment.fragment {ct=Handshake}
     | FCCS       of f:(;i,rg)HSFragment.fragment {ct=Change_cipher_spec}
@@ -80,9 +57,6 @@

 type (;e:epoch,ct:ContentType,h:(;e)history,rg:range) plain =
   f:(;Id(e),ct,rg)fragment { AuthId(Id(e)) => RecordSent(e,ct,h,rg,f) }
-  //MK { AuthId(Id(e)) => ?e'. Id(e')=Id(e) /\ RecordSent(e',ct,h,rg,f) }
-
-

 function val ExtendHistory: e:epoch * ct:ContentType * ss:(;e)history * r:range * (;e,ct,ss,r)plain -> 'a //(;e)history

@@ -109,7 +83,6 @@
     !e',h. RecordSent(e',ct,h,r0,f0) =>
            RecordSent(e',ct,h,RangeClass(i,r0),f1)}

-
 function val EmptyHistory: e:epoch -> (;e)history
 private definition !e. EmptyHistory(e) = {
        handshake = HSFragment.EmptyStream(Id(e));
diff -Ewbur /opt/mitls/lib/TLSInfo.fs /opt/miTLS-0.8.1/lib/TLSInfo.fs
--- /opt/mitls/lib/TLSInfo.fs   2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/TLSInfo.fs     2014-12-04 17:11:29.000000000 +0100
@@ -32,33 +32,14 @@
 type negotiatedExtensions = {ne_extended_ms: bool; ne_extended_padding:bool;
                              ne_renegotiation_info: option<(cVerifyData * sVerifyData)>}

-let noCsr:csrands = Nonce.random 64 //TODO should be Nonce.noCsr but this does not tc.
+let noCsr:csrands = Nonce.random 64

-(* MK:
-We could and probably should have:
-
-    type pms' = i:index * (;i)pms
-
-For example 'type index=int'.
-
-When we generate a pms we choose a unique index i. Then pmsId could be defined as:
-
-    type pmsId =
-        | NoPmsId
-        | SomePmsId of index
-
-    let pmsId (i,pms) = SomePmsId(i)
-
-What we have below is only possible because F7 allows comparison of
-values with an abstract type because of an implementation error.
-*)
 type pmsId =
   | NoPmsId
   | SomePmsId of PMS.pms
 let pmsId (pms:PMS.pms) = SomePmsId(pms)
 let noPmsId = NoPmsId

-
 type SessionInfo = {
     init_crand: crand;
     init_srand: srand;
@@ -82,11 +63,9 @@

 let noMsId = StandardMS (noPmsId, noCsr, PRF_SSL3_nested)

-
 let csrands sinfo =
     sinfo.init_crand @| sinfo.init_srand

-
 let kefAlg (si:SessionInfo) =
   match si.protocol_version with
   | SSL_3p0           -> PRF_SSL3_nested
@@ -111,7 +90,6 @@
 let vdAlg (si:SessionInfo) =
   si.protocol_version, si.cipher_suite

-
 let msi (si:SessionInfo) =
   let ext = si.extensions in
   if ext.ne_extended_ms = false then
@@ -156,7 +134,6 @@
     | FullEpoch (si,pe) -> Error.unexpected "[epochAI] invoked on full epoch."
     | AbbrEpoch (ai,pe1,pe2) -> ai

-
 let epochSRand e =
     match e with
     | InitEpoch (d) -> Error.unexpected "[epochSRand] invoked on initial epoch."
@@ -225,7 +202,7 @@

 let macAlg_of_id id = macAlg_of_aeAlg id.aeAlg
 let encAlg_of_id id = encAlg_of_aeAlg id.aeAlg
-let pv_of_id (id:id) =  id.pv //TODO MK fix
+let pv_of_id (id:id) =  id.pv
 let kdfAlg_of_id (id:id) = id.kdfAlg

 type event =
@@ -234,7 +211,6 @@
   | SentCCS of Role * SessionInfo
   | SentCCSAbbr of Role * abbrInfo

-
 let noId: id = {
   msId = noMsId;
   kdfAlg=PRF_SSL3_nested;
@@ -364,7 +340,7 @@
 let max_TLSPlaintext_fragment_length = 16384 (*@ 2^14 *)
 let max_TLSCompressed_fragment_length = max_TLSPlaintext_fragment_length + 1024
 let max_TLSCipher_fragment_length = max_TLSCompressed_fragment_length + 1024
-let fragmentLength = max_TLSPlaintext_fragment_length (*CF use e.g. 1 for testing *)
+let fragmentLength = max_TLSPlaintext_fragment_length

 #if ideal

@@ -382,7 +358,7 @@
 let safeCRE (e:SessionInfo) = failwith "spec only": bool
 let safeVD (e:SessionInfo) = failwith "spec only": bool
 let auth (e:epoch) = failwith "spec only": bool
-let safe (e:epoch) = failwith "spec only" : bool //CF Define in terms of strength and honesty
+let safe (e:epoch) = failwith "spec only" : bool

 let safeKDF (i:id) = failwith "spec only": bool
 let authId (i:id) = failwith "spec only":bool
diff -Ewbur /opt/mitls/lib/TLSInfo.fs7 /opt/miTLS-0.8.1/lib/TLSInfo.fs7
--- /opt/mitls/lib/TLSInfo.fs7  2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/TLSInfo.fs7    2014-12-04 17:11:29.000000000 +0100
@@ -39,7 +39,6 @@

 // -------------------------------------------------------------------
 // Application configuration options
-// TODO Consider repackaging client and server options

 type helloReqPolicy =
     | HRPIgnore
@@ -125,8 +124,6 @@
 definition !p,g,gx,gy,dhpms. HonestPMS(PmsId(PMS.DHPMS(p,g,gx,gy,dhpms))) <=> PMS.HonestDHPMS(p,g,gx,gy,dhpms)
 val noPmsId: i:pmsId { not HonestPMS(i) }
 val honestPMS: (pi:pmsId) -> b:bool {b=true => HonestPMS(pi)}
-// MK <= currently can't typecheck other direction.
-// CF should be derivable, but probably not used for now

 // Strengths of Handshake algorithms defined on pmsId

@@ -138,7 +135,6 @@
 // -------------------------------------------------------------------
 // Master Secret indexes and their properties

-// CF postv1, move strength predicates --> TLSConstants
 // ``kefAlg is a strong randomness extractor, despite all other kefAlgs'', guarding idealization in KEF
 predicate StrongKEF of kefAlg
 val strongKEF: ca:kefAlg -> b:bool {b=true <=> StrongKEF(ca)}
@@ -147,7 +143,6 @@
 predicate StrongKDF of kdfAlg
 predicate StrongVD  of vdAlg

-
 // -------------------------------------------------------------------
 // Session information (public immutable data)

@@ -156,7 +151,6 @@
 // to identify an active or resumable session state.''
 // We treat empty_bytes as the absence of identifier.

-// TODO this is out of sync with the paper, on client_auth.
 type SessionInfo = {
     init_crand: crand;
     init_srand: srand;
@@ -217,7 +211,6 @@
 function val SIaeAlg: SessionInfo -> aeAlg
 definition !si. SIaeAlg(si) = CipherSuiteAuthEncAlg(si.cipher_suite,si.protocol_version)

-
 type msId =
   StandardMS of         // We record the parameters used to derive this MS:
   pms   : pmsId *   // the pms index
@@ -227,7 +220,6 @@
   pms   : pmsId *       // the pms index
   sh    : sessionHash * // the hash of the session log
   kefAlg: kefAlg        // the PMS-PRF algorithm
-// CF We cannot use just csr, because of MiTM forwarding honest nonces

 // ``the MS at this index is abstractly generated and used within PRF''
 predicate HonestMS of msId
@@ -236,14 +228,8 @@
        (?pmsId,csr,kefAlg. msi = StandardMS(pmsId,csr,kefAlg) /\ HonestPMS(pmsId) /\ StrongKEF(kefAlg))
        \/ (?pmsId,sh,kefAlg. msi = ExtendedMS(pmsId,sh,kefAlg) /\ HonestPMS(pmsId) /\ StrongKEF(kefAlg)))

-//CF are we missing a correlation with csr?
-//MK we don't allow leak, so every MS derived from an
-//MK HonestPMS with strong KEF algorithms is honest?
-//MK More uniformally this would go through a definition of SafeCRE.
-
 val noMsId: i:msId { not HonestMS(i) }

-
 // Getting master-secret indexes out of SessionInfo

 function val MsI: SessionInfo -> msId
@@ -261,17 +247,15 @@
 // guarding idealization in PRF
 predicate StrongPRF of SessionInfo
 definition !si. StrongPRF(si) <=> StrongKDF(KdfAlg(si)) /\ StrongVD(VdAlg(si))
-// MK I think having this joint strength predicate
-// MK guaranteeing the idealization of the complete module is useful

 // Summarizing all assumptions needed for a strong handshake
-// CF derived & to be used in the public API only
+
 predicate StrongHS of SessionInfo
 definition !si. StrongHS(si) <=>
     StrongKEX(si.pmsId) /\
     StrongKEF(KefAlg(si)) /\
     StrongPRF(si) /\
-    StrongSig(si)  //CF * hashAlg for certs?
+    StrongSig(si)

 // Safety of SessionInfo crypto processing

@@ -282,8 +266,6 @@
 predicate SafeVD  of SessionInfo // Safe handshake for MS-based VerifyData
 definition !si. SafeVD(si) <=> (HonestMS(MsI(si)) /\ StrongVD(VdAlg(si)))
 val safeVD:  (si:SessionInfo) -> b:bool { b=true <=> SafeVD(si) }
-//MK: safeVD is used for idealization even if ciphersuites don't match.
-//MK: this is needed to guarantee security of finished message MACs

 predicate StrongAuthSI of SessionInfo
 definition !si. StrongAuthSI(si) <=>
@@ -314,12 +296,7 @@
 predicate val IsSuccEpoch: preEpoch -> bool
 predicate val IsFullEpoch: preEpoch -> bool
 predicate val IsAbbrEpoch: preEpoch -> bool
-//CF ?
-//MK fixes verification of epochWriter. Valid? Old:
-//MK   private definition !e. IsInitEpoch(e) <=> ?r. e = InitEpoch(r)
-//MK   private definition !e. IsSuccEpoch(e) <=> ?c,s,si,pe. e = SuccEpoch(c,s,si,pe)
-//MK with the following we might be able to prove that some e is IsSuccEpoch(e) though it is not a valid preEpoch
-//MK but that is also true for the existential version above.
+
 private definition !e:preEpoch. IsInitEpoch(e) <=> (?r:Role. e = InitEpoch(r))
 private definition !e:preEpoch.
         IsFullEpoch(e) <=> (?si:SessionInfo,pe:preEpoch. e = FullEpoch(si,pe))
@@ -355,7 +332,6 @@
 function val EpochAI: succEpoch -> abbrInfo
 private definition (!ai,p1,p2. EpochAI(AbbrEpoch(ai,p1,p2)) = ai)

-
 function val EpochCRand: succEpoch -> bytes
 function val EpochSRand: succEpoch -> bytes
 function val EpochCSRands: succEpoch -> bytes
@@ -476,7 +452,7 @@
 definition !i. PvOfId(i)=i.pv
 val pv_of_id: i:id -> pv:ProtocolVersion {pv=PvOfId(i)}

-val kdfAlg_of_id: id -> kdfAlg //TODO add and specify
+val kdfAlg_of_id: id -> kdfAlg

 // -----------------------------------------------------------------------
 // Safety of key derivation depends on matching algorithms (see PRF)
@@ -543,7 +519,7 @@
 // Re-indexing from epochs to ids

 val noId: i:id { not AuthId(i) }
-//TODO how to ask it !?!
+
 theorem not AuthId(noId)

 function val Id: epoch -> id
@@ -561,7 +537,6 @@
 ask !e. IsInitEpoch(e) => Id(e) = noId
 ask !e. IsInitEpoch(e) => not AuthId(Id(e))

-//KB maybe we don't need this, but it helps in AppFragment for now
 val unAuthIdInv: i:id{not AuthId(i)} -> s:epoch {Id(s) = i}

 // -------------------------------------------------------------------------
@@ -595,7 +570,6 @@
                    ((IsFullEpoch(e) /\ SentCCS(r,EpochSI(e)) /\ (SafeVD(EpochSI(e)) => SentCCS(DualRole(r),EpochSI(e)))) \/
                     (IsAbbrEpoch(e) /\ SentCCSAbbr(r,EpochAI(e)) /\ (SafeVD(EpochSI(e)) => SentCCSAbbr(DualRole(r),EpochAI(e))))))

-
 predicate Safe   of epoch        // The epoch parameters yield privacy & integrity
 definition !e. Safe(e) <=> (SafeId(Id(e)) /\ OpenState(e))
 val safe:   (e:epoch) -> b:bool { b = true <=> Safe(e)}
@@ -614,10 +588,6 @@
 ask !e. OpenState(e) => (SafeId(Id(e)) => Safe(e))
 ask !e. Auth(e) => OpenState(e)

-//KB The following is only true with Reneg indication, but is difficult to remove.
-//KB It is an artifact of the way we treat epochs that we cannot just authenticate the current epoch, we need to always authenticate the full chain
-//KB Maybe a refactor for v2 would be to separate our the current epoch and an optional predecessor
-//KB Also this needs to account for SentCCSResume
 private theorem !r,r',e,e'. SentCCS(r,EpochSI(e)) /\
                            SentCCS(r',EpochSI(e')) /\
                            Id(e) = Id(e') => e = e'
@@ -625,7 +595,6 @@

 val sinfo_to_string: SessionInfo -> string

-//CF move those to TLSConstants?
 private val max_TLSPlaintext_fragment_length: nat
 private val max_TLSCompressed_fragment_length: nat
 val max_TLSCipher_fragment_length: nat
diff -Ewbur /opt/mitls/lib/TLSInfo.fsi /opt/miTLS-0.8.1/lib/TLSInfo.fsi
--- /opt/mitls/lib/TLSInfo.fsi  2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/TLSInfo.fsi    2014-12-04 17:11:29.000000000 +0100
@@ -31,12 +31,10 @@
 type negotiatedExtensions = {ne_extended_ms: bool; ne_extended_padding:bool;
                              ne_renegotiation_info: option<(cVerifyData * sVerifyData)>}

-
 type pmsId
 val pmsId: PMS.pms -> pmsId
 val noPmsId: pmsId

-
 type SessionInfo = {
     init_crand: crand;
     init_srand: srand;
Only in /opt/mitls/lib: TLSRecord.fs7
Only in /opt/mitls/lib: TLS_metrics.ods
diff -Ewbur /opt/mitls/lib/UTLS.fs /opt/miTLS-0.8.1/lib/UTLS.fs
--- /opt/mitls/lib/UTLS.fs      2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/UTLS.fs        2014-12-04 17:11:29.000000000 +0100
@@ -2,8 +2,6 @@

 module UTLS

-// TODO: locking
-
 (* ------------------------------------------------------------------------ *)
 open Bytes
 open Error
@@ -154,7 +152,6 @@
         let (d0,d1) = DataStream.split e st rg0 rg1 d in
         (rg0,d0)

-
 let write (fd : fd) (bytes : bytes) : int =
     match connection_of_fd fd with
     | None    -> EI_BADHANDLE
diff -Ewbur /opt/mitls/lib/UntrustedCert.fs /opt/miTLS-0.8.1/lib/UntrustedCert.fs
--- /opt/mitls/lib/UntrustedCert.fs     2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/lib/UntrustedCert.fs       2014-12-04 17:11:29.000000000 +0100
@@ -89,7 +89,7 @@

 (* ------------------------------------------------------------------------ *)
 let x509_check_key_sig_alg (sigkeyalg : Sig.alg) (x509 : X509Certificate2) =
-    match x509.SignatureAlgorithm with (* AP: WARN: OID_MD5WithRSAEncryption is obsolete - removed *)
+    match x509.SignatureAlgorithm with
     | o when o.Value = OID_SHAWithRSAEncryption ->
          (* We are not strict, to comply with TLS < 1.2 *)
             sigkeyalg = (SA_RSA, MD5SHA1)
@@ -111,7 +111,7 @@
         chain.Build(x509)

 (* ------------------------------------------------------------------------ *)
-let x509_chain (x509 : X509Certificate2) = (* FIXME: Is certs. store must be opened ? *)
+let x509_chain (x509 : X509Certificate2) =
     let chain = new X509Chain() in
         chain.ChainPolicy.RevocationMode <- X509RevocationMode.NoCheck;
         ignore (chain.Build(x509));
@@ -146,7 +146,6 @@

 let x509list_to_chain (chain : list<X509Certificate2>): chain  = List.map x509_export_public chain

-
 let rec validate_x509list (c : X509Certificate2) (issuers : list<X509Certificate2>) =
     try
         let chain = new X509Chain () in
Only in /opt/mitls/lib: index.txt
Only in /opt/mitls/lib: interactive
Only in /opt/mitls/lib: predicates.txt
Only in /opt/mitls: metrics
Only in /opt/mitls: miTLS-0.1.0.tgz
Only in /opt/mitls: miTLS-0.1.3-r33070.patch
Only in /opt/mitls: miTLS-0.1.3.tgz
Only in /opt/mitls: mihttp
Only in /opt/mitls/pwapp: Makefile
diff -Ewbur /opt/mitls/pwapp/PwApp.fs /opt/miTLS-0.8.1/pwapp/PwApp.fs
--- /opt/mitls/pwapp/PwApp.fs   2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/pwapp/PwApp.fs     2014-12-04 17:11:29.000000000 +0100
@@ -153,7 +153,7 @@
             | CertQuery (_,_,_) -> None
             | CompletedFirst (conn)
             | CompletedSecond (conn) -> handle_client_request conn
-            | Read(conn,m) -> None // AP: should never happen
+            | Read(conn,m) -> None
         else
             refuse conn q; None
     | CompletedFirst conn
diff -Ewbur /opt/mitls/pwapp/PwToken.fs7 /opt/miTLS-0.8.1/pwapp/PwToken.fs7
--- /opt/mitls/pwapp/PwToken.fs7        2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/pwapp/PwToken.fs7  2014-12-04 17:11:30.000000000 +0100
@@ -82,4 +82,3 @@
   -> d  : (;ki, s, r) delta

   -> bool
-
\ No newline at end of file
Only in /opt/mitls/pwapp: genrules
Only in /opt/mitls: rpc
Only in /opt/mitls/scripts: anonymize
Only in /opt/mitls/scripts: makegen
Only in /opt/mitls/scripts: pyparsing.py
Only in /opt/mitls/scripts: pyparsing.pyc
Only in /opt/mitls/scripts: show_comments.py
Only in /opt/mitls/scripts: xunit-tc7
Only in /opt/mitls: tests
Only in /opt/mitls: tls.sdf
diff -Ewbur /opt/mitls/tls.sln /opt/miTLS-0.8.1/tls.sln
--- /opt/mitls/tls.sln  2014-12-04 15:58:41.000000000 +0100
+++ /opt/miTLS-0.8.1/tls.sln    2014-12-04 17:11:22.000000000 +0100
@@ -1,4 +1,4 @@
-
+
 Microsoft Visual Studio Solution File, Format Version 12.00
 # Visual Studio 2013
 VisualStudioVersion = 12.0.30723.0
@@ -17,23 +17,10 @@
 EndProject
 Project("{F2A71F9B-5D33-465A-A702-920D77279786}") = "DB", "DB\DB.fsproj", "{CAD78B05-0ADC-433B-954B-1F31FC6477F6}"
 EndProject
-Project("{F2A71F9B-5D33-465A-A702-920D77279786}") = "BenchClient", "BenchClient\BenchClient.fsproj", "{EB2F95AE-C1CA-451F-96E6-40B33A2344D5}"
-EndProject
-Project("{F2A71F9B-5D33-465A-A702-920D77279786}") = "BenchServer", "BenchServer\BenchServer.fsproj", "{377A7C1A-5294-4AD8-9121-BFAACF65AD5C}"
-EndProject
 Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "OpenSSL", "OpenSSL\OpenSSL.csproj", "{DB787D27-C33E-4D14-BF2C-B92CBDBF0C54}"
 EndProject
 Project("{F2A71F9B-5D33-465A-A702-920D77279786}") = "Platform", "Platform\Platform.fsproj", "{408E6F53-363A-4C58-9808-84A0B526324B}"
 EndProject
-Project("{F2A71F9B-5D33-465A-A702-920D77279786}") = "AutoBench", "AutoBench\AutoBench.fsproj", "{2CE2CB44-953C-414F-BA55-BF45AD43D530}"
-EndProject
-Project("{F2A71F9B-5D33-465A-A702-920D77279786}") = "mihttp", "mihttp\mihttp.fsproj", "{F5B505A7-EA88-45CC-A001-46D67077F382}"
-       ProjectSection(ProjectDependencies) = postProject
-               {6D4E3F46-DBF9-473B-93BA-58614114AA57} = {6D4E3F46-DBF9-473B-93BA-58614114AA57}
-               {408E6F53-363A-4C58-9808-84A0B526324B} = {408E6F53-363A-4C58-9808-84A0B526324B}
-               {7283C0EF-3C40-495D-9969-79CB71B3AACC} = {7283C0EF-3C40-495D-9969-79CB71B3AACC}
-       EndProjectSection
-EndProject
 Project("{F2A71F9B-5D33-465A-A702-920D77279786}") = "DHDBManager", "DHDBManager\DHDBManager.fsproj", "{2DA9CE8A-C82F-4CF2-8329-79B8A3F19F1F}"
 EndProject
 Global
@@ -211,54 +198,6 @@
                {CAD78B05-0ADC-433B-954B-1F31FC6477F6}.Release|Win32.ActiveCfg = Release|Any CPU
                {CAD78B05-0ADC-433B-954B-1F31FC6477F6}.Release|x64.ActiveCfg = Release|Any CPU
                {CAD78B05-0ADC-433B-954B-1F31FC6477F6}.Release|x86.ActiveCfg = Release|Any CPU
-               {EB2F95AE-C1CA-451F-96E6-40B33A2344D5}.Debug|Any CPU.ActiveCfg = Debug|x86
-               {EB2F95AE-C1CA-451F-96E6-40B33A2344D5}.Debug|Any CPU.Build.0 = Debug|x86
-               {EB2F95AE-C1CA-451F-96E6-40B33A2344D5}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
-               {EB2F95AE-C1CA-451F-96E6-40B33A2344D5}.Debug|Mixed Platforms.Build.0 = Debug|x86
-               {EB2F95AE-C1CA-451F-96E6-40B33A2344D5}.Debug|Win32.ActiveCfg = Debug|x86
-               {EB2F95AE-C1CA-451F-96E6-40B33A2344D5}.Debug|x64.ActiveCfg = Debug|x86
-               {EB2F95AE-C1CA-451F-96E6-40B33A2344D5}.Debug|x86.ActiveCfg = Debug|x86
-               {EB2F95AE-C1CA-451F-96E6-40B33A2344D5}.Debug|x86.Build.0 = Debug|x86
-               {EB2F95AE-C1CA-451F-96E6-40B33A2344D5}.Ideal|Any CPU.ActiveCfg = Debug|x86
-               {EB2F95AE-C1CA-451F-96E6-40B33A2344D5}.Ideal|Any CPU.Build.0 = Debug|x86
-               {EB2F95AE-C1CA-451F-96E6-40B33A2344D5}.Ideal|Mixed Platforms.ActiveCfg = Release|x86
-               {EB2F95AE-C1CA-451F-96E6-40B33A2344D5}.Ideal|Mixed Platforms.Build.0 = Release|x86
-               {EB2F95AE-C1CA-451F-96E6-40B33A2344D5}.Ideal|Win32.ActiveCfg = Release|x86
-               {EB2F95AE-C1CA-451F-96E6-40B33A2344D5}.Ideal|x64.ActiveCfg = Release|x86
-               {EB2F95AE-C1CA-451F-96E6-40B33A2344D5}.Ideal|x86.ActiveCfg = Release|x86
-               {EB2F95AE-C1CA-451F-96E6-40B33A2344D5}.Ideal|x86.Build.0 = Release|x86
-               {EB2F95AE-C1CA-451F-96E6-40B33A2344D5}.Release|Any CPU.ActiveCfg = Release|x86
-               {EB2F95AE-C1CA-451F-96E6-40B33A2344D5}.Release|Any CPU.Build.0 = Release|x86
-               {EB2F95AE-C1CA-451F-96E6-40B33A2344D5}.Release|Mixed Platforms.ActiveCfg = Release|x86
-               {EB2F95AE-C1CA-451F-96E6-40B33A2344D5}.Release|Mixed Platforms.Build.0 = Release|x86
-               {EB2F95AE-C1CA-451F-96E6-40B33A2344D5}.Release|Win32.ActiveCfg = Release|x86
-               {EB2F95AE-C1CA-451F-96E6-40B33A2344D5}.Release|x64.ActiveCfg = Release|x86
-               {EB2F95AE-C1CA-451F-96E6-40B33A2344D5}.Release|x86.ActiveCfg = Release|x86
-               {EB2F95AE-C1CA-451F-96E6-40B33A2344D5}.Release|x86.Build.0 = Release|x86
-               {377A7C1A-5294-4AD8-9121-BFAACF65AD5C}.Debug|Any CPU.ActiveCfg = Debug|x86
-               {377A7C1A-5294-4AD8-9121-BFAACF65AD5C}.Debug|Any CPU.Build.0 = Debug|x86
-               {377A7C1A-5294-4AD8-9121-BFAACF65AD5C}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
-               {377A7C1A-5294-4AD8-9121-BFAACF65AD5C}.Debug|Mixed Platforms.Build.0 = Debug|x86
-               {377A7C1A-5294-4AD8-9121-BFAACF65AD5C}.Debug|Win32.ActiveCfg = Debug|x86
-               {377A7C1A-5294-4AD8-9121-BFAACF65AD5C}.Debug|x64.ActiveCfg = Debug|x86
-               {377A7C1A-5294-4AD8-9121-BFAACF65AD5C}.Debug|x86.ActiveCfg = Debug|x86
-               {377A7C1A-5294-4AD8-9121-BFAACF65AD5C}.Debug|x86.Build.0 = Debug|x86
-               {377A7C1A-5294-4AD8-9121-BFAACF65AD5C}.Ideal|Any CPU.ActiveCfg = Debug|x86
-               {377A7C1A-5294-4AD8-9121-BFAACF65AD5C}.Ideal|Any CPU.Build.0 = Debug|x86
-               {377A7C1A-5294-4AD8-9121-BFAACF65AD5C}.Ideal|Mixed Platforms.ActiveCfg = Release|x86
-               {377A7C1A-5294-4AD8-9121-BFAACF65AD5C}.Ideal|Mixed Platforms.Build.0 = Release|x86
-               {377A7C1A-5294-4AD8-9121-BFAACF65AD5C}.Ideal|Win32.ActiveCfg = Release|x86
-               {377A7C1A-5294-4AD8-9121-BFAACF65AD5C}.Ideal|x64.ActiveCfg = Release|x86
-               {377A7C1A-5294-4AD8-9121-BFAACF65AD5C}.Ideal|x86.ActiveCfg = Release|x86
-               {377A7C1A-5294-4AD8-9121-BFAACF65AD5C}.Ideal|x86.Build.0 = Release|x86
-               {377A7C1A-5294-4AD8-9121-BFAACF65AD5C}.Release|Any CPU.ActiveCfg = Release|x86
-               {377A7C1A-5294-4AD8-9121-BFAACF65AD5C}.Release|Any CPU.Build.0 = Release|x86
-               {377A7C1A-5294-4AD8-9121-BFAACF65AD5C}.Release|Mixed Platforms.ActiveCfg = Release|x86
-               {377A7C1A-5294-4AD8-9121-BFAACF65AD5C}.Release|Mixed Platforms.Build.0 = Release|x86
-               {377A7C1A-5294-4AD8-9121-BFAACF65AD5C}.Release|Win32.ActiveCfg = Release|x86
-               {377A7C1A-5294-4AD8-9121-BFAACF65AD5C}.Release|x64.ActiveCfg = Release|x86
-               {377A7C1A-5294-4AD8-9121-BFAACF65AD5C}.Release|x86.ActiveCfg = Release|x86
-               {377A7C1A-5294-4AD8-9121-BFAACF65AD5C}.Release|x86.Build.0 = Release|x86
                {DB787D27-C33E-4D14-BF2C-B92CBDBF0C54}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
                {DB787D27-C33E-4D14-BF2C-B92CBDBF0C54}.Debug|Any CPU.Build.0 = Debug|Any CPU
                {DB787D27-C33E-4D14-BF2C-B92CBDBF0C54}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
@@ -301,54 +240,6 @@
                {408E6F53-363A-4C58-9808-84A0B526324B}.Release|Win32.ActiveCfg = Release|Any CPU
                {408E6F53-363A-4C58-9808-84A0B526324B}.Release|x64.ActiveCfg = Release|Any CPU
                {408E6F53-363A-4C58-9808-84A0B526324B}.Release|x86.ActiveCfg = Release|Any CPU
-               {2CE2CB44-953C-414F-BA55-BF45AD43D530}.Debug|Any CPU.ActiveCfg = Debug|x86
-               {2CE2CB44-953C-414F-BA55-BF45AD43D530}.Debug|Any CPU.Build.0 = Debug|x86
-               {2CE2CB44-953C-414F-BA55-BF45AD43D530}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
-               {2CE2CB44-953C-414F-BA55-BF45AD43D530}.Debug|Mixed Platforms.Build.0 = Debug|x86
-               {2CE2CB44-953C-414F-BA55-BF45AD43D530}.Debug|Win32.ActiveCfg = Debug|x86
-               {2CE2CB44-953C-414F-BA55-BF45AD43D530}.Debug|x64.ActiveCfg = Debug|x86
-               {2CE2CB44-953C-414F-BA55-BF45AD43D530}.Debug|x86.ActiveCfg = Debug|x86
-               {2CE2CB44-953C-414F-BA55-BF45AD43D530}.Debug|x86.Build.0 = Debug|x86
-               {2CE2CB44-953C-414F-BA55-BF45AD43D530}.Ideal|Any CPU.ActiveCfg = Debug|x86
-               {2CE2CB44-953C-414F-BA55-BF45AD43D530}.Ideal|Any CPU.Build.0 = Debug|x86
-               {2CE2CB44-953C-414F-BA55-BF45AD43D530}.Ideal|Mixed Platforms.ActiveCfg = Release|x86
-               {2CE2CB44-953C-414F-BA55-BF45AD43D530}.Ideal|Mixed Platforms.Build.0 = Release|x86
-               {2CE2CB44-953C-414F-BA55-BF45AD43D530}.Ideal|Win32.ActiveCfg = Release|x86
-               {2CE2CB44-953C-414F-BA55-BF45AD43D530}.Ideal|x64.ActiveCfg = Release|x86
-               {2CE2CB44-953C-414F-BA55-BF45AD43D530}.Ideal|x86.ActiveCfg = Release|x86
-               {2CE2CB44-953C-414F-BA55-BF45AD43D530}.Ideal|x86.Build.0 = Release|x86
-               {2CE2CB44-953C-414F-BA55-BF45AD43D530}.Release|Any CPU.ActiveCfg = Release|x86
-               {2CE2CB44-953C-414F-BA55-BF45AD43D530}.Release|Any CPU.Build.0 = Release|x86
-               {2CE2CB44-953C-414F-BA55-BF45AD43D530}.Release|Mixed Platforms.ActiveCfg = Release|x86
-               {2CE2CB44-953C-414F-BA55-BF45AD43D530}.Release|Mixed Platforms.Build.0 = Release|x86
-               {2CE2CB44-953C-414F-BA55-BF45AD43D530}.Release|Win32.ActiveCfg = Release|x86
-               {2CE2CB44-953C-414F-BA55-BF45AD43D530}.Release|x64.ActiveCfg = Release|x86
-               {2CE2CB44-953C-414F-BA55-BF45AD43D530}.Release|x86.ActiveCfg = Release|x86
-               {2CE2CB44-953C-414F-BA55-BF45AD43D530}.Release|x86.Build.0 = Release|x86
-               {F5B505A7-EA88-45CC-A001-46D67077F382}.Debug|Any CPU.ActiveCfg = Debug|x86
-               {F5B505A7-EA88-45CC-A001-46D67077F382}.Debug|Any CPU.Build.0 = Debug|x86
-               {F5B505A7-EA88-45CC-A001-46D67077F382}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
-               {F5B505A7-EA88-45CC-A001-46D67077F382}.Debug|Mixed Platforms.Build.0 = Debug|x86
-               {F5B505A7-EA88-45CC-A001-46D67077F382}.Debug|Win32.ActiveCfg = Debug|x86
-               {F5B505A7-EA88-45CC-A001-46D67077F382}.Debug|x64.ActiveCfg = Debug|x86
-               {F5B505A7-EA88-45CC-A001-46D67077F382}.Debug|x86.ActiveCfg = Debug|x86
-               {F5B505A7-EA88-45CC-A001-46D67077F382}.Debug|x86.Build.0 = Debug|x86
-               {F5B505A7-EA88-45CC-A001-46D67077F382}.Ideal|Any CPU.ActiveCfg = Debug|x86
-               {F5B505A7-EA88-45CC-A001-46D67077F382}.Ideal|Any CPU.Build.0 = Debug|x86
-               {F5B505A7-EA88-45CC-A001-46D67077F382}.Ideal|Mixed Platforms.ActiveCfg = Release|x86
-               {F5B505A7-EA88-45CC-A001-46D67077F382}.Ideal|Mixed Platforms.Build.0 = Release|x86
-               {F5B505A7-EA88-45CC-A001-46D67077F382}.Ideal|Win32.ActiveCfg = Release|x86
-               {F5B505A7-EA88-45CC-A001-46D67077F382}.Ideal|x64.ActiveCfg = Release|x86
-               {F5B505A7-EA88-45CC-A001-46D67077F382}.Ideal|x86.ActiveCfg = Release|x86
-               {F5B505A7-EA88-45CC-A001-46D67077F382}.Ideal|x86.Build.0 = Release|x86
-               {F5B505A7-EA88-45CC-A001-46D67077F382}.Release|Any CPU.ActiveCfg = Release|x86
-               {F5B505A7-EA88-45CC-A001-46D67077F382}.Release|Any CPU.Build.0 = Release|x86
-               {F5B505A7-EA88-45CC-A001-46D67077F382}.Release|Mixed Platforms.ActiveCfg = Release|x86
-               {F5B505A7-EA88-45CC-A001-46D67077F382}.Release|Mixed Platforms.Build.0 = Release|x86
-               {F5B505A7-EA88-45CC-A001-46D67077F382}.Release|Win32.ActiveCfg = Release|x86
-               {F5B505A7-EA88-45CC-A001-46D67077F382}.Release|x64.ActiveCfg = Release|x86
-               {F5B505A7-EA88-45CC-A001-46D67077F382}.Release|x86.ActiveCfg = Release|x86
-               {F5B505A7-EA88-45CC-A001-46D67077F382}.Release|x86.Build.0 = Release|x86
                {2DA9CE8A-C82F-4CF2-8329-79B8A3F19F1F}.Debug|Any CPU.ActiveCfg = Debug|x86
                {2DA9CE8A-C82F-4CF2-8329-79B8A3F19F1F}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
                {2DA9CE8A-C82F-4CF2-8329-79B8A3F19F1F}.Debug|Mixed Platforms.Build.0 = Debug|x86
Only in /opt/mitls: www-data